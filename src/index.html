<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TLDraw</title>
  <script defer="defer" src="main.js"></script>
</head>

<body>
  <div id="root"></div>
  <script>
    (() => {
      var e, t, n = {
        3358: (e, t, n) => { "use strict"; n.d(t, { Z: () => g }); var r = n(8081), i = n.n(r), o = n(3645), a = n.n(o), s = n(1667), l = n.n(s), c = new URL(n(7413), n.b), u = new URL(n(8455), n.b), d = new URL(n(3998), n.b), p = a()(i()), h = l()(c), f = l()(u), m = l()(d); p.push([e.id, `/* caveat-brush-latin-ext-400-normal*/\n@font-face {\n  font-family: 'Caveat Brush';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${h}) format('woff2'), url(${f}) format('woff');\n  unicode-range: U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;\n}\n/* caveat-brush-latin-400-normal*/\n@font-face {\n  font-family: 'Caveat Brush';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${m}) format('woff2'), url(${f}) format('woff');\n  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;\n}\n`, ""]); const g = p }, 8756: (e, t, n) => { "use strict"; n.d(t, { Z: () => y }); var r = n(8081), i = n.n(r), o = n(3645), a = n.n(o), s = n(1667), l = n.n(s), c = new URL(n(5405), n.b), u = new URL(n(3076), n.b), d = new URL(n(2400), n.b), p = new URL(n(6879), n.b), h = a()(i()), f = l()(c), m = l()(u), g = l()(d), v = l()(p); h.push([e.id, `/* crimson-pro-vietnamese-400-normal*/\n@font-face {\n  font-family: 'Crimson Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${f}) format('woff2'), url(${m}) format('woff');\n  unicode-range: U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB;\n}\n/* crimson-pro-latin-ext-400-normal*/\n@font-face {\n  font-family: 'Crimson Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${g}) format('woff2'), url(${m}) format('woff');\n  unicode-range: U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;\n}\n/* crimson-pro-latin-400-normal*/\n@font-face {\n  font-family: 'Crimson Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${v}) format('woff2'), url(${m}) format('woff');\n  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;\n}\n`, ""]); const y = h }, 1073: (e, t, n) => { "use strict"; n.d(t, { Z: () => w }); var r = n(8081), i = n.n(r), o = n(3645), a = n.n(o), s = n(1667), l = n.n(s), c = new URL(n(7732), n.b), u = new URL(n(2240), n.b), d = new URL(n(8681), n.b), p = new URL(n(9325), n.b), h = new URL(n(2975), n.b), f = a()(i()), m = l()(c), g = l()(u), v = l()(d), y = l()(p), b = l()(h); f.push([e.id, `/* recursive-cyrillic-ext-400-normal*/\n@font-face {\n  font-family: 'Recursive';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${m}) format('woff2'), url(${g}) format('woff');\n  unicode-range: U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;\n}\n/* recursive-vietnamese-400-normal*/\n@font-face {\n  font-family: 'Recursive';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${v}) format('woff2'), url(${g}) format('woff');\n  unicode-range: U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB;\n}\n/* recursive-latin-ext-400-normal*/\n@font-face {\n  font-family: 'Recursive';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${y}) format('woff2'), url(${g}) format('woff');\n  unicode-range: U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;\n}\n/* recursive-latin-400-normal*/\n@font-face {\n  font-family: 'Recursive';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${b}) format('woff2'), url(${g}) format('woff');\n  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;\n}\n`, ""]); const w = f }, 9429: (e, t, n) => { "use strict"; n.d(t, { Z: () => A }); var r = n(8081), i = n.n(r), o = n(3645), a = n.n(o), s = n(1667), l = n.n(s), c = new URL(n(1512), n.b), u = new URL(n(8353), n.b), d = new URL(n(3221), n.b), p = new URL(n(5726), n.b), h = new URL(n(7604), n.b), f = new URL(n(5414), n.b), m = new URL(n(4279), n.b), g = new URL(n(6807), n.b), v = a()(i()), y = l()(c), b = l()(u), w = l()(d), E = l()(p), C = l()(h), S = l()(f), k = l()(m), x = l()(g); v.push([e.id, `/* source-code-pro-cyrillic-ext-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${y}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;\n}\n/* source-code-pro-cyrillic-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${w}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;\n}\n/* source-code-pro-greek-ext-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${E}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+1F00-1FFF;\n}\n/* source-code-pro-greek-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${C}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0370-03FF;\n}\n/* source-code-pro-vietnamese-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${S}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB;\n}\n/* source-code-pro-latin-ext-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${k}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;\n}\n/* source-code-pro-latin-400-normal*/\n@font-face {\n  font-family: 'Source Code Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${x}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;\n}\n`, ""]); const A = v }, 2905: (e, t, n) => { "use strict"; n.d(t, { Z: () => A }); var r = n(8081), i = n.n(r), o = n(3645), a = n.n(o), s = n(1667), l = n.n(s), c = new URL(n(7722), n.b), u = new URL(n(3102), n.b), d = new URL(n(5582), n.b), p = new URL(n(3047), n.b), h = new URL(n(549), n.b), f = new URL(n(5417), n.b), m = new URL(n(6882), n.b), g = new URL(n(7306), n.b), v = a()(i()), y = l()(c), b = l()(u), w = l()(d), E = l()(p), C = l()(h), S = l()(f), k = l()(m), x = l()(g); v.push([e.id, `/* source-sans-pro-cyrillic-ext-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${y}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F;\n}\n/* source-sans-pro-cyrillic-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${w}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116;\n}\n/* source-sans-pro-greek-ext-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${E}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+1F00-1FFF;\n}\n/* source-sans-pro-greek-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${C}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0370-03FF;\n}\n/* source-sans-pro-vietnamese-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${S}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB;\n}\n/* source-sans-pro-latin-ext-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${k}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;\n}\n/* source-sans-pro-latin-400-normal*/\n@font-face {\n  font-family: 'Source Sans Pro';\n  font-style: normal;\n  font-display: swap;\n  font-weight: 400;\n  src: url(${x}) format('woff2'), url(${b}) format('woff');\n  unicode-range: U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;\n}\n`, ""]); const A = v }, 1424: (e, t, n) => { "use strict"; n.d(t, { Z: () => s }); var r = n(8081), i = n.n(r), o = n(3645), a = n.n(o)()(i()); a.push([e.id, "html,\n* {\n\tbox-sizing: border-box;\n}\n\nbody {\n\toverscroll-behavior: none;\n\tmargin: 0px;\n\tpadding: 0px;\n}\n\n.tldraw {\n\tposition: fixed;\n\ttop: 0px;\n\tleft: 0px;\n\tbottom: 0px;\n\tright: 0px;\n\twidth: 100%;\n\theight: 100%;\n\toverflow: hidden;\n}\n\n.tlui-help-menu,\n.tlui-toolbar__inner {\n\tmargin-bottom: 15px;\n}", ""]); const s = a }, 3645: e => { "use strict"; e.exports = function (e) { var t = []; return t.toString = function () { return this.map((function (t) { var n = "", r = void 0 !== t[5]; return t[4] && (n += "@supports (".concat(t[4], ") {")), t[2] && (n += "@media ".concat(t[2], " {")), r && (n += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")), n += e(t), r && (n += "}"), t[2] && (n += "}"), t[4] && (n += "}"), n })).join("") }, t.i = function (e, n, r, i, o) { "string" == typeof e && (e = [[null, e, void 0]]); var a = {}; if (r) for (var s = 0; s < this.length; s++) { var l = this[s][0]; null != l && (a[l] = !0) } for (var c = 0; c < e.length; c++) { var u = [].concat(e[c]); r && a[u[0]] || (void 0 !== o && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = o), n && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = n) : u[2] = n), i && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = i) : u[4] = "".concat(i)), t.push(u)) } }, t } }, 1667: e => { "use strict"; e.exports = function (e, t) { return t || (t = {}), e ? (e = String(e.__esModule ? e.default : e), /^['"].*['"]$/.test(e) && (e = e.slice(1, -1)), t.hash && (e += t.hash), /["'() \t\n]|(%20)/.test(e) || t.needQuotes ? '"'.concat(e.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : e) : e } }, 8081: e => { "use strict"; e.exports = function (e) { return e[1] } }, 8679: (e, t, n) => { "use strict"; var r = n(1296), i = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, o = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, a = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, s = {}; function l(e) { return r.isMemo(e) ? a : s[e.$$typeof] || i } s[r.ForwardRef] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, s[r.Memo] = a; var c = Object.defineProperty, u = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, p = Object.getOwnPropertyDescriptor, h = Object.getPrototypeOf, f = Object.prototype; e.exports = function e(t, n, r) { if ("string" != typeof n) { if (f) { var i = h(n); i && i !== f && e(t, i, r) } var a = u(n); d && (a = a.concat(d(n))); for (var s = l(t), m = l(n), g = 0; g < a.length; ++g) { var v = a[g]; if (!(o[v] || r && r[v] || m && m[v] || s && s[v])) { var y = p(n, v); try { c(t, v, y) } catch (e) { } } } } return t } }, 6103: (e, t) => { "use strict"; var n = "function" == typeof Symbol && Symbol.for, r = n ? Symbol.for("react.element") : 60103, i = n ? Symbol.for("react.portal") : 60106, o = n ? Symbol.for("react.fragment") : 60107, a = n ? Symbol.for("react.strict_mode") : 60108, s = n ? Symbol.for("react.profiler") : 60114, l = n ? Symbol.for("react.provider") : 60109, c = n ? Symbol.for("react.context") : 60110, u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111, p = n ? Symbol.for("react.forward_ref") : 60112, h = n ? Symbol.for("react.suspense") : 60113, f = n ? Symbol.for("react.suspense_list") : 60120, m = n ? Symbol.for("react.memo") : 60115, g = n ? Symbol.for("react.lazy") : 60116, v = n ? Symbol.for("react.block") : 60121, y = n ? Symbol.for("react.fundamental") : 60117, b = n ? Symbol.for("react.responder") : 60118, w = n ? Symbol.for("react.scope") : 60119; function E(e) { if ("object" == typeof e && null !== e) { var t = e.$$typeof; switch (t) { case r: switch (e = e.type) { case u: case d: case o: case s: case a: case h: return e; default: switch (e = e && e.$$typeof) { case c: case p: case g: case m: case l: return e; default: return t } }case i: return t } } } function C(e) { return E(e) === d } t.AsyncMode = u, t.ConcurrentMode = d, t.ContextConsumer = c, t.ContextProvider = l, t.Element = r, t.ForwardRef = p, t.Fragment = o, t.Lazy = g, t.Memo = m, t.Portal = i, t.Profiler = s, t.StrictMode = a, t.Suspense = h, t.isAsyncMode = function (e) { return C(e) || E(e) === u }, t.isConcurrentMode = C, t.isContextConsumer = function (e) { return E(e) === c }, t.isContextProvider = function (e) { return E(e) === l }, t.isElement = function (e) { return "object" == typeof e && null !== e && e.$$typeof === r }, t.isForwardRef = function (e) { return E(e) === p }, t.isFragment = function (e) { return E(e) === o }, t.isLazy = function (e) { return E(e) === g }, t.isMemo = function (e) { return E(e) === m }, t.isPortal = function (e) { return E(e) === i }, t.isProfiler = function (e) { return E(e) === s }, t.isStrictMode = function (e) { return E(e) === a }, t.isSuspense = function (e) { return E(e) === h }, t.isValidElementType = function (e) { return "string" == typeof e || "function" == typeof e || e === o || e === d || e === s || e === a || e === h || e === f || "object" == typeof e && null !== e && (e.$$typeof === g || e.$$typeof === m || e.$$typeof === l || e.$$typeof === c || e.$$typeof === p || e.$$typeof === y || e.$$typeof === b || e.$$typeof === w || e.$$typeof === v) }, t.typeOf = E }, 1296: (e, t, n) => { "use strict"; e.exports = n(6103) }, 4448: (e, t, n) => { "use strict"; var r = n(7294), i = n(3840); function o(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = new Set, s = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (s[e] = t, e = 0; e < t.length; e++)a.add(t[e]) } var u = !("undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement), d = Object.prototype.hasOwnProperty, p = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, h = {}, f = {}; function m(e, t, n, r, i, o, a) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = a } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var v = /[\-:]([a-z])/g; function y(e) { return e[1].toUpperCase() } function b(e, t, n, r) { var i = g.hasOwnProperty(t) ? g[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null == t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!d.call(f, e) || !d.call(h, e) && (p.test(e) ? f[e] = !0 : (h[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, E = Symbol.for("react.element"), C = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), k = Symbol.for("react.strict_mode"), x = Symbol.for("react.profiler"), A = Symbol.for("react.provider"), I = Symbol.for("react.context"), P = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), T = Symbol.for("react.suspense_list"), R = Symbol.for("react.memo"), B = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var D = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var L = Symbol.iterator; function O(e) { return null === e || "object" != typeof e ? null : "function" == typeof (e = L && e[L] || e["@@iterator"]) ? e : null } var F, z = Object.assign; function H(e) { if (void 0 === F) try { throw Error() } catch (e) { var t = e.stack.trim().match(/\n( *(at )?)/); F = t && t[1] || "" } return "\n" + F + e } var N = !1; function j(e, t) { if (!e || N) return ""; N = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" == typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (e) { var r = e } Reflect.construct(e, [], t) } else { try { t.call() } catch (e) { r = e } e.call(t.prototype) } else { try { throw Error() } catch (e) { r = e } e() } } catch (t) { if (t && r && "string" == typeof t.stack) { for (var i = t.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];)s--; for (; 1 <= a && 0 <= s; a--, s--)if (i[a] !== o[s]) { if (1 !== a || 1 !== s) do { if (a--, 0 > --s || i[a] !== o[s]) { var l = "\n" + i[a].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= a && 0 <= s); break } } } finally { N = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? H(e) : "" } function U(e) { switch (e.tag) { case 5: return H(e.type); case 16: return H("Lazy"); case 13: return H("Suspense"); case 19: return H("SuspenseList"); case 0: case 2: case 15: return j(e.type, !1); case 11: return j(e.type.render, !1); case 1: return j(e.type, !0); default: return "" } } function V(e) { if (null == e) return null; if ("function" == typeof e) return e.displayName || e.name || null; if ("string" == typeof e) return e; switch (e) { case S: return "Fragment"; case C: return "Portal"; case x: return "Profiler"; case k: return "StrictMode"; case M: return "Suspense"; case T: return "SuspenseList" }if ("object" == typeof e) switch (e.$$typeof) { case I: return (e.displayName || "Context") + ".Consumer"; case A: return (e._context.displayName || "Context") + ".Provider"; case P: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case R: return null !== (t = e.displayName || null) ? t : V(e.type) || "Memo"; case B: t = e._payload, e = e._init; try { return V(e(t)) } catch (e) { } }return null } function K(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return V(t); case 8: return t === k ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" == typeof t) return t.displayName || t.name || null; if ("string" == typeof t) return t }return null } function W(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function Y(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function G(e) { e._valueTracker || (e._valueTracker = function (e) { var t = Y(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, o.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function Z(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = Y(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function X(e) { if (void 0 === (e = e || ("undefined" != typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function _(e, t) { var n = t.checked; return z({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function Q(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = W(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function q(e, t) { null != (t = t.checked) && b(e, "checked", t, !1) } function J(e, t) { q(e, t); var n = W(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, W(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function $(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && X(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + W(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(o(91)); return z({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(o(92)); if (te(n)) { if (1 < n.length) throw Error(o(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: W(n) } } function oe(e, t) { var n = W(t.value), r = W(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function ae(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function se(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function pe(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var he = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, fe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" == typeof t || "" === t ? "" : n || "number" != typeof t || 0 === t || he.hasOwnProperty(e) && he[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = me(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(he).forEach((function (e) { fe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), he[t] = he[e] })) })); var ve = z({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ye(e, t) { if (t) { if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(o(60)); if ("object" != typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61)) } if (null != t.style && "object" != typeof t.style) throw Error(o(62)) } } function be(e, t) { if (-1 === e.indexOf("-")) return "string" == typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var we = null; function Ee(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var Ce = null, Se = null, ke = null; function xe(e) { if (e = bi(e)) { if ("function" != typeof Ce) throw Error(o(280)); var t = e.stateNode; t && (t = Ei(t), Ce(e.stateNode, e.type, t)) } } function Ae(e) { Se ? ke ? ke.push(e) : ke = [e] : Se = e } function Ie() { if (Se) { var e = Se, t = ke; if (ke = Se = null, xe(e), t) for (e = 0; e < t.length; e++)xe(t[e]) } } function Pe(e, t) { return e(t) } function Me() { } var Te = !1; function Re(e, t, n) { if (Te) return e(t, n); Te = !0; try { return Pe(e, t, n) } finally { Te = !1, (null !== Se || null !== ke) && (Me(), Ie()) } } function Be(e, t) { var n = e.stateNode; if (null === n) return null; var r = Ei(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" != typeof n) throw Error(o(231, t, typeof n)); return n } var De = !1; if (u) try { var Le = {}; Object.defineProperty(Le, "passive", { get: function () { De = !0 } }), window.addEventListener("test", Le, Le), window.removeEventListener("test", Le, Le) } catch (ue) { De = !1 } function Oe(e, t, n, r, i, o, a, s, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (e) { this.onError(e) } } var Fe = !1, ze = null, He = !1, Ne = null, je = { onError: function (e) { Fe = !0, ze = e } }; function Ue(e, t, n, r, i, o, a, s, l) { Fe = !1, ze = null, Oe.apply(je, arguments) } function Ve(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 != (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function Ke(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && null !== (e = e.alternate) && (t = e.memoizedState), null !== t) return t.dehydrated } return null } function We(e) { if (Ve(e) !== e) throw Error(o(188)) } function Ye(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = Ve(e))) throw Error(o(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var a = i.alternate; if (null === a) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === a.child) { for (a = i.child; a;) { if (a === n) return We(i), e; if (a === r) return We(i), t; a = a.sibling } throw Error(o(188)) } if (n.return !== r.return) n = i, r = a; else { for (var s = !1, l = i.child; l;) { if (l === n) { s = !0, n = i, r = a; break } if (l === r) { s = !0, r = i, n = a; break } l = l.sibling } if (!s) { for (l = a.child; l;) { if (l === n) { s = !0, n = a, r = i; break } if (l === r) { s = !0, r = a, n = i; break } l = l.sibling } if (!s) throw Error(o(189)) } } if (n.alternate !== r) throw Error(o(190)) } if (3 !== n.tag) throw Error(o(188)); return n.stateNode.current === n ? e : t }(e)) ? Ge(e) : null } function Ge(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Ge(e); if (null !== t) return t; e = e.sibling } return null } var Ze = i.unstable_scheduleCallback, Xe = i.unstable_cancelCallback, _e = i.unstable_shouldYield, Qe = i.unstable_requestPaint, qe = i.unstable_now, Je = i.unstable_getCurrentPriorityLevel, $e = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, ot = null, at = Math.clz32 ? Math.clz32 : function (e) { return 0 === (e >>>= 0) ? 32 : 31 - (st(e) / lt | 0) | 0 }, st = Math.log, lt = Math.LN2, ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function pt(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, a = 268435455 & n; if (0 !== a) { var s = a & ~i; 0 !== s ? r = dt(s) : 0 != (o &= a) && (r = dt(o)) } else 0 != (a = n & ~i) ? r = dt(a) : 0 !== o && (r = dt(o)); if (0 === r) return 0; if (0 !== t && t !== r && 0 == (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 != (4194240 & o))) return t; if (0 != (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - at(t)), r |= e[n], t &= ~i; return r } function ht(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function ft(e) { return 0 != (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return 0 == (4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function vt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n } function yt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - at(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var bt = 0; function wt(e) { return 1 < (e &= -e) ? 4 < e ? 0 != (268435455 & e) ? 16 : 536870912 : 4 : 1 } var Et, Ct, St, kt, xt, At = !1, It = [], Pt = null, Mt = null, Tt = null, Rt = new Map, Bt = new Map, Dt = [], Lt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Ot(e, t) { switch (e) { case "focusin": case "focusout": Pt = null; break; case "dragenter": case "dragleave": Mt = null; break; case "mouseover": case "mouseout": Tt = null; break; case "pointerover": case "pointerout": Rt.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Bt.delete(t.pointerId) } } function Ft(e, t, n, r, i, o) { return null === e || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, null !== t && null !== (t = bi(t)) && Ct(t), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function zt(e) { var t = yi(e.target); if (null !== t) { var n = Ve(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = Ke(n))) return e.blockedOn = t, void xt(e.priority, (function () { St(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function Ht(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = _t(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = bi(n)) && Ct(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); we = r, n.target.dispatchEvent(r), we = null, t.shift() } return !0 } function Nt(e, t, n) { Ht(e) && n.delete(t) } function jt() { At = !1, null !== Pt && Ht(Pt) && (Pt = null), null !== Mt && Ht(Mt) && (Mt = null), null !== Tt && Ht(Tt) && (Tt = null), Rt.forEach(Nt), Bt.forEach(Nt) } function Ut(e, t) { e.blockedOn === t && (e.blockedOn = null, At || (At = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, jt))) } function Vt(e) { function t(t) { return Ut(t, e) } if (0 < It.length) { Ut(It[0], e); for (var n = 1; n < It.length; n++) { var r = It[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== Pt && Ut(Pt, e), null !== Mt && Ut(Mt, e), null !== Tt && Ut(Tt, e), Rt.forEach(t), Bt.forEach(t), n = 0; n < Dt.length; n++)(r = Dt[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Dt.length && null === (n = Dt[0]).blockedOn;)zt(n), null === n.blockedOn && Dt.shift() } var Kt = w.ReactCurrentBatchConfig, Wt = !0; function Yt(e, t, n, r) { var i = bt, o = Kt.transition; Kt.transition = null; try { bt = 1, Zt(e, t, n, r) } finally { bt = i, Kt.transition = o } } function Gt(e, t, n, r) { var i = bt, o = Kt.transition; Kt.transition = null; try { bt = 4, Zt(e, t, n, r) } finally { bt = i, Kt.transition = o } } function Zt(e, t, n, r) { if (Wt) { var i = _t(e, t, n, r); if (null === i) Wr(e, t, r, Xt, n), Ot(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return Pt = Ft(Pt, e, t, n, r, i), !0; case "dragenter": return Mt = Ft(Mt, e, t, n, r, i), !0; case "mouseover": return Tt = Ft(Tt, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return Rt.set(o, Ft(Rt.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, Bt.set(o, Ft(Bt.get(o) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (Ot(e, r), 4 & t && -1 < Lt.indexOf(e)) { for (; null !== i;) { var o = bi(i); if (null !== o && Et(o), null === (o = _t(e, t, n, r)) && Wr(e, t, r, Xt, n), o === i) break; i = o } null !== i && r.stopPropagation() } else Wr(e, t, r, null, n) } } var Xt = null; function _t(e, t, n, r) { if (Xt = null, null !== (e = yi(e = Ee(r)))) if (null === (t = Ve(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = Ke(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Xt = e, null } function Qt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Je()) { case $e: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var qt = null, Jt = null, $t = null; function en() { if ($t) return $t; var e, t, n = Jt, r = n.length, i = "value" in qt ? qt.value : qt.textContent, o = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var a = r - e; for (t = 1; t <= a && n[r - t] === i[o - t]; t++); return $t = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function on(e) { function t(t, n, r, i, o) { for (var a in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(i) : i[a]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return z(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" != typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" != typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var an, sn, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = on(cn), dn = z({}, cn, { view: 0, detail: 0 }), pn = on(dn), hn = z({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: xn, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX, sn = e.screenY - ln.screenY) : sn = an = 0, ln = e), an) }, movementY: function (e) { return "movementY" in e ? e.movementY : sn } }), fn = on(hn), mn = on(z({}, hn, { dataTransfer: 0 })), gn = on(z({}, dn, { relatedTarget: 0 })), vn = on(z({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), yn = z({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), bn = on(yn), wn = on(z({}, cn, { data: 0 })), En = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Cn = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Sn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function kn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = Sn[e]) && !!t[e] } function xn() { return kn } var An = z({}, dn, { key: function (e) { if (e.key) { var t = En[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Cn[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: xn, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), In = on(An), Pn = on(z({}, hn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Mn = on(z({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: xn })), Tn = on(z({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), Rn = z({}, hn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Bn = on(Rn), Dn = [9, 13, 27, 32], Ln = u && "CompositionEvent" in window, On = null; u && "documentMode" in document && (On = document.documentMode); var Fn = u && "TextEvent" in window && !On, zn = u && (!Ln || On && 8 < On && 11 >= On), Hn = String.fromCharCode(32), Nn = !1; function jn(e, t) { switch (e) { case "keyup": return -1 !== Dn.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Un(e) { return "object" == typeof (e = e.detail) && "data" in e ? e.data : null } var Vn = !1, Kn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Wn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!Kn[e.type] : "textarea" === t } function Yn(e, t, n, r) { Ae(r), 0 < (t = Gr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Gn = null, Zn = null; function Xn(e) { Hr(e, 0) } function _n(e) { if (Z(wi(e))) return e } function Qn(e, t) { if ("change" === e) return t } var qn = !1; if (u) { var Jn; if (u) { var $n = "oninput" in document; if (!$n) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), $n = "function" == typeof er.oninput } Jn = $n } else Jn = !1; qn = Jn && (!document.documentMode || 9 < document.documentMode) } function tr() { Gn && (Gn.detachEvent("onpropertychange", nr), Zn = Gn = null) } function nr(e) { if ("value" === e.propertyName && _n(Zn)) { var t = []; Yn(t, Zn, e, Ee(e)), Re(Xn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), Zn = n, (Gn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return _n(Zn) } function or(e, t) { if ("click" === e) return _n(t) } function ar(e, t) { if ("input" === e || "change" === e) return _n(t) } var sr = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }; function lr(e, t) { if (sr(e, t)) return !0; if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!d.call(t, i) || !sr(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function dr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function pr() { for (var e = window, t = X(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" == typeof t.contentWindow.location.href } catch (e) { n = !1 } if (!n) break; t = X((e = t.contentWindow).document) } return t } function hr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function fr(e) { var t = pr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) { if (null !== r && hr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = ur(n, o); var a = ur(n, r); i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" == typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, vr = null, yr = null, br = !1; function wr(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; br || null == gr || gr !== X(r) || (r = "selectionStart" in (r = gr) && hr(r) ? { start: r.selectionStart, end: r.selectionEnd } : { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, yr && lr(yr, r) || (yr = r, 0 < (r = Gr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = gr))) } function Er(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Cr = { animationend: Er("Animation", "AnimationEnd"), animationiteration: Er("Animation", "AnimationIteration"), animationstart: Er("Animation", "AnimationStart"), transitionend: Er("Transition", "TransitionEnd") }, Sr = {}, kr = {}; function xr(e) { if (Sr[e]) return Sr[e]; if (!Cr[e]) return e; var t, n = Cr[e]; for (t in n) if (n.hasOwnProperty(t) && t in kr) return Sr[e] = n[t]; return e } u && (kr = document.createElement("div").style, "AnimationEvent" in window || (delete Cr.animationend.animation, delete Cr.animationiteration.animation, delete Cr.animationstart.animation), "TransitionEvent" in window || delete Cr.transitionend.transition); var Ar = xr("animationend"), Ir = xr("animationiteration"), Pr = xr("animationstart"), Mr = xr("transitionend"), Tr = new Map, Rr = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Br(e, t) { Tr.set(e, t), l(t, [e]) } for (var Dr = 0; Dr < Rr.length; Dr++) { var Lr = Rr[Dr]; Br(Lr.toLowerCase(), "on" + (Lr[0].toUpperCase() + Lr.slice(1))) } Br(Ar, "onAnimationEnd"), Br(Ir, "onAnimationIteration"), Br(Pr, "onAnimationStart"), Br("dblclick", "onDoubleClick"), Br("focusin", "onFocus"), Br("focusout", "onBlur"), Br(Mr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Or = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Fr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Or)); function zr(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, a, s, l, c) { if (Ue.apply(this, arguments), Fe) { if (!Fe) throw Error(o(198)); var u = ze; Fe = !1, ze = null, He || (He = !0, Ne = u) } }(r, t, void 0, e), e.currentTarget = null } function Hr(e, t) { t = 0 != (4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var a = r.length - 1; 0 <= a; a--) { var s = r[a], l = s.instance, c = s.currentTarget; if (s = s.listener, l !== o && i.isPropagationStopped()) break e; zr(i, s, c), o = l } else for (a = 0; a < r.length; a++) { if (l = (s = r[a]).instance, c = s.currentTarget, s = s.listener, l !== o && i.isPropagationStopped()) break e; zr(i, s, c), o = l } } } if (He) throw e = Ne, He = !1, Ne = null, e } function Nr(e, t) { var n = t[mi]; void 0 === n && (n = t[mi] = new Set); var r = e + "__bubble"; n.has(r) || (Kr(t, e, 2, !1), n.add(r)) } function jr(e, t, n) { var r = 0; t && (r |= 4), Kr(n, e, r, t) } var Ur = "_reactListening" + Math.random().toString(36).slice(2); function Vr(e) { if (!e[Ur]) { e[Ur] = !0, a.forEach((function (t) { "selectionchange" !== t && (Fr.has(t) || jr(t, !1, e), jr(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Ur] || (t[Ur] = !0, jr("selectionchange", !1, t)) } } function Kr(e, t, n, r) { switch (Qt(t)) { case 1: var i = Yt; break; case 4: i = Gt; break; default: i = Zt }n = i.bind(null, t, n, e), i = void 0, !De || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Wr(e, t, n, r, i) { var o = r; if (0 == (1 & t) && 0 == (2 & t) && null !== r) e: for (; ;) { if (null === r) return; var a = r.tag; if (3 === a || 4 === a) { var s = r.stateNode.containerInfo; if (s === i || 8 === s.nodeType && s.parentNode === i) break; if (4 === a) for (a = r.return; null !== a;) { var l = a.tag; if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; a = a.return } for (; null !== s;) { if (null === (a = yi(s))) return; if (5 === (l = a.tag) || 6 === l) { r = o = a; continue e } s = s.parentNode } } r = r.return } Re((function () { var r = o, i = Ee(n), a = []; e: { var s = Tr.get(e); if (void 0 !== s) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = In; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = fn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = Mn; break; case Ar: case Ir: case Pr: l = vn; break; case Mr: l = Tn; break; case "scroll": l = pn; break; case "wheel": l = Bn; break; case "copy": case "cut": case "paste": l = bn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = Pn }var u = 0 != (4 & t), d = !u && "scroll" === e, p = u ? null !== s ? s + "Capture" : null : s; u = []; for (var h, f = r; null !== f;) { var m = (h = f).stateNode; if (5 === h.tag && null !== m && (h = m, null !== p && null != (m = Be(f, p)) && u.push(Yr(f, m, h))), d) break; f = f.return } 0 < u.length && (s = new l(s, c, null, n, i), a.push({ event: s, listeners: u })) } } if (0 == (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(s = "mouseover" === e || "pointerover" === e) || n === we || !(c = n.relatedTarget || n.fromElement) || !yi(c) && !c[fi]) && (l || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? yi(c) : null) && (c !== (d = Ve(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = fn, m = "onMouseLeave", p = "onMouseEnter", f = "mouse", "pointerout" !== e && "pointerover" !== e || (u = Pn, m = "onPointerLeave", p = "onPointerEnter", f = "pointer"), d = null == l ? s : wi(l), h = null == c ? s : wi(c), (s = new u(m, f + "leave", l, n, i)).target = d, s.relatedTarget = h, m = null, yi(i) === r && ((u = new u(p, f + "enter", c, n, i)).target = h, u.relatedTarget = d, m = u), d = m, l && c) e: { for (p = c, f = 0, h = u = l; h; h = Zr(h))f++; for (h = 0, m = p; m; m = Zr(m))h++; for (; 0 < f - h;)u = Zr(u), f--; for (; 0 < h - f;)p = Zr(p), h--; for (; f--;) { if (u === p || null !== p && u === p.alternate) break e; u = Zr(u), p = Zr(p) } u = null } else u = null; null !== l && Xr(a, s, l, u, !1), null !== c && null !== d && Xr(a, d, c, u, !0) } if ("select" === (l = (s = r ? wi(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === l && "file" === s.type) var g = Qn; else if (Wn(s)) if (qn) g = ar; else { g = ir; var v = rr } else (l = s.nodeName) && "input" === l.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (g = or); switch (g && (g = g(e, r)) ? Yn(a, g, n, i) : (v && v(e, s, r), "focusout" === e && (v = s._wrapperState) && v.controlled && "number" === s.type && ee(s, "number", s.value)), v = r ? wi(r) : window, e) { case "focusin": (Wn(v) || "true" === v.contentEditable) && (gr = v, vr = r, yr = null); break; case "focusout": yr = vr = gr = null; break; case "mousedown": br = !0; break; case "contextmenu": case "mouseup": case "dragend": br = !1, wr(a, n, i); break; case "selectionchange": if (mr) break; case "keydown": case "keyup": wr(a, n, i) }var y; if (Ln) e: { switch (e) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else Vn ? jn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart"); b && (zn && "ko" !== n.locale && (Vn || "onCompositionStart" !== b ? "onCompositionEnd" === b && Vn && (y = en()) : (Jt = "value" in (qt = i) ? qt.value : qt.textContent, Vn = !0)), 0 < (v = Gr(r, b)).length && (b = new wn(b, e, null, n, i), a.push({ event: b, listeners: v }), (y || null !== (y = Un(n))) && (b.data = y))), (y = Fn ? function (e, t) { switch (e) { case "compositionend": return Un(t); case "keypress": return 32 !== t.which ? null : (Nn = !0, Hn); case "textInput": return (e = t.data) === Hn && Nn ? null : e; default: return null } }(e, n) : function (e, t) { if (Vn) return "compositionend" === e || !Ln && jn(e, t) ? (e = en(), $t = Jt = qt = null, Vn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return zn && "ko" !== t.locale ? null : t.data } }(e, n)) && 0 < (r = Gr(r, "onBeforeInput")).length && (i = new wn("onBeforeInput", "beforeinput", null, n, i), a.push({ event: i, listeners: r }), i.data = y) } Hr(a, t) })) } function Yr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Gr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, o = i.stateNode; 5 === i.tag && null !== o && (i = o, null != (o = Be(e, n)) && r.unshift(Yr(e, o, i)), null != (o = Be(e, t)) && r.push(Yr(e, o, i))), e = e.return } return r } function Zr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Xr(e, t, n, r, i) { for (var o = t._reactName, a = []; null !== n && n !== r;) { var s = n, l = s.alternate, c = s.stateNode; if (null !== l && l === r) break; 5 === s.tag && null !== c && (s = c, i ? null != (l = Be(n, o)) && a.unshift(Yr(n, l, s)) : i || null != (l = Be(n, o)) && a.push(Yr(n, l, s))), n = n.return } 0 !== a.length && e.push({ event: t, listeners: a }) } var _r = /\r\n?/g, Qr = /\u0000|\uFFFD/g; function qr(e) { return ("string" == typeof e ? e : "" + e).replace(_r, "\n").replace(Qr, "") } function Jr(e, t, n) { if (t = qr(t), qr(e) !== t && n) throw Error(o(425)) } function $r() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" == typeof t.children || "number" == typeof t.children || "object" == typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" == typeof setTimeout ? setTimeout : void 0, ii = "function" == typeof clearTimeout ? clearTimeout : void 0, oi = "function" == typeof Promise ? Promise : void 0, ai = "function" == typeof queueMicrotask ? queueMicrotask : void 0 !== oi ? function (e) { return oi.resolve(null).then(e).catch(si) } : ri; function si(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void Vt(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); Vt(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var di = Math.random().toString(36).slice(2), pi = "__reactFiber$" + di, hi = "__reactProps$" + di, fi = "__reactContainer$" + di, mi = "__reactEvents$" + di, gi = "__reactListeners$" + di, vi = "__reactHandles$" + di; function yi(e) { var t = e[pi]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[fi] || n[pi]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[pi]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function bi(e) { return !(e = e[pi] || e[fi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function wi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(o(33)) } function Ei(e) { return e[hi] || null } var Ci = [], Si = -1; function ki(e) { return { current: e } } function xi(e) { 0 > Si || (e.current = Ci[Si], Ci[Si] = null, Si--) } function Ai(e, t) { Si++, Ci[Si] = e.current, e.current = t } var Ii = {}, Pi = ki(Ii), Mi = ki(!1), Ti = Ii; function Ri(e, t) { var n = e.type.contextTypes; if (!n) return Ii; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, o = {}; for (i in n) o[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function Bi(e) { return null != e.childContextTypes } function Di() { xi(Mi), xi(Pi) } function Li(e, t, n) { if (Pi.current !== Ii) throw Error(o(168)); Ai(Pi, t), Ai(Mi, n) } function Oi(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" != typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(o(108, K(e) || "Unknown", i)); return z({}, n, r) } function Fi(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Ii, Ti = Pi.current, Ai(Pi, e), Ai(Mi, Mi.current), !0 } function zi(e, t, n) { var r = e.stateNode; if (!r) throw Error(o(169)); n ? (e = Oi(e, t, Ti), r.__reactInternalMemoizedMergedChildContext = e, xi(Mi), xi(Pi), Ai(Pi, e)) : xi(Mi), Ai(Mi, n) } var Hi = null, Ni = !1, ji = !1; function Ui(e) { null === Hi ? Hi = [e] : Hi.push(e) } function Vi() { if (!ji && null !== Hi) { ji = !0; var e = 0, t = bt; try { var n = Hi; for (bt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Hi = null, Ni = !1 } catch (t) { throw null !== Hi && (Hi = Hi.slice(e + 1)), Ze($e, Vi), t } finally { bt = t, ji = !1 } } return null } var Ki = [], Wi = 0, Yi = null, Gi = 0, Zi = [], Xi = 0, _i = null, Qi = 1, qi = ""; function Ji(e, t) { Ki[Wi++] = Gi, Ki[Wi++] = Yi, Yi = e, Gi = t } function $i(e, t, n) { Zi[Xi++] = Qi, Zi[Xi++] = qi, Zi[Xi++] = _i, _i = e; var r = Qi; e = qi; var i = 32 - at(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - at(t) + i; if (30 < o) { var a = i - i % 5; o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Qi = 1 << 32 - at(t) + i | n << i | r, qi = o + e } else Qi = 1 << o | n << i | r, qi = e } function eo(e) { null !== e.return && (Ji(e, 1), $i(e, 1, 0)) } function to(e) { for (; e === Yi;)Yi = Ki[--Wi], Ki[Wi] = null, Gi = Ki[--Wi], Ki[Wi] = null; for (; e === _i;)_i = Zi[--Xi], Zi[Xi] = null, qi = Zi[--Xi], Zi[Xi] = null, Qi = Zi[--Xi], Zi[Xi] = null } var no = null, ro = null, io = !1, oo = null; function ao(e, t) { var n = Bc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function so(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== _i ? { id: Qi, overflow: qi } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Bc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0); default: return !1 } } function lo(e) { return 0 != (1 & e.mode) && 0 == (128 & e.flags) } function co(e) { if (io) { var t = ro; if (t) { var n = t; if (!so(e, t)) { if (lo(e)) throw Error(o(418)); t = ci(n.nextSibling); var r = no; t && so(e, t) ? ao(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e) } } else { if (lo(e)) throw Error(o(418)); e.flags = -4097 & e.flags | 2, io = !1, no = e } } } function uo(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; no = e } function po(e) { if (e !== no) return !1; if (!io) return uo(e), io = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) { if (lo(e)) throw ho(), Error(o(418)); for (; t;)ao(e, t), t = ci(t.nextSibling) } if (uo(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { ro = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } ro = null } } else ro = no ? ci(e.stateNode.nextSibling) : null; return !0 } function ho() { for (var e = ro; e;)e = ci(e.nextSibling) } function fo() { ro = no = null, io = !1 } function mo(e) { null === oo ? oo = [e] : oo.push(e) } var go = w.ReactCurrentBatchConfig; function vo(e, t) { if (e && e.defaultProps) { for (var n in t = z({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var yo = ki(null), bo = null, wo = null, Eo = null; function Co() { Eo = wo = bo = null } function So(e) { var t = yo.current; xi(yo), e._currentValue = t } function ko(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function xo(e, t) { bo = e, Eo = wo = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 != (e.lanes & t) && (ws = !0), e.firstContext = null) } function Ao(e) { var t = e._currentValue; if (Eo !== e) if (e = { context: e, memoizedValue: t, next: null }, null === wo) { if (null === bo) throw Error(o(308)); wo = e, bo.dependencies = { lanes: 0, firstContext: e } } else wo = wo.next = e; return t } var Io = null; function Po(e) { null === Io ? Io = [e] : Io.push(e) } function Mo(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, Po(t)) : (n.next = i.next, i.next = n), t.interleaved = n, To(e, r) } function To(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var Ro = !1; function Bo(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Do(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Lo(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Oo(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 != (2 & Ml)) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, To(e, n) } return null === (i = r.interleaved) ? (t.next = t, Po(r)) : (t.next = i.next, i.next = t), r.interleaved = t, To(e, n) } function Fo(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 != (4194240 & n))) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } function zo(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, o = null; if (null !== (n = n.firstBaseUpdate)) { do { var a = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === o ? i = o = a : o = o.next = a, n = n.next } while (null !== n); null === o ? i = o = t : o = o.next = t } else i = o = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Ho(e, t, n, r) { var i = e.updateQueue; Ro = !1; var o = i.firstBaseUpdate, a = i.lastBaseUpdate, s = i.shared.pending; if (null !== s) { i.shared.pending = null; var l = s, c = l.next; l.next = null, null === a ? o = c : a.next = c, a = l; var u = e.alternate; null !== u && (s = (u = u.updateQueue).lastBaseUpdate) !== a && (null === s ? u.firstBaseUpdate = c : s.next = c, u.lastBaseUpdate = l) } if (null !== o) { var d = i.baseState; for (a = 0, u = c = l = null, s = o; ;) { var p = s.lane, h = s.eventTime; if ((r & p) === p) { null !== u && (u = u.next = { eventTime: h, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null }); e: { var f = e, m = s; switch (p = t, h = n, m.tag) { case 1: if ("function" == typeof (f = m.payload)) { d = f.call(h, d, p); break e } d = f; break e; case 3: f.flags = -65537 & f.flags | 128; case 0: if (null == (p = "function" == typeof (f = m.payload) ? f.call(h, d, p) : f)) break e; d = z({}, d, p); break e; case 2: Ro = !0 } } null !== s.callback && 0 !== s.lane && (e.flags |= 64, null === (p = i.effects) ? i.effects = [s] : p.push(s)) } else h = { eventTime: h, lane: p, tag: s.tag, payload: s.payload, callback: s.callback, next: null }, null === u ? (c = u = h, l = d) : u = u.next = h, a |= p; if (null === (s = s.next)) { if (null === (s = i.shared.pending)) break; s = (p = s).next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null } } if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { a |= i.lane, i = i.next } while (i !== t) } else null === o && (i.shared.lanes = 0); zl |= a, e.lanes = a, e.memoizedState = d } } function No(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" != typeof i) throw Error(o(191, i)); i.call(r) } } } var jo = (new r.Component).refs; function Uo(e, t, n, r) { n = null == (n = n(r, t = e.memoizedState)) ? t : z({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var Vo = { isMounted: function (e) { return !!(e = e._reactInternals) && Ve(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), o = Lo(r, i); o.payload = t, null != n && (o.callback = n), null !== (t = Oo(e, o, i)) && (rc(t, e, i, r), Fo(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), o = Lo(r, i); o.tag = 1, o.payload = t, null != n && (o.callback = n), null !== (t = Oo(e, o, i)) && (rc(t, e, i, r), Fo(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tc(), r = nc(e), i = Lo(n, r); i.tag = 2, null != t && (i.callback = t), null !== (t = Oo(e, i, r)) && (rc(t, e, r, n), Fo(t, e, r)) } }; function Ko(e, t, n, r, i, o, a) { return "function" == typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !(t.prototype && t.prototype.isPureReactComponent && lr(n, r) && lr(i, o)) } function Wo(e, t, n) { var r = !1, i = Ii, o = t.contextType; return "object" == typeof o && null !== o ? o = Ao(o) : (i = Bi(t) ? Ti : Pi.current, o = (r = null != (r = t.contextTypes)) ? Ri(e, i) : Ii), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Vo, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function Yo(e, t, n, r) { e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Vo.enqueueReplaceState(t, t.state, null) } function Go(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = jo, Bo(e); var o = t.contextType; "object" == typeof o && null !== o ? i.context = Ao(o) : (o = Bi(t) ? Ti : Pi.current, i.context = Ri(e, o)), i.state = e.memoizedState, "function" == typeof (o = t.getDerivedStateFromProps) && (Uo(e, t, o, n), i.state = e.memoizedState), "function" == typeof t.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (t = i.state, "function" == typeof i.componentWillMount && i.componentWillMount(), "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Vo.enqueueReplaceState(i, i.state, null), Ho(e, n, i, r), i.state = e.memoizedState), "function" == typeof i.componentDidMount && (e.flags |= 4194308) } function Zo(e, t, n) { if (null !== (e = n.ref) && "function" != typeof e && "object" != typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(o(309)); var r = n.stateNode } if (!r) throw Error(o(147, e)); var i = r, a = "" + e; return null !== t && null !== t.ref && "function" == typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function (e) { var t = i.refs; t === jo && (t = i.refs = {}), null === e ? delete t[a] : t[a] = e }, t._stringRef = a, t) } if ("string" != typeof e) throw Error(o(284)); if (!n._owner) throw Error(o(290, e)) } return e } function Xo(e, t) { throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function _o(e) { return (0, e._init)(e._payload) } function Qo(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Lc(e, t)).index = 0, e.sibling = null, e } function a(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function s(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = Hc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var o = n.type; return o === S ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" == typeof o && null !== o && o.$$typeof === B && _o(o) === t.type) ? ((r = i(t, n.props)).ref = Zo(e, t, n), r.return = e, r) : ((r = Oc(n.type, n.key, n.props, null, e.mode, r)).ref = Zo(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Nc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function d(e, t, n, r, o) { return null === t || 7 !== t.tag ? ((t = Fc(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t) } function p(e, t, n) { if ("string" == typeof t && "" !== t || "number" == typeof t) return (t = Hc("" + t, e.mode, n)).return = e, t; if ("object" == typeof t && null !== t) { switch (t.$$typeof) { case E: return (n = Oc(t.type, t.key, t.props, null, e.mode, n)).ref = Zo(e, null, t), n.return = e, n; case C: return (t = Nc(t, e.mode, n)).return = e, t; case B: return p(e, (0, t._init)(t._payload), n) }if (te(t) || O(t)) return (t = Fc(t, e.mode, n, null)).return = e, t; Xo(e, t) } return null } function h(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" == typeof n && "" !== n || "number" == typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" == typeof n && null !== n) { switch (n.$$typeof) { case E: return n.key === i ? c(e, t, n, r) : null; case C: return n.key === i ? u(e, t, n, r) : null; case B: return h(e, t, (i = n._init)(n._payload), r) }if (te(n) || O(n)) return null !== i ? null : d(e, t, n, r, null); Xo(e, n) } return null } function f(e, t, n, r, i) { if ("string" == typeof r && "" !== r || "number" == typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" == typeof r && null !== r) { switch (r.$$typeof) { case E: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case C: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case B: return f(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || O(r)) return d(t, e = e.get(n) || null, r, i, null); Xo(t, r) } return null } function m(i, o, s, l) { for (var c = null, u = null, d = o, m = o = 0, g = null; null !== d && m < s.length; m++) { d.index > m ? (g = d, d = null) : g = d.sibling; var v = h(i, d, s[m], l); if (null === v) { null === d && (d = g); break } e && d && null === v.alternate && t(i, d), o = a(v, o, m), null === u ? c = v : u.sibling = v, u = v, d = g } if (m === s.length) return n(i, d), io && Ji(i, m), c; if (null === d) { for (; m < s.length; m++)null !== (d = p(i, s[m], l)) && (o = a(d, o, m), null === u ? c = d : u.sibling = d, u = d); return io && Ji(i, m), c } for (d = r(i, d); m < s.length; m++)null !== (g = f(d, i, m, s[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), o = a(g, o, m), null === u ? c = g : u.sibling = g, u = g); return e && d.forEach((function (e) { return t(i, e) })), io && Ji(i, m), c } function g(i, s, l, c) { var u = O(l); if ("function" != typeof u) throw Error(o(150)); if (null == (l = u.call(l))) throw Error(o(151)); for (var d = u = null, m = s, g = s = 0, v = null, y = l.next(); null !== m && !y.done; g++, y = l.next()) { m.index > g ? (v = m, m = null) : v = m.sibling; var b = h(i, m, y.value, c); if (null === b) { null === m && (m = v); break } e && m && null === b.alternate && t(i, m), s = a(b, s, g), null === d ? u = b : d.sibling = b, d = b, m = v } if (y.done) return n(i, m), io && Ji(i, g), u; if (null === m) { for (; !y.done; g++, y = l.next())null !== (y = p(i, y.value, c)) && (s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y); return io && Ji(i, g), u } for (m = r(i, m); !y.done; g++, y = l.next())null !== (y = f(m, i, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key), s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y); return e && m.forEach((function (e) { return t(i, e) })), io && Ji(i, g), u } return function e(r, o, a, l) { if ("object" == typeof a && null !== a && a.type === S && null === a.key && (a = a.props.children), "object" == typeof a && null !== a) { switch (a.$$typeof) { case E: e: { for (var c = a.key, u = o; null !== u;) { if (u.key === c) { if ((c = a.type) === S) { if (7 === u.tag) { n(r, u.sibling), (o = i(u, a.props.children)).return = r, r = o; break e } } else if (u.elementType === c || "object" == typeof c && null !== c && c.$$typeof === B && _o(c) === u.type) { n(r, u.sibling), (o = i(u, a.props)).ref = Zo(r, u, a), o.return = r, r = o; break e } n(r, u); break } t(r, u), u = u.sibling } a.type === S ? ((o = Fc(a.props.children, r.mode, l, a.key)).return = r, r = o) : ((l = Oc(a.type, a.key, a.props, null, r.mode, l)).ref = Zo(r, o, a), l.return = r, r = l) } return s(r); case C: e: { for (u = a.key; null !== o;) { if (o.key === u) { if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) { n(r, o.sibling), (o = i(o, a.children || [])).return = r, r = o; break e } n(r, o); break } t(r, o), o = o.sibling } (o = Nc(a, r.mode, l)).return = r, r = o } return s(r); case B: return e(r, o, (u = a._init)(a._payload), l) }if (te(a)) return m(r, o, a, l); if (O(a)) return g(r, o, a, l); Xo(r, a) } return "string" == typeof a && "" !== a || "number" == typeof a ? (a = "" + a, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, a)).return = r, r = o) : (n(r, o), (o = Hc(a, r.mode, l)).return = r, r = o), s(r)) : n(r, o) } } var qo = Qo(!0), Jo = Qo(!1), $o = {}, ea = ki($o), ta = ki($o), na = ki($o); function ra(e) { if (e === $o) throw Error(o(174)); return e } function ia(e, t) { switch (Ai(na, t), Ai(ta, e), Ai(ea, $o), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }xi(ea), Ai(ea, t) } function oa() { xi(ea), xi(ta), xi(na) } function aa(e) { ra(na.current); var t = ra(ea.current), n = le(t, e.type); t !== n && (Ai(ta, e), Ai(ea, n)) } function sa(e) { ta.current === e && (xi(ea), xi(ta)) } var la = ki(0); function ca(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 != (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ua = []; function da() { for (var e = 0; e < ua.length; e++)ua[e]._workInProgressVersionPrimary = null; ua.length = 0 } var pa = w.ReactCurrentDispatcher, ha = w.ReactCurrentBatchConfig, fa = 0, ma = null, ga = null, va = null, ya = !1, ba = !1, wa = 0, Ea = 0; function Ca() { throw Error(o(321)) } function Sa(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!sr(e[n], t[n])) return !1; return !0 } function ka(e, t, n, r, i, a) { if (fa = a, ma = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, pa.current = null === e || null === e.memoizedState ? ss : ls, e = n(r, i), ba) { a = 0; do { if (ba = !1, wa = 0, 25 <= a) throw Error(o(301)); a += 1, va = ga = null, t.updateQueue = null, pa.current = cs, e = n(r, i) } while (ba) } if (pa.current = as, t = null !== ga && null !== ga.next, fa = 0, va = ga = ma = null, ya = !1, t) throw Error(o(300)); return e } function xa() { var e = 0 !== wa; return wa = 0, e } function Aa() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === va ? ma.memoizedState = va = e : va = va.next = e, va } function Ia() { if (null === ga) { var e = ma.alternate; e = null !== e ? e.memoizedState : null } else e = ga.next; var t = null === va ? ma.memoizedState : va.next; if (null !== t) va = t, ga = e; else { if (null === e) throw Error(o(310)); e = { memoizedState: (ga = e).memoizedState, baseState: ga.baseState, baseQueue: ga.baseQueue, queue: ga.queue, next: null }, null === va ? ma.memoizedState = va = e : va = va.next = e } return va } function Pa(e, t) { return "function" == typeof t ? t(e) : t } function Ma(e) { var t = Ia(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = ga, i = r.baseQueue, a = n.pending; if (null !== a) { if (null !== i) { var s = i.next; i.next = a.next, a.next = s } r.baseQueue = i = a, n.pending = null } if (null !== i) { a = i.next, r = r.baseState; var l = s = null, c = null, u = a; do { var d = u.lane; if ((fa & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var p = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = p, s = r) : c = c.next = p, ma.lanes |= d, zl |= d } u = u.next } while (null !== u && u !== a); null === c ? s = r : c.next = l, sr(r, t.memoizedState) || (ws = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { a = i.lane, ma.lanes |= a, zl |= a, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Ta(e) { var t = Ia(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, a = t.memoizedState; if (null !== i) { n.pending = null; var s = i = i.next; do { a = e(a, s.action), s = s.next } while (s !== i); sr(a, t.memoizedState) || (ws = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a } return [a, r] } function Ra() { } function Ba(e, t) { var n = ma, r = Ia(), i = t(), a = !sr(r.memoizedState, i); if (a && (r.memoizedState = i, ws = !0), r = r.queue, Wa(Oa.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== va && 1 & va.memoizedState.tag) { if (n.flags |= 2048, Na(9, La.bind(null, n, r, i, t), void 0, null), null === Tl) throw Error(o(349)); 0 != (30 & fa) || Da(n, t, i) } return i } function Da(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = ma.updateQueue) ? (t = { lastEffect: null, stores: null }, ma.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function La(e, t, n, r) { t.value = n, t.getSnapshot = r, Fa(t) && za(e) } function Oa(e, t, n) { return n((function () { Fa(t) && za(e) })) } function Fa(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !sr(e, n) } catch (e) { return !0 } } function za(e) { var t = To(e, 1); null !== t && rc(t, e, 1, -1) } function Ha(e) { var t = Aa(); return "function" == typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Pa, lastRenderedState: e }, t.queue = e, e = e.dispatch = ns.bind(null, ma, e), [t.memoizedState, e] } function Na(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = ma.updateQueue) ? (t = { lastEffect: null, stores: null }, ma.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function ja() { return Ia().memoizedState } function Ua(e, t, n, r) { var i = Aa(); ma.flags |= e, i.memoizedState = Na(1 | t, n, void 0, void 0 === r ? null : r) } function Va(e, t, n, r) { var i = Ia(); r = void 0 === r ? null : r; var o = void 0; if (null !== ga) { var a = ga.memoizedState; if (o = a.destroy, null !== r && Sa(r, a.deps)) return void (i.memoizedState = Na(t, n, o, r)) } ma.flags |= e, i.memoizedState = Na(1 | t, n, o, r) } function Ka(e, t) { return Ua(8390656, 8, e, t) } function Wa(e, t) { return Va(2048, 8, e, t) } function Ya(e, t) { return Va(4, 2, e, t) } function Ga(e, t) { return Va(4, 4, e, t) } function Za(e, t) { return "function" == typeof t ? (e = e(), t(e), function () { t(null) }) : null != t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Xa(e, t, n) { return n = null != n ? n.concat([e]) : null, Va(4, 4, Za.bind(null, t, e), n) } function _a() { } function Qa(e, t) { var n = Ia(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && Sa(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function qa(e, t) { var n = Ia(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && Sa(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Ja(e, t, n) { return 0 == (21 & fa) ? (e.baseState && (e.baseState = !1, ws = !0), e.memoizedState = n) : (sr(n, t) || (n = mt(), ma.lanes |= n, zl |= n, e.baseState = !0), t) } function $a(e, t) { var n = bt; bt = 0 !== n && 4 > n ? n : 4, e(!0); var r = ha.transition; ha.transition = {}; try { e(!1), t() } finally { bt = n, ha.transition = r } } function es() { return Ia().memoizedState } function ts(e, t, n) { var r = nc(e); n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, rs(e) ? is(t, n) : null !== (n = Mo(e, t, n, r)) && (rc(n, e, r, tc()), os(n, t, r)) } function ns(e, t, n) { var r = nc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (rs(e)) is(t, i); else { var o = e.alternate; if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try { var a = t.lastRenderedState, s = o(a, n); if (i.hasEagerState = !0, i.eagerState = s, sr(s, a)) { var l = t.interleaved; return null === l ? (i.next = i, Po(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (e) { } null !== (n = Mo(e, t, i, r)) && (rc(n, e, r, i = tc()), os(n, t, r)) } } function rs(e) { var t = e.alternate; return e === ma || null !== t && t === ma } function is(e, t) { ba = ya = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function os(e, t, n) { if (0 != (4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } var as = { readContext: Ao, useCallback: Ca, useContext: Ca, useEffect: Ca, useImperativeHandle: Ca, useInsertionEffect: Ca, useLayoutEffect: Ca, useMemo: Ca, useReducer: Ca, useRef: Ca, useState: Ca, useDebugValue: Ca, useDeferredValue: Ca, useTransition: Ca, useMutableSource: Ca, useSyncExternalStore: Ca, useId: Ca, unstable_isNewReconciler: !1 }, ss = { readContext: Ao, useCallback: function (e, t) { return Aa().memoizedState = [e, void 0 === t ? null : t], e }, useContext: Ao, useEffect: Ka, useImperativeHandle: function (e, t, n) { return n = null != n ? n.concat([e]) : null, Ua(4194308, 4, Za.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Ua(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Ua(4, 2, e, t) }, useMemo: function (e, t) { var n = Aa(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Aa(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = ts.bind(null, ma, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, Aa().memoizedState = e }, useState: Ha, useDebugValue: _a, useDeferredValue: function (e) { return Aa().memoizedState = e }, useTransition: function () { var e = Ha(!1), t = e[0]; return e = $a.bind(null, e[1]), Aa().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ma, i = Aa(); if (io) { if (void 0 === n) throw Error(o(407)); n = n() } else { if (n = t(), null === Tl) throw Error(o(349)); 0 != (30 & fa) || Da(r, t, n) } i.memoizedState = n; var a = { value: n, getSnapshot: t }; return i.queue = a, Ka(Oa.bind(null, r, a, e), [e]), r.flags |= 2048, Na(9, La.bind(null, r, a, n, t), void 0, null), n }, useId: function () { var e = Aa(), t = Tl.identifierPrefix; if (io) { var n = qi; t = ":" + t + "R" + (n = (Qi & ~(1 << 32 - at(Qi) - 1)).toString(32) + n), 0 < (n = wa++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = Ea++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, ls = { readContext: Ao, useCallback: Qa, useContext: Ao, useEffect: Wa, useImperativeHandle: Xa, useInsertionEffect: Ya, useLayoutEffect: Ga, useMemo: qa, useReducer: Ma, useRef: ja, useState: function () { return Ma(Pa) }, useDebugValue: _a, useDeferredValue: function (e) { return Ja(Ia(), ga.memoizedState, e) }, useTransition: function () { return [Ma(Pa)[0], Ia().memoizedState] }, useMutableSource: Ra, useSyncExternalStore: Ba, useId: es, unstable_isNewReconciler: !1 }, cs = { readContext: Ao, useCallback: Qa, useContext: Ao, useEffect: Wa, useImperativeHandle: Xa, useInsertionEffect: Ya, useLayoutEffect: Ga, useMemo: qa, useReducer: Ta, useRef: ja, useState: function () { return Ta(Pa) }, useDebugValue: _a, useDeferredValue: function (e) { var t = Ia(); return null === ga ? t.memoizedState = e : Ja(t, ga.memoizedState, e) }, useTransition: function () { return [Ta(Pa)[0], Ia().memoizedState] }, useMutableSource: Ra, useSyncExternalStore: Ba, useId: es, unstable_isNewReconciler: !1 }; function us(e, t) { try { var n = "", r = t; do { n += U(r), r = r.return } while (r); var i = n } catch (e) { i = "\nError generating stack: " + e.message + "\n" + e.stack } return { value: e, source: t, stack: i, digest: null } } function ds(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function ps(e, t) { try { console.error(t.value) } catch (e) { setTimeout((function () { throw e })) } } var hs = "function" == typeof WeakMap ? WeakMap : Map; function fs(e, t, n) { (n = Lo(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Yl || (Yl = !0, Gl = r), ps(0, t) }, n } function ms(e, t, n) { (n = Lo(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" == typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { ps(0, t) } } var o = e.stateNode; return null !== o && "function" == typeof o.componentDidCatch && (n.callback = function () { ps(0, t), "function" != typeof r && (null === Zl ? Zl = new Set([this]) : Zl.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function gs(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new hs; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Ac.bind(null, e, t, n), t.then(e, e)) } function vs(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function ys(e, t, n, r, i) { return 0 == (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Lo(-1, 1)).tag = 2, Oo(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e) } var bs = w.ReactCurrentOwner, ws = !1; function Es(e, t, n, r) { t.child = null === e ? Jo(t, null, n, r) : qo(t, e.child, n, r) } function Cs(e, t, n, r, i) { n = n.render; var o = t.ref; return xo(t, i), r = ka(e, t, n, r, o, i), n = xa(), null === e || ws ? (io && n && eo(t), t.flags |= 1, Es(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ys(e, t, i)) } function Ss(e, t, n, r, i) { if (null === e) { var o = n.type; return "function" != typeof o || Dc(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Oc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, ks(e, t, o, r, i)) } if (o = e.child, 0 == (e.lanes & i)) { var a = o.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(a, r) && e.ref === t.ref) return Ys(e, t, i) } return t.flags |= 1, (e = Lc(o, r)).ref = t.ref, e.return = t, t.child = e } function ks(e, t, n, r, i) { if (null !== e) { var o = e.memoizedProps; if (lr(o, r) && e.ref === t.ref) { if (ws = !1, t.pendingProps = r = o, 0 == (e.lanes & i)) return t.lanes = e.lanes, Ys(e, t, i); 0 != (131072 & e.flags) && (ws = !0) } } return Is(e, t, n, r, i) } function xs(e, t, n) { var r = t.pendingProps, i = r.children, o = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (0 == (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ai(Ll, Dl), Dl |= n; else { if (0 == (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ai(Ll, Dl), Dl |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== o ? o.baseLanes : n, Ai(Ll, Dl), Dl |= r } else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ai(Ll, Dl), Dl |= r; return Es(e, t, i, n), t.child } function As(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Is(e, t, n, r, i) { var o = Bi(n) ? Ti : Pi.current; return o = Ri(t, o), xo(t, i), n = ka(e, t, n, r, o, i), r = xa(), null === e || ws ? (io && r && eo(t), t.flags |= 1, Es(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ys(e, t, i)) } function Ps(e, t, n, r, i) { if (Bi(n)) { var o = !0; Fi(t) } else o = !1; if (xo(t, i), null === t.stateNode) Ws(e, t), Wo(t, n, r), Go(t, n, r, i), r = !0; else if (null === e) { var a = t.stateNode, s = t.memoizedProps; a.props = s; var l = a.context, c = n.contextType; c = "object" == typeof c && null !== c ? Ao(c) : Ri(t, c = Bi(n) ? Ti : Pi.current); var u = n.getDerivedStateFromProps, d = "function" == typeof u || "function" == typeof a.getSnapshotBeforeUpdate; d || "function" != typeof a.UNSAFE_componentWillReceiveProps && "function" != typeof a.componentWillReceiveProps || (s !== r || l !== c) && Yo(t, a, r, c), Ro = !1; var p = t.memoizedState; a.state = p, Ho(t, r, a, i), l = t.memoizedState, s !== r || p !== l || Mi.current || Ro ? ("function" == typeof u && (Uo(t, n, u, r), l = t.memoizedState), (s = Ro || Ko(t, n, s, r, p, l, c)) ? (d || "function" != typeof a.UNSAFE_componentWillMount && "function" != typeof a.componentWillMount || ("function" == typeof a.componentWillMount && a.componentWillMount(), "function" == typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" == typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" == typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = s) : ("function" == typeof a.componentDidMount && (t.flags |= 4194308), r = !1) } else { a = t.stateNode, Do(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : vo(t.type, s), a.props = c, d = t.pendingProps, p = a.context, l = "object" == typeof (l = n.contextType) && null !== l ? Ao(l) : Ri(t, l = Bi(n) ? Ti : Pi.current); var h = n.getDerivedStateFromProps; (u = "function" == typeof h || "function" == typeof a.getSnapshotBeforeUpdate) || "function" != typeof a.UNSAFE_componentWillReceiveProps && "function" != typeof a.componentWillReceiveProps || (s !== d || p !== l) && Yo(t, a, r, l), Ro = !1, p = t.memoizedState, a.state = p, Ho(t, r, a, i); var f = t.memoizedState; s !== d || p !== f || Mi.current || Ro ? ("function" == typeof h && (Uo(t, n, h, r), f = t.memoizedState), (c = Ro || Ko(t, n, c, r, p, f, l) || !1) ? (u || "function" != typeof a.UNSAFE_componentWillUpdate && "function" != typeof a.componentWillUpdate || ("function" == typeof a.componentWillUpdate && a.componentWillUpdate(r, f, l), "function" == typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, f, l)), "function" == typeof a.componentDidUpdate && (t.flags |= 4), "function" == typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" != typeof a.componentDidUpdate || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 4), "function" != typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = f), a.props = r, a.state = f, a.context = l, r = c) : ("function" != typeof a.componentDidUpdate || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 4), "function" != typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 1024), r = !1) } return Ms(e, t, n, r, o, i) } function Ms(e, t, n, r, i, o) { As(e, t); var a = 0 != (128 & t.flags); if (!r && !a) return i && zi(t, n, !1), Ys(e, t, o); r = t.stateNode, bs.current = t; var s = a && "function" != typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && a ? (t.child = qo(t, e.child, null, o), t.child = qo(t, null, s, o)) : Es(e, t, s, o), t.memoizedState = r.state, i && zi(t, n, !0), t.child } function Ts(e) { var t = e.stateNode; t.pendingContext ? Li(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Li(0, t.context, !1), ia(e, t.containerInfo) } function Rs(e, t, n, r, i) { return fo(), mo(i), t.flags |= 256, Es(e, t, n, r), t.child } var Bs, Ds, Ls, Os, Fs = { dehydrated: null, treeContext: null, retryLane: 0 }; function zs(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Hs(e, t, n) { var r, i = t.pendingProps, a = la.current, s = !1, l = 0 != (128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 != (2 & a)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Ai(la, 1 & a), null === e) return co(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 == (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, l = { mode: "hidden", children: l }, 0 == (1 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = l) : s = zc(l, i, 0, null), e = Fc(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = zs(n), t.memoizedState = Fs, e) : Ns(t, l)); if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated)) return function (e, t, n, r, i, a, s) { if (n) return 256 & t.flags ? (t.flags &= -257, js(e, t, s, r = ds(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = zc({ mode: "visible", children: r.children }, i, 0, null), (a = Fc(a, i, s, null)).flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, 0 != (1 & t.mode) && qo(t, e.child, null, s), t.child.memoizedState = zs(s), t.memoizedState = Fs, a); if (0 == (1 & t.mode)) return js(e, t, s, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, js(e, t, s, r = ds(a = Error(o(419)), r, void 0)) } if (l = 0 != (s & e.childLanes), ws || l) { if (null !== (r = Tl)) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = 0 != (i & (r.suspendedLanes | s)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i, To(e, i), rc(r, e, i, -1)) } return gc(), js(e, t, s, r = ds(Error(o(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Pc.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, ro = ci(i.nextSibling), no = t, io = !0, oo = null, null !== e && (Zi[Xi++] = Qi, Zi[Xi++] = qi, Zi[Xi++] = _i, Qi = e.id, qi = e.overflow, _i = t), (t = Ns(t, r.children)).flags |= 4096, t) }(e, t, l, i, r, a, n); if (s) { s = i.fallback, l = t.mode, r = (a = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 0 == (1 & l) && t.child !== a ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Lc(a, c)).subtreeFlags = 14680064 & a.subtreeFlags, null !== r ? s = Lc(r, s) : (s = Fc(s, l, n, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, l = null === (l = e.child.memoizedState) ? zs(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, s.memoizedState = l, s.childLanes = e.childLanes & ~n, t.memoizedState = Fs, i } return e = (s = e.child).sibling, i = Lc(s, { mode: "visible", children: i.children }), 0 == (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Ns(e, t) { return (t = zc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function js(e, t, n, r) { return null !== r && mo(r), qo(t, e.child, null, n), (e = Ns(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Us(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), ko(e.return, t, n) } function Vs(e, t, n, r, i) { var o = e.memoizedState; null === o ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function Ks(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (Es(e, t, r.children, n), 0 != (2 & (r = la.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 != (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Us(e, n, t); else if (19 === e.tag) Us(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ai(la, r), 0 == (1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === ca(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Vs(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === ca(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Vs(t, !0, n, null, o); break; case "together": Vs(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Ws(e, t) { 0 == (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Ys(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), zl |= t.lanes, 0 == (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(o(153)); if (null !== t.child) { for (n = Lc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Lc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Gs(e, t) { if (!io) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Zs(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Xs(e, t, n) { var r = t.pendingProps; switch (to(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Zs(t), null; case 1: case 17: return Bi(t.type) && Di(), Zs(t), null; case 3: return r = t.stateNode, oa(), xi(Mi), xi(Pi), da(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (po(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 == (256 & t.flags) || (t.flags |= 1024, null !== oo && (sc(oo), oo = null))), Ds(e, t), Zs(t), null; case 5: sa(t); var i = ra(na.current); if (n = t.type, null !== e && null != t.stateNode) Ls(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(o(166)); return Zs(t), null } if (e = ra(ea.current), po(t)) { r = t.stateNode, n = t.type; var a = t.memoizedProps; switch (r[pi] = t, r[hi] = a, e = 0 != (1 & t.mode), n) { case "dialog": Nr("cancel", r), Nr("close", r); break; case "iframe": case "object": case "embed": Nr("load", r); break; case "video": case "audio": for (i = 0; i < Or.length; i++)Nr(Or[i], r); break; case "source": Nr("error", r); break; case "img": case "image": case "link": Nr("error", r), Nr("load", r); break; case "details": Nr("toggle", r); break; case "input": Q(r, a), Nr("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!a.multiple }, Nr("invalid", r); break; case "textarea": ie(r, a), Nr("invalid", r) }for (var l in ye(n, a), i = null, a) if (a.hasOwnProperty(l)) { var c = a[l]; "children" === l ? "string" == typeof c ? r.textContent !== c && (!0 !== a.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", c]) : "number" == typeof c && r.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", "" + c]) : s.hasOwnProperty(l) && null != c && "onScroll" === l && Nr("scroll", r) } switch (n) { case "input": G(r), $(r, a, !0); break; case "textarea": G(r), ae(r); break; case "select": case "option": break; default: "function" == typeof a.onClick && (r.onclick = $r) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = se(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" == typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[pi] = t, e[hi] = r, Bs(e, t, !1, !1), t.stateNode = e; e: { switch (l = be(n, r), n) { case "dialog": Nr("cancel", e), Nr("close", e), i = r; break; case "iframe": case "object": case "embed": Nr("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Or.length; i++)Nr(Or[i], e); i = r; break; case "source": Nr("error", e), i = r; break; case "img": case "image": case "link": Nr("error", e), Nr("load", e), i = r; break; case "details": Nr("toggle", e), i = r; break; case "input": Q(e, r), i = _(e, r), Nr("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = z({}, r, { value: void 0 }), Nr("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), Nr("invalid", e) }for (a in ye(n, i), c = i) if (c.hasOwnProperty(a)) { var u = c[a]; "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" == typeof u ? ("textarea" !== n || "" !== u) && pe(e, u) : "number" == typeof u && pe(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (s.hasOwnProperty(a) ? null != u && "onScroll" === a && Nr("scroll", e) : null != u && b(e, a, u, l)) } switch (n) { case "input": G(e), $(e, r, !1); break; case "textarea": G(e), ae(e); break; case "option": null != r.value && e.setAttribute("value", "" + W(r.value)); break; case "select": e.multiple = !!r.multiple, null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" == typeof i.onClick && (e.onclick = $r) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Zs(t), null; case 6: if (e && null != t.stateNode) Os(e, t, e.memoizedProps, r); else { if ("string" != typeof r && null === t.stateNode) throw Error(o(166)); if (n = ra(na.current), ra(ea.current), po(t)) { if (r = t.stateNode, n = t.memoizedProps, r[pi] = t, (a = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) { case 3: Jr(r.nodeValue, n, 0 != (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Jr(r.nodeValue, n, 0 != (1 & e.mode)) }a && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[pi] = t, t.stateNode = r } return Zs(t), null; case 13: if (xi(la), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (io && null !== ro && 0 != (1 & t.mode) && 0 == (128 & t.flags)) ho(), fo(), t.flags |= 98560, a = !1; else if (a = po(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!a) throw Error(o(318)); if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(o(317)); a[pi] = t } else fo(), 0 == (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Zs(t), a = !1 } else null !== oo && (sc(oo), oo = null), a = !0; if (!a) return 65536 & t.flags ? t : null } return 0 != (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) != (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 != (1 & t.mode) && (null === e || 0 != (1 & la.current) ? 0 === Ol && (Ol = 3) : gc())), null !== t.updateQueue && (t.flags |= 4), Zs(t), null); case 4: return oa(), Ds(e, t), null === e && Vr(t.stateNode.containerInfo), Zs(t), null; case 10: return So(t.type._context), Zs(t), null; case 19: if (xi(la), null === (a = t.memoizedState)) return Zs(t), null; if (r = 0 != (128 & t.flags), null === (l = a.rendering)) if (r) Gs(a, !1); else { if (0 !== Ol || null !== e && 0 != (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = ca(e))) { for (t.flags |= 128, Gs(a, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (a = n).flags &= 14680066, null === (l = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ai(la, 1 & la.current | 2), t.child } e = e.sibling } null !== a.tail && qe() > Kl && (t.flags |= 128, r = !0, Gs(a, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = ca(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Gs(a, !0), null === a.tail && "hidden" === a.tailMode && !l.alternate && !io) return Zs(t), null } else 2 * qe() - a.renderingStartTime > Kl && 1073741824 !== n && (t.flags |= 128, r = !0, Gs(a, !1), t.lanes = 4194304); a.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l, a.last = l) } return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = qe(), t.sibling = null, n = la.current, Ai(la, r ? 1 & n | 2 : 1 & n), t) : (Zs(t), null); case 22: case 23: return pc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 != (1 & t.mode) ? 0 != (1073741824 & Dl) && (Zs(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Zs(t), null; case 24: case 25: return null }throw Error(o(156, t.tag)) } function _s(e, t) { switch (to(t), t.tag) { case 1: return Bi(t.type) && Di(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return oa(), xi(Mi), xi(Pi), da(), 0 != (65536 & (e = t.flags)) && 0 == (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return sa(t), null; case 13: if (xi(la), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(o(340)); fo() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return xi(la), null; case 4: return oa(), null; case 10: return So(t.type._context), null; case 22: case 23: return pc(), null; default: return null } } Bs = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, Ds = function () { }, Ls = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, ra(ea.current); var o, a = null; switch (n) { case "input": i = _(e, i), r = _(e, r), a = []; break; case "select": i = z({}, i, { value: void 0 }), r = z({}, r, { value: void 0 }), a = []; break; case "textarea": i = re(e, i), r = re(e, r), a = []; break; default: "function" != typeof i.onClick && "function" == typeof r.onClick && (e.onclick = $r) }for (u in ye(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (o in l) l.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (o in l) !l.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in c) c.hasOwnProperty(o) && l[o] !== c[o] && (n || (n = {}), n[o] = c[o]) } else n || (a || (a = []), a.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" != typeof c && "number" != typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != c && "onScroll" === u && Nr("scroll", e), a || l === c || (a = [])) : (a = a || []).push(u, c)) } n && (a = a || []).push("style", n); var u = a; (t.updateQueue = u) && (t.flags |= 4) } }, Os = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Qs = !1, qs = !1, Js = "function" == typeof WeakSet ? WeakSet : Set, $s = null; function el(e, t) { var n = e.ref; if (null !== n) if ("function" == typeof n) try { n(null) } catch (n) { xc(e, t, n) } else n.current = null } function tl(e, t, n) { try { n() } catch (n) { xc(e, t, n) } } var nl = !1; function rl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, void 0 !== o && tl(t, n, o) } i = i.next } while (i !== r) } } function il(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ol(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" == typeof t ? t(e) : t.current = e } } function al(e) { var t = e.alternate; null !== t && (e.alternate = null, al(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && null !== (t = e.stateNode) && (delete t[pi], delete t[hi], delete t[mi], delete t[gi], delete t[vi]), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function sl(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ll(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || sl(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null != (n = n._reactRootContainer) || null !== t.onclick || (t.onclick = $r)); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } function ul(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;)ul(e, t, n), e = e.sibling } var dl = null, pl = !1; function hl(e, t, n) { for (n = n.child; null !== n;)fl(e, t, n), n = n.sibling } function fl(e, t, n) { if (ot && "function" == typeof ot.onCommitFiberUnmount) try { ot.onCommitFiberUnmount(it, n) } catch (e) { } switch (n.tag) { case 5: qs || el(n, t); case 6: var r = dl, i = pl; dl = null, hl(e, t, n), pl = i, null !== (dl = r) && (pl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode)); break; case 18: null !== dl && (pl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), Vt(e)) : li(dl, n.stateNode)); break; case 4: r = dl, i = pl, dl = n.stateNode.containerInfo, pl = !0, hl(e, t, n), dl = r, pl = i; break; case 0: case 11: case 14: case 15: if (!qs && null !== (r = n.updateQueue) && null !== (r = r.lastEffect)) { i = r = r.next; do { var o = i, a = o.destroy; o = o.tag, void 0 !== a && (0 != (2 & o) || 0 != (4 & o)) && tl(n, t, a), i = i.next } while (i !== r) } hl(e, t, n); break; case 1: if (!qs && (el(n, t), "function" == typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (e) { xc(n, t, e) } hl(e, t, n); break; case 21: hl(e, t, n); break; case 22: 1 & n.mode ? (qs = (r = qs) || null !== n.memoizedState, hl(e, t, n), qs = r) : hl(e, t, n); break; default: hl(e, t, n) } } function ml(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Js), t.forEach((function (t) { var r = Mc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function gl(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var a = e, s = t, l = s; e: for (; null !== l;) { switch (l.tag) { case 5: dl = l.stateNode, pl = !1; break e; case 3: case 4: dl = l.stateNode.containerInfo, pl = !0; break e }l = l.return } if (null === dl) throw Error(o(160)); fl(a, s, i), dl = null, pl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (e) { xc(i, t, e) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)vl(t, e), t = t.sibling } function vl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (gl(t, e), yl(e), 4 & r) { try { rl(3, e, e.return), il(3, e) } catch (t) { xc(e, e.return, t) } try { rl(5, e, e.return) } catch (t) { xc(e, e.return, t) } } break; case 1: gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return); break; case 5: if (gl(t, e), yl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) { var i = e.stateNode; try { pe(i, "") } catch (t) { xc(e, e.return, t) } } if (4 & r && null != (i = e.stateNode)) { var a = e.memoizedProps, s = null !== n ? n.memoizedProps : a, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === a.type && null != a.name && q(i, a), be(l, s); var u = be(l, a); for (s = 0; s < c.length; s += 2) { var d = c[s], p = c[s + 1]; "style" === d ? ge(i, p) : "dangerouslySetInnerHTML" === d ? de(i, p) : "children" === d ? pe(i, p) : b(i, d, p, u) } switch (l) { case "input": J(i, a); break; case "textarea": oe(i, a); break; case "select": var h = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!a.multiple; var f = a.value; null != f ? ne(i, !!a.multiple, f, !1) : h !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1)) }i[hi] = a } catch (t) { xc(e, e.return, t) } } break; case 6: if (gl(t, e), yl(e), 4 & r) { if (null === e.stateNode) throw Error(o(162)); i = e.stateNode, a = e.memoizedProps; try { i.nodeValue = a } catch (t) { xc(e, e.return, t) } } break; case 3: if (gl(t, e), yl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { Vt(t.containerInfo) } catch (t) { xc(e, e.return, t) } break; case 4: default: gl(t, e), yl(e); break; case 13: gl(t, e), yl(e), 8192 & (i = e.child).flags && (a = null !== i.memoizedState, i.stateNode.isHidden = a, !a || null !== i.alternate && null !== i.alternate.memoizedState || (Vl = qe())), 4 & r && ml(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (qs = (u = qs) || d, gl(t, e), qs = u) : gl(t, e), yl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 != (1 & e.mode)) for ($s = e, d = e.child; null !== d;) { for (p = $s = d; null !== $s;) { switch (f = (h = $s).child, h.tag) { case 0: case 11: case 14: case 15: rl(4, h, h.return); break; case 1: el(h, h.return); var m = h.stateNode; if ("function" == typeof m.componentWillUnmount) { r = h, n = h.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (e) { xc(r, n, e) } } break; case 5: el(h, h.return); break; case 22: if (null !== h.memoizedState) { Cl(p); continue } }null !== f ? (f.return = h, $s = f) : Cl(p) } d = d.sibling } e: for (d = null, p = e; ;) { if (5 === p.tag) { if (null === d) { d = p; try { i = p.stateNode, u ? "function" == typeof (a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = p.stateNode, s = null != (c = p.memoizedProps.style) && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", s)) } catch (t) { xc(e, e.return, t) } } } else if (6 === p.tag) { if (null === d) try { p.stateNode.nodeValue = u ? "" : p.memoizedProps } catch (t) { xc(e, e.return, t) } } else if ((22 !== p.tag && 23 !== p.tag || null === p.memoizedState || p === e) && null !== p.child) { p.child.return = p, p = p.child; continue } if (p === e) break e; for (; null === p.sibling;) { if (null === p.return || p.return === e) break e; d === p && (d = null), p = p.return } d === p && (d = null), p.sibling.return = p.return, p = p.sibling } } break; case 19: gl(t, e), yl(e), 4 & r && ml(e); case 21: } } function yl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (sl(n)) { var r = n; break e } n = n.return } throw Error(o(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (pe(i, ""), r.flags &= -33), ul(e, ll(e), i); break; case 3: case 4: var a = r.stateNode.containerInfo; cl(e, ll(e), a); break; default: throw Error(o(161)) } } catch (t) { xc(e, e.return, t) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function bl(e, t, n) { $s = e, wl(e, t, n) } function wl(e, t, n) { for (var r = 0 != (1 & e.mode); null !== $s;) { var i = $s, o = i.child; if (22 === i.tag && r) { var a = null !== i.memoizedState || Qs; if (!a) { var s = i.alternate, l = null !== s && null !== s.memoizedState || qs; s = Qs; var c = qs; if (Qs = a, (qs = l) && !c) for ($s = i; null !== $s;)l = (a = $s).child, 22 === a.tag && null !== a.memoizedState ? Sl(i) : null !== l ? (l.return = a, $s = l) : Sl(i); for (; null !== o;)$s = o, wl(o, t, n), o = o.sibling; $s = i, Qs = s, qs = c } El(e) } else 0 != (8772 & i.subtreeFlags) && null !== o ? (o.return = i, $s = o) : El(e) } } function El(e) { for (; null !== $s;) { var t = $s; if (0 != (8772 & t.flags)) { var n = t.alternate; try { if (0 != (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: qs || il(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !qs) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : vo(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var a = t.updateQueue; null !== a && No(t, a, r); break; case 3: var s = t.updateQueue; if (null !== s) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }No(t, s, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var p = d.dehydrated; null !== p && Vt(p) } } } break; default: throw Error(o(163)) }qs || 512 & t.flags && ol(t) } catch (e) { xc(t, t.return, e) } } if (t === e) { $s = null; break } if (null !== (n = t.sibling)) { n.return = t.return, $s = n; break } $s = t.return } } function Cl(e) { for (; null !== $s;) { var t = $s; if (t === e) { $s = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, $s = n; break } $s = t.return } } function Sl(e) { for (; null !== $s;) { var t = $s; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { il(4, t) } catch (e) { xc(t, n, e) } break; case 1: var r = t.stateNode; if ("function" == typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (e) { xc(t, i, e) } } var o = t.return; try { ol(t) } catch (e) { xc(t, o, e) } break; case 5: var a = t.return; try { ol(t) } catch (e) { xc(t, a, e) } } } catch (e) { xc(t, t.return, e) } if (t === e) { $s = null; break } var s = t.sibling; if (null !== s) { s.return = t.return, $s = s; break } $s = t.return } } var kl, xl = Math.ceil, Al = w.ReactCurrentDispatcher, Il = w.ReactCurrentOwner, Pl = w.ReactCurrentBatchConfig, Ml = 0, Tl = null, Rl = null, Bl = 0, Dl = 0, Ll = ki(0), Ol = 0, Fl = null, zl = 0, Hl = 0, Nl = 0, jl = null, Ul = null, Vl = 0, Kl = 1 / 0, Wl = null, Yl = !1, Gl = null, Zl = null, Xl = !1, _l = null, Ql = 0, ql = 0, Jl = null, $l = -1, ec = 0; function tc() { return 0 != (6 & Ml) ? qe() : -1 !== $l ? $l : $l = qe() } function nc(e) { return 0 == (1 & e.mode) ? 1 : 0 != (2 & Ml) && 0 !== Bl ? Bl & -Bl : null !== go.transition ? (0 === ec && (ec = mt()), ec) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Qt(e.type) } function rc(e, t, n, r) { if (50 < ql) throw ql = 0, Jl = null, Error(o(185)); vt(e, n, r), 0 != (2 & Ml) && e === Tl || (e === Tl && (0 == (2 & Ml) && (Hl |= n), 4 === Ol && lc(e, Bl)), ic(e, r), 1 === n && 0 === Ml && 0 == (1 & t.mode) && (Kl = qe() + 500, Ni && Vi())) } function ic(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var a = 31 - at(o), s = 1 << a, l = i[a]; -1 === l ? 0 != (s & n) && 0 == (s & r) || (i[a] = ht(s, t)) : l <= t && (e.expiredLanes |= s), o &= ~s } }(e, t); var r = pt(e, e === Tl ? Bl : 0); if (0 === r) null !== n && Xe(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && Xe(n), 1 === t) 0 === e.tag ? function (e) { Ni = !0, Ui(e) }(cc.bind(null, e)) : Ui(cc.bind(null, e)), ai((function () { 0 == (6 & Ml) && Vi() })), n = null; else { switch (wt(r)) { case 1: n = $e; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Tc(n, oc.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function oc(e, t) { if ($l = -1, ec = 0, 0 != (6 & Ml)) throw Error(o(327)); var n = e.callbackNode; if (Sc() && e.callbackNode !== n) return null; var r = pt(e, e === Tl ? Bl : 0); if (0 === r) return null; if (0 != (30 & r) || 0 != (r & e.expiredLanes) || t) t = vc(e, r); else { t = r; var i = Ml; Ml |= 2; var a = mc(); for (Tl === e && Bl === t || (Wl = null, Kl = qe() + 500, hc(e, t)); ;)try { bc(); break } catch (t) { fc(e, t) } Co(), Al.current = a, Ml = i, null !== Rl ? t = 0 : (Tl = null, Bl = 0, t = Ol) } if (0 !== t) { if (2 === t && 0 !== (i = ft(e)) && (r = i, t = ac(e, i)), 1 === t) throw n = Fl, hc(e, 0), lc(e, r), ic(e, qe()), n; if (6 === t) lc(e, r); else { if (i = e.current.alternate, 0 == (30 & r) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!sr(o(), i)) return !1 } catch (e) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) && (2 === (t = vc(e, r)) && 0 !== (a = ft(e)) && (r = a, t = ac(e, a)), 1 === t)) throw n = Fl, hc(e, 0), lc(e, r), ic(e, qe()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(o(345)); case 2: case 5: Cc(e, Ul, Wl); break; case 3: if (lc(e, r), (130023424 & r) === r && 10 < (t = Vl + 500 - qe())) { if (0 !== pt(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { tc(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(Cc.bind(null, e, Ul, Wl), t); break } Cc(e, Ul, Wl); break; case 4: if (lc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - at(r); a = 1 << s, (s = t[s]) > i && (i = s), r &= ~a } if (r = i, 10 < (r = (120 > (r = qe() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * xl(r / 1960)) - r)) { e.timeoutHandle = ri(Cc.bind(null, e, Ul, Wl), r); break } Cc(e, Ul, Wl); break; default: throw Error(o(329)) } } } return ic(e, qe()), e.callbackNode === n ? oc.bind(null, e) : null } function ac(e, t) { var n = jl; return e.current.memoizedState.isDehydrated && (hc(e, t).flags |= 256), 2 !== (e = vc(e, t)) && (t = Ul, Ul = n, null !== t && sc(t)), e } function sc(e) { null === Ul ? Ul = e : Ul.push.apply(Ul, e) } function lc(e, t) { for (t &= ~Nl, t &= ~Hl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - at(t), r = 1 << n; e[n] = -1, t &= ~r } } function cc(e) { if (0 != (6 & Ml)) throw Error(o(327)); Sc(); var t = pt(e, 0); if (0 == (1 & t)) return ic(e, qe()), null; var n = vc(e, t); if (0 !== e.tag && 2 === n) { var r = ft(e); 0 !== r && (t = r, n = ac(e, r)) } if (1 === n) throw n = Fl, hc(e, 0), lc(e, t), ic(e, qe()), n; if (6 === n) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Cc(e, Ul, Wl), ic(e, qe()), null } function uc(e, t) { var n = Ml; Ml |= 1; try { return e(t) } finally { 0 === (Ml = n) && (Kl = qe() + 500, Ni && Vi()) } } function dc(e) { null !== _l && 0 === _l.tag && 0 == (6 & Ml) && Sc(); var t = Ml; Ml |= 1; var n = Pl.transition, r = bt; try { if (Pl.transition = null, bt = 1, e) return e() } finally { bt = r, Pl.transition = n, 0 == (6 & (Ml = t)) && Vi() } } function pc() { Dl = Ll.current, xi(Ll) } function hc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Rl) for (n = Rl.return; null !== n;) { var r = n; switch (to(r), r.tag) { case 1: null != (r = r.type.childContextTypes) && Di(); break; case 3: oa(), xi(Mi), xi(Pi), da(); break; case 5: sa(r); break; case 4: oa(); break; case 13: case 19: xi(la); break; case 10: So(r.type._context); break; case 22: case 23: pc() }n = n.return } if (Tl = e, Rl = e = Lc(e.current, null), Bl = Dl = t, Ol = 0, Fl = null, Nl = Hl = zl = 0, Ul = jl = null, null !== Io) { for (t = 0; t < Io.length; t++)if (null !== (r = (n = Io[t]).interleaved)) { n.interleaved = null; var i = r.next, o = n.pending; if (null !== o) { var a = o.next; o.next = i, r.next = a } n.pending = r } Io = null } return e } function fc(e, t) { for (; ;) { var n = Rl; try { if (Co(), pa.current = as, ya) { for (var r = ma.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } ya = !1 } if (fa = 0, va = ga = ma = null, ba = !1, wa = 0, Il.current = null, null === n || null === n.return) { Ol = 1, Fl = t, Rl = null; break } e: { var a = e, s = n.return, l = n, c = t; if (t = Bl, l.flags |= 32768, null !== c && "object" == typeof c && "function" == typeof c.then) { var u = c, d = l, p = d.tag; if (0 == (1 & d.mode) && (0 === p || 11 === p || 15 === p)) { var h = d.alternate; h ? (d.updateQueue = h.updateQueue, d.memoizedState = h.memoizedState, d.lanes = h.lanes) : (d.updateQueue = null, d.memoizedState = null) } var f = vs(s); if (null !== f) { f.flags &= -257, ys(f, s, l, 0, t), 1 & f.mode && gs(a, u, t), c = u; var m = (t = f).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (0 == (1 & t)) { gs(a, u, t), gc(); break e } c = Error(o(426)) } else if (io && 1 & l.mode) { var v = vs(s); if (null !== v) { 0 == (65536 & v.flags) && (v.flags |= 256), ys(v, s, l, 0, t), mo(us(c, l)); break e } } a = c = us(c, l), 4 !== Ol && (Ol = 2), null === jl ? jl = [a] : jl.push(a), a = s; do { switch (a.tag) { case 3: a.flags |= 65536, t &= -t, a.lanes |= t, zo(a, fs(0, c, t)); break e; case 1: l = c; var y = a.type, b = a.stateNode; if (0 == (128 & a.flags) && ("function" == typeof y.getDerivedStateFromError || null !== b && "function" == typeof b.componentDidCatch && (null === Zl || !Zl.has(b)))) { a.flags |= 65536, t &= -t, a.lanes |= t, zo(a, ms(a, l, t)); break e } }a = a.return } while (null !== a) } Ec(n) } catch (e) { t = e, Rl === n && null !== n && (Rl = n = n.return); continue } break } } function mc() { var e = Al.current; return Al.current = as, null === e ? as : e } function gc() { 0 !== Ol && 3 !== Ol && 2 !== Ol || (Ol = 4), null === Tl || 0 == (268435455 & zl) && 0 == (268435455 & Hl) || lc(Tl, Bl) } function vc(e, t) { var n = Ml; Ml |= 2; var r = mc(); for (Tl === e && Bl === t || (Wl = null, hc(e, t)); ;)try { yc(); break } catch (t) { fc(e, t) } if (Co(), Ml = n, Al.current = r, null !== Rl) throw Error(o(261)); return Tl = null, Bl = 0, Ol } function yc() { for (; null !== Rl;)wc(Rl) } function bc() { for (; null !== Rl && !_e();)wc(Rl) } function wc(e) { var t = kl(e.alternate, e, Dl); e.memoizedProps = e.pendingProps, null === t ? Ec(e) : Rl = t, Il.current = null } function Ec(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 == (32768 & t.flags)) { if (null !== (n = Xs(n, t, Dl))) return void (Rl = n) } else { if (null !== (n = _s(n, t))) return n.flags &= 32767, void (Rl = n); if (null === e) return Ol = 6, void (Rl = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Rl = t); Rl = t = e } while (null !== t); 0 === Ol && (Ol = 5) } function Cc(e, t, n) { var r = bt, i = Pl.transition; try { Pl.transition = null, bt = 1, function (e, t, n, r) { do { Sc() } while (null !== _l); if (0 != (6 & Ml)) throw Error(o(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var a = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - at(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } }(e, a), e === Tl && (Rl = Tl = null, Bl = 0), 0 == (2064 & n.subtreeFlags) && 0 == (2064 & n.flags) || Xl || (Xl = !0, Tc(tt, (function () { return Sc(), null }))), a = 0 != (15990 & n.flags), 0 != (15990 & n.subtreeFlags) || a) { a = Pl.transition, Pl.transition = null; var s = bt; bt = 1; var l = Ml; Ml |= 4, Il.current = null, function (e, t) { if (ei = Wt, hr(e = pr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, a = r.focusNode; r = r.focusOffset; try { n.nodeType, a.nodeType } catch (e) { n = null; break e } var s = 0, l = -1, c = -1, u = 0, d = 0, p = e, h = null; t: for (; ;) { for (var f; p !== n || 0 !== i && 3 !== p.nodeType || (l = s + i), p !== a || 0 !== r && 3 !== p.nodeType || (c = s + r), 3 === p.nodeType && (s += p.nodeValue.length), null !== (f = p.firstChild);)h = p, p = f; for (; ;) { if (p === e) break t; if (h === n && ++u === i && (l = s), h === a && ++d === r && (c = s), null !== (f = p.nextSibling)) break; h = (p = h).parentNode } p = f } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Wt = !1, $s = t; null !== $s;)if (e = (t = $s).child, 0 != (1028 & t.subtreeFlags) && null !== e) e.return = t, $s = e; else for (; null !== $s;) { t = $s; try { var m = t.alternate; if (0 != (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, v = m.memoizedState, y = t.stateNode, b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : vo(t.type, g), v); y.__reactInternalSnapshotBeforeUpdate = b } break; case 3: var w = t.stateNode.containerInfo; 1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement); break; default: throw Error(o(163)) } } catch (e) { xc(t, t.return, e) } if (null !== (e = t.sibling)) { e.return = t.return, $s = e; break } $s = t.return } m = nl, nl = !1 }(e, n), vl(n, e), fr(ti), Wt = !!ei, ti = ei = null, e.current = n, bl(n, e, i), Qe(), Ml = l, bt = s, Pl.transition = a } else e.current = n; if (Xl && (Xl = !1, _l = e, Ql = i), 0 === (a = e.pendingLanes) && (Zl = null), function (e) { if (ot && "function" == typeof ot.onCommitFiberRoot) try { ot.onCommitFiberRoot(it, e, void 0, 128 == (128 & e.current.flags)) } catch (e) { } }(n.stateNode), ic(e, qe()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)r((i = t[n]).value, { componentStack: i.stack, digest: i.digest }); if (Yl) throw Yl = !1, e = Gl, Gl = null, e; 0 != (1 & Ql) && 0 !== e.tag && Sc(), 0 != (1 & (a = e.pendingLanes)) ? e === Jl ? ql++ : (ql = 0, Jl = e) : ql = 0, Vi() }(e, t, n, r) } finally { Pl.transition = i, bt = r } return null } function Sc() { if (null !== _l) { var e = wt(Ql), t = Pl.transition, n = bt; try { if (Pl.transition = null, bt = 16 > e ? 16 : e, null === _l) var r = !1; else { if (e = _l, _l = null, Ql = 0, 0 != (6 & Ml)) throw Error(o(331)); var i = Ml; for (Ml |= 4, $s = e.current; null !== $s;) { var a = $s, s = a.child; if (0 != (16 & $s.flags)) { var l = a.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for ($s = u; null !== $s;) { var d = $s; switch (d.tag) { case 0: case 11: case 15: rl(8, d, a) }var p = d.child; if (null !== p) p.return = d, $s = p; else for (; null !== $s;) { var h = (d = $s).sibling, f = d.return; if (al(d), d === u) { $s = null; break } if (null !== h) { h.return = f, $s = h; break } $s = f } } } var m = a.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var v = g.sibling; g.sibling = null, g = v } while (null !== g) } } $s = a } } if (0 != (2064 & a.subtreeFlags) && null !== s) s.return = a, $s = s; else e: for (; null !== $s;) { if (0 != (2048 & (a = $s).flags)) switch (a.tag) { case 0: case 11: case 15: rl(9, a, a.return) }var y = a.sibling; if (null !== y) { y.return = a.return, $s = y; break e } $s = a.return } } var b = e.current; for ($s = b; null !== $s;) { var w = (s = $s).child; if (0 != (2064 & s.subtreeFlags) && null !== w) w.return = s, $s = w; else e: for (s = b; null !== $s;) { if (0 != (2048 & (l = $s).flags)) try { switch (l.tag) { case 0: case 11: case 15: il(9, l) } } catch (e) { xc(l, l.return, e) } if (l === s) { $s = null; break e } var E = l.sibling; if (null !== E) { E.return = l.return, $s = E; break e } $s = l.return } } if (Ml = i, Vi(), ot && "function" == typeof ot.onPostCommitFiberRoot) try { ot.onPostCommitFiberRoot(it, e) } catch (e) { } r = !0 } return r } finally { bt = n, Pl.transition = t } } return !1 } function kc(e, t, n) { e = Oo(e, t = fs(0, t = us(n, t), 1), 1), t = tc(), null !== e && (vt(e, 1, t), ic(e, t)) } function xc(e, t, n) { if (3 === e.tag) kc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { kc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" == typeof t.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === Zl || !Zl.has(r))) { t = Oo(t, e = ms(t, e = us(n, e), 1), 1), e = tc(), null !== t && (vt(t, 1, e), ic(t, e)); break } } t = t.return } } function Ac(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Tl === e && (Bl & n) === n && (4 === Ol || 3 === Ol && (130023424 & Bl) === Bl && 500 > qe() - Vl ? hc(e, 0) : Nl |= n), ic(e, t) } function Ic(e, t) { 0 === t && (0 == (1 & e.mode) ? t = 1 : (t = ut, 0 == (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = tc(); null !== (e = To(e, t)) && (vt(e, t, n), ic(e, n)) } function Pc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Ic(e, n) } function Mc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(o(314)) }null !== r && r.delete(t), Ic(e, n) } function Tc(e, t) { return Ze(e, t) } function Rc(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Bc(e, t, n, r) { return new Rc(e, t, n, r) } function Dc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Lc(e, t) { var n = e.alternate; return null === n ? ((n = Bc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Oc(e, t, n, r, i, a) { var s = 2; if (r = e, "function" == typeof e) Dc(e) && (s = 1); else if ("string" == typeof e) s = 5; else e: switch (e) { case S: return Fc(n.children, i, a, t); case k: s = 8, i |= 8; break; case x: return (e = Bc(12, n, t, 2 | i)).elementType = x, e.lanes = a, e; case M: return (e = Bc(13, n, t, i)).elementType = M, e.lanes = a, e; case T: return (e = Bc(19, n, t, i)).elementType = T, e.lanes = a, e; case D: return zc(n, i, a, t); default: if ("object" == typeof e && null !== e) switch (e.$$typeof) { case A: s = 10; break e; case I: s = 9; break e; case P: s = 11; break e; case R: s = 14; break e; case B: s = 16, r = null; break e }throw Error(o(130, null == e ? e : typeof e, "")) }return (t = Bc(s, n, t, i)).elementType = e, t.type = r, t.lanes = a, t } function Fc(e, t, n, r) { return (e = Bc(7, e, r, t)).lanes = n, e } function zc(e, t, n, r) { return (e = Bc(22, e, r, t)).elementType = D, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Hc(e, t, n) { return (e = Bc(6, e, null, t)).lanes = n, e } function Nc(e, t, n) { return (t = Bc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function jc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Uc(e, t, n, r, i, o, a, s, l) { return e = new jc(e, t, n, s, l), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Bc(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Bo(o), e } function Vc(e) { if (!e) return Ii; e: { if (Ve(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Bi(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(o(171)) } if (1 === e.tag) { var n = e.type; if (Bi(n)) return Oi(e, n, t) } return t } function Kc(e, t, n, r, i, o, a, s, l) { return (e = Uc(n, r, !0, e, 0, o, 0, s, l)).context = Vc(null), n = e.current, (o = Lo(r = tc(), i = nc(n))).callback = null != t ? t : null, Oo(n, o, i), e.current.lanes = i, vt(e, i, r), ic(e, r), e } function Wc(e, t, n, r) { var i = t.current, o = tc(), a = nc(i); return n = Vc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Lo(o, a)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Oo(i, t, a)) && (rc(e, i, a, o), Fo(e, i, a)), a } function Yc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Gc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Zc(e, t) { Gc(e, t), (e = e.alternate) && Gc(e, t) } kl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Mi.current) ws = !0; else { if (0 == (e.lanes & n) && 0 == (128 & t.flags)) return ws = !1, function (e, t, n) { switch (t.tag) { case 3: Ts(t), fo(); break; case 5: aa(t); break; case 1: Bi(t.type) && Fi(t); break; case 4: ia(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ai(yo, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ai(la, 1 & la.current), t.flags |= 128, null) : 0 != (n & t.child.childLanes) ? Hs(e, t, n) : (Ai(la, 1 & la.current), null !== (e = Ys(e, t, n)) ? e.sibling : null); Ai(la, 1 & la.current); break; case 19: if (r = 0 != (n & t.childLanes), 0 != (128 & e.flags)) { if (r) return Ks(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ai(la, la.current), r) break; return null; case 22: case 23: return t.lanes = 0, xs(e, t, n) }return Ys(e, t, n) }(e, t, n); ws = 0 != (131072 & e.flags) } else ws = !1, io && 0 != (1048576 & t.flags) && $i(t, Gi, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Ws(e, t), e = t.pendingProps; var i = Ri(t, Pi.current); xo(t, n), i = ka(null, t, r, e, i, n); var a = xa(); return t.flags |= 1, "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Bi(r) ? (a = !0, Fi(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Bo(t), i.updater = Vo, t.stateNode = i, i._reactInternals = t, Go(t, r, e, n), t = Ms(null, t, r, !0, a, n)) : (t.tag = 0, io && a && eo(t), Es(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Ws(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" == typeof e) return Dc(e) ? 1 : 0; if (null != e) { if ((e = e.$$typeof) === P) return 11; if (e === R) return 14 } return 2 }(r), e = vo(r, e), i) { case 0: t = Is(null, t, r, e, n); break e; case 1: t = Ps(null, t, r, e, n); break e; case 11: t = Cs(null, t, r, e, n); break e; case 14: t = Ss(null, t, r, vo(r.type, e), n); break e }throw Error(o(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, Is(e, t, r, i = t.elementType === r ? i : vo(r, i), n); case 1: return r = t.type, i = t.pendingProps, Ps(e, t, r, i = t.elementType === r ? i : vo(r, i), n); case 3: e: { if (Ts(t), null === e) throw Error(o(387)); r = t.pendingProps, i = (a = t.memoizedState).element, Do(e, t), Ho(t, r, null, n); var s = t.memoizedState; if (r = s.element, a.isDehydrated) { if (a = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) { t = Rs(e, t, r, n, i = us(Error(o(423)), t)); break e } if (r !== i) { t = Rs(e, t, r, n, i = us(Error(o(424)), t)); break e } for (ro = ci(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = Jo(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (fo(), r === i) { t = Ys(e, t, n); break e } Es(e, t, r, n) } t = t.child } return t; case 5: return aa(t), null === e && co(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, s = i.children, ni(r, i) ? s = null : null !== a && ni(r, a) && (t.flags |= 32), As(e, t), Es(e, t, s, n), t.child; case 6: return null === e && co(t), null; case 13: return Hs(e, t, n); case 4: return ia(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = qo(t, null, r, n) : Es(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, Cs(e, t, r, i = t.elementType === r ? i : vo(r, i), n); case 7: return Es(e, t, t.pendingProps, n), t.child; case 8: case 12: return Es(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, s = i.value, Ai(yo, r._currentValue), r._currentValue = s, null !== a) if (sr(a.value, s)) { if (a.children === i.children && !Mi.current) { t = Ys(e, t, n); break e } } else for (null !== (a = t.child) && (a.return = t); null !== a;) { var l = a.dependencies; if (null !== l) { s = a.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === a.tag) { (c = Lo(-1, n & -n)).tag = 2; var u = a.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), ko(a.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === a.tag) s = a.type === t.type ? null : a.child; else if (18 === a.tag) { if (null === (s = a.return)) throw Error(o(341)); s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), ko(s, n, t), s = a.sibling } else s = a.child; if (null !== s) s.return = a; else for (s = a; null !== s;) { if (s === t) { s = null; break } if (null !== (a = s.sibling)) { a.return = s.return, s = a; break } s = s.return } a = s } Es(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, xo(t, n), r = r(i = Ao(i)), t.flags |= 1, Es(e, t, r, n), t.child; case 14: return i = vo(r = t.type, t.pendingProps), Ss(e, t, r, i = vo(r.type, i), n); case 15: return ks(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : vo(r, i), Ws(e, t), t.tag = 1, Bi(r) ? (e = !0, Fi(t)) : e = !1, xo(t, n), Wo(t, r, i), Go(t, r, i, n), Ms(null, t, r, !0, e, n); case 19: return Ks(e, t, n); case 22: return xs(e, t, n) }throw Error(o(156, t.tag)) }; var Xc = "function" == typeof reportError ? reportError : function (e) { console.error(e) }; function _c(e) { this._internalRoot = e } function Qc(e) { this._internalRoot = e } function qc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Jc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function $c() { } function eu(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var a = o; if ("function" == typeof i) { var s = i; i = function () { var e = Yc(a); s.call(e) } } Wc(t, a, e, i) } else a = function (e, t, n, r, i) { if (i) { if ("function" == typeof r) { var o = r; r = function () { var e = Yc(a); o.call(e) } } var a = Kc(t, r, e, 0, null, !1, 0, "", $c); return e._reactRootContainer = a, e[fi] = a.current, Vr(8 === e.nodeType ? e.parentNode : e), dc(), a } for (; i = e.lastChild;)e.removeChild(i); if ("function" == typeof r) { var s = r; r = function () { var e = Yc(l); s.call(e) } } var l = Uc(e, 0, !1, null, 0, !1, 0, "", $c); return e._reactRootContainer = l, e[fi] = l.current, Vr(8 === e.nodeType ? e.parentNode : e), dc((function () { Wc(t, l, n, r) })), l }(n, t, e, i, r); return Yc(a) } Qc.prototype.render = _c.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(o(409)); Wc(e, t, null, null) }, Qc.prototype.unmount = _c.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; dc((function () { Wc(null, e, null, null) })), t[fi] = null } }, Qc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = kt(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Dt.length && 0 !== t && t < Dt[n].priority; n++); Dt.splice(n, 0, e), 0 === n && zt(e) } }, Et = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (yt(t, 1 | n), ic(t, qe()), 0 == (6 & Ml) && (Kl = qe() + 500, Vi())) } break; case 13: dc((function () { var t = To(e, 1); if (null !== t) { var n = tc(); rc(t, e, 1, n) } })), Zc(e, 1) } }, Ct = function (e) { if (13 === e.tag) { var t = To(e, 134217728); null !== t && rc(t, e, 134217728, tc()), Zc(e, 134217728) } }, St = function (e) { if (13 === e.tag) { var t = nc(e), n = To(e, t); null !== n && rc(n, e, t, tc()), Zc(e, t) } }, kt = function () { return bt }, xt = function (e, t) { var n = bt; try { return bt = e, t() } finally { bt = n } }, Ce = function (e, t, n) { switch (t) { case "input": if (J(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Ei(r); if (!i) throw Error(o(90)); Z(r), J(r, i) } } } break; case "textarea": oe(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, Pe = uc, Me = dc; var tu = { usingClientEntryPoint: !1, Events: [bi, wi, Ei, Ae, Ie, uc] }, nu = { findFiberByHostInstance: yi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, ru = { bundleType: nu.bundleType, version: nu.version, rendererPackageName: nu.rendererPackageName, rendererConfig: nu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: w.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = Ye(e)) ? null : e.stateNode }, findFiberByHostInstance: nu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!iu.isDisabled && iu.supportsFiber) try { it = iu.inject(ru), ot = iu } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!qc(t)) throw Error(o(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: C, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!qc(e)) throw Error(o(299)); var n = !1, r = "", i = Xc; return null != t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Uc(e, 1, !1, null, 0, n, 0, r, i), e[fi] = t.current, Vr(8 === e.nodeType ? e.parentNode : e), new _c(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" == typeof e.render) throw Error(o(188)); throw e = Object.keys(e).join(","), Error(o(268, e)) } return null === (e = Ye(t)) ? null : e.stateNode }, t.flushSync = function (e) { return dc(e) }, t.hydrate = function (e, t, n) { if (!Jc(t)) throw Error(o(200)); return eu(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!qc(e)) throw Error(o(405)); var r = null != n && n.hydratedSources || null, i = !1, a = "", s = Xc; if (null != n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (s = n.onRecoverableError)), t = Kc(t, null, e, 1, null != n ? n : null, i, 0, a, s), e[fi] = t.current, Vr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Qc(t) }, t.render = function (e, t, n) { if (!Jc(t)) throw Error(o(200)); return eu(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Jc(e)) throw Error(o(40)); return !!e._reactRootContainer && (dc((function () { eu(null, null, e, !1, (function () { e._reactRootContainer = null, e[fi] = null })) })), !0) }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Jc(n)) throw Error(o(200)); if (null == e || void 0 === e._reactInternals) throw Error(o(38)); return eu(e, t, n, !1, r) }, t.version = "18.2.0-next-9e3b772b8-20220608" }, 3935: (e, t, n) => { "use strict"; !function e() { if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (e) { console.error(e) } }(), e.exports = n(4448) }, 5800: function (e, t, n) { !function (e, t) { "use strict"; function n(e) { if (e && e.__esModule) return e; var t = Object.create(null); return e && Object.keys(e).forEach((function (n) { if ("default" !== n) { var r = Object.getOwnPropertyDescriptor(e, n); Object.defineProperty(t, n, r.get ? r : { enumerable: !0, get: function () { return e[n] } }) } })), t.default = e, Object.freeze(t) } var r = n(t); function i(e, t) { return i = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, i(e, t) } var o = { error: null }, a = function (e) { function t() { for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return (t = e.call.apply(e, [this].concat(r)) || this).state = o, t.resetErrorBoundary = function () { for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; null == t.props.onReset || (e = t.props).onReset.apply(e, r), t.reset() }, t } var n, a; a = e, (n = t).prototype = Object.create(a.prototype), n.prototype.constructor = n, i(n, a), t.getDerivedStateFromError = function (e) { return { error: e } }; var s = t.prototype; return s.reset = function () { this.setState(o) }, s.componentDidCatch = function (e, t) { var n, r; null == (n = (r = this.props).onError) || n.call(r, e, t) }, s.componentDidUpdate = function (e, t) { var n, r, i, o, a = this.state.error, s = this.props.resetKeys; null !== a && null !== t.error && (void 0 === (i = e.resetKeys) && (i = []), void 0 === (o = s) && (o = []), i.length !== o.length || i.some((function (e, t) { return !Object.is(e, o[t]) }))) && (null == (n = (r = this.props).onResetKeysChange) || n.call(r, e.resetKeys, s), this.reset()) }, s.render = function () { var e = this.state.error, t = this.props, n = t.fallbackRender, i = t.FallbackComponent, o = t.fallback; if (null !== e) { var a = { error: e, resetErrorBoundary: this.resetErrorBoundary }; if (r.isValidElement(o)) return o; if ("function" == typeof n) return n(a); if (i) return r.createElement(i, a); throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop") } return this.props.children }, t }(r.Component); e.ErrorBoundary = a, e.useErrorHandler = function (e) { var t = r.useState(null), n = t[0], i = t[1]; if (null != e) throw e; if (null != n) throw n; return i }, e.withErrorBoundary = function (e, t) { var n = function (n) { return r.createElement(a, t, r.createElement(e, n)) }, i = e.displayName || e.name || "Unknown"; return n.displayName = "withErrorBoundary(" + i + ")", n }, Object.defineProperty(e, "__esModule", { value: !0 }) }(t, n(7294)) }, 5251: (e, t, n) => { "use strict"; var r = n(7294), i = Symbol.for("react.element"), o = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, o = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: o, _owner: s.current } } t.Fragment = o, t.jsx = c, t.jsxs = c }, 2408: (e, t) => { "use strict"; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.iterator, f = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function v(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || f } function y() { } function b(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || f } v.prototype.isReactComponent = {}, v.prototype.setState = function (e, t) { if ("object" != typeof e && "function" != typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, v.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, y.prototype = v.prototype; var w = b.prototype = new y; w.constructor = b, m(w, v.prototype), w.isPureReactComponent = !0; var E = Array.isArray, C = Object.prototype.hasOwnProperty, S = { current: null }, k = { key: !0, ref: !0, __self: !0, __source: !0 }; function x(e, t, r) { var i, o = {}, a = null, s = null; if (null != t) for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (a = "" + t.key), t) C.call(t, i) && !k.hasOwnProperty(i) && (o[i] = t[i]); var l = arguments.length - 2; if (1 === l) o.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; o.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === o[i] && (o[i] = l[i]); return { $$typeof: n, type: e, key: a, ref: s, props: o, _owner: S.current } } function A(e) { return "object" == typeof e && null !== e && e.$$typeof === n } var I = /\/+/g; function P(e, t) { return "object" == typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function M(e, t, i, o, a) { var s = typeof e; "undefined" !== s && "boolean" !== s || (e = null); var l = !1; if (null === e) l = !0; else switch (s) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return a = a(l = e), e = "" === o ? "." + P(l, 0) : o, E(a) ? (i = "", null != e && (i = e.replace(I, "$&/") + "/"), M(a, t, i, "", (function (e) { return e }))) : null != a && (A(a) && (a = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(a, i + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(I, "$&/") + "/") + e)), t.push(a)), 1; if (l = 0, o = "" === o ? "." : o + ":", E(e)) for (var c = 0; c < e.length; c++) { var u = o + P(s = e[c], c); l += M(s, t, i, u, a) } else if (u = function (e) { return null === e || "object" != typeof e ? null : "function" == typeof (e = h && e[h] || e["@@iterator"]) ? e : null }(e), "function" == typeof u) for (e = u.call(e), c = 0; !(s = e.next()).done;)l += M(s = s.value, t, i, u = o + P(s, c++), a); else if ("object" === s) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function T(e, t, n) { if (null == e) return e; var r = [], i = 0; return M(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function R(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var B = { current: null }, D = { transition: null }, L = { ReactCurrentDispatcher: B, ReactCurrentBatchConfig: D, ReactCurrentOwner: S }; t.Children = { map: T, forEach: function (e, t, n) { T(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return T(e, (function () { t++ })), t }, toArray: function (e) { return T(e, (function (e) { return e })) || [] }, only: function (e) { if (!A(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = v, t.Fragment = i, t.Profiler = a, t.PureComponent = b, t.StrictMode = o, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = L, t.cloneElement = function (e, t, r) { if (null == e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = m({}, e.props), o = e.key, a = e.ref, s = e._owner; if (null != t) { if (void 0 !== t.ref && (a = t.ref, s = S.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) C.call(t, c) && !k.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: o, ref: a, props: i, _owner: s } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: s, _context: e }, e.Consumer = e }, t.createElement = x, t.createFactory = function (e) { var t = x.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = A, t.lazy = function (e) { return { $$typeof: p, _payload: { _status: -1, _result: e }, _init: R } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = D.transition; D.transition = {}; try { e() } finally { D.transition = t } }, t.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, t.useCallback = function (e, t) { return B.current.useCallback(e, t) }, t.useContext = function (e) { return B.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return B.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return B.current.useEffect(e, t) }, t.useId = function () { return B.current.useId() }, t.useImperativeHandle = function (e, t, n) { return B.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return B.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return B.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return B.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return B.current.useReducer(e, t, n) }, t.useRef = function (e) { return B.current.useRef(e) }, t.useState = function (e) { return B.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return B.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return B.current.useTransition() }, t.version = "18.2.0" }, 7294: (e, t, n) => { "use strict"; e.exports = n(2408) }, 5893: (e, t, n) => { "use strict"; e.exports = n(5251) }, 53: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < o(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) { var s = 2 * (r + 1) - 1, l = e[s], c = s + 1, u = e[c]; if (0 > o(l, n)) c < i && 0 > o(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s); else { if (!(c < i && 0 > o(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function o(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" == typeof performance && "function" == typeof performance.now) { var a = performance; t.unstable_now = function () { return a.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var c = [], u = [], d = 1, p = null, h = 3, f = !1, m = !1, g = !1, v = "function" == typeof setTimeout ? setTimeout : null, y = "function" == typeof clearTimeout ? clearTimeout : null, b = "undefined" != typeof setImmediate ? setImmediate : null; function w(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function E(e) { if (g = !1, w(e), !m) if (null !== r(c)) m = !0, D(C); else { var t = r(u); null !== t && L(E, t.startTime - e) } } function C(e, n) { m = !1, g && (g = !1, y(A), A = -1), f = !0; var o = h; try { for (w(n), p = r(c); null !== p && (!(p.expirationTime > n) || e && !M());) { var a = p.callback; if ("function" == typeof a) { p.callback = null, h = p.priorityLevel; var s = a(p.expirationTime <= n); n = t.unstable_now(), "function" == typeof s ? p.callback = s : p === r(c) && i(c), w(n) } else i(c); p = r(c) } if (null !== p) var l = !0; else { var d = r(u); null !== d && L(E, d.startTime - n), l = !1 } return l } finally { p = null, h = o, f = !1 } } "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var S, k = !1, x = null, A = -1, I = 5, P = -1; function M() { return !(t.unstable_now() - P < I) } function T() { if (null !== x) { var e = t.unstable_now(); P = e; var n = !0; try { n = x(!0, e) } finally { n ? S() : (k = !1, x = null) } } else k = !1 } if ("function" == typeof b) S = function () { b(T) }; else if ("undefined" != typeof MessageChannel) { var R = new MessageChannel, B = R.port2; R.port1.onmessage = T, S = function () { B.postMessage(null) } } else S = function () { v(T, 0) }; function D(e) { x = e, k || (k = !0, S()) } function L(e, n) { A = v((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || f || (m = !0, D(C)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return h }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (h) { case 1: case 2: case 3: var t = 3; break; default: t = h }var n = h; h = t; try { return e() } finally { h = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = h; h = e; try { return t() } finally { h = n } }, t.unstable_scheduleCallback = function (e, i, o) { var a = t.unstable_now(); switch (o = "object" == typeof o && null !== o && "number" == typeof (o = o.delay) && 0 < o ? a + o : a, e) { case 1: var s = -1; break; case 2: s = 250; break; case 5: s = 1073741823; break; case 4: s = 1e4; break; default: s = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: o, expirationTime: s = o + s, sortIndex: -1 }, o > a ? (e.sortIndex = o, n(u, e), null === r(c) && e === r(u) && (g ? (y(A), A = -1) : g = !0, L(E, o - a))) : (e.sortIndex = s, n(c, e), m || f || (m = !0, D(C))), e }, t.unstable_shouldYield = M, t.unstable_wrapCallback = function (e) { var t = h; return function () { var n = h; h = t; try { return e.apply(this, arguments) } finally { h = n } } } }, 3840: (e, t, n) => { "use strict"; e.exports = n(53) }, 8548: (e, t, n) => { "use strict"; n.r(t), n.d(t, { default: () => v }); var r = n(3379), i = n.n(r), o = n(7795), a = n.n(o), s = n(569), l = n.n(s), c = n(3565), u = n.n(c), d = n(9216), p = n.n(d), h = n(4589), f = n.n(h), m = n(1424), g = {}; g.styleTagTransform = f(), g.setAttributes = u(), g.insert = l().bind(null, "head"), g.domAPI = a(), g.insertStyleElement = p(), i()(m.Z, g); const v = m.Z && m.Z.locals ? m.Z.locals : void 0 }, 3379: e => { "use strict"; var t = []; function n(e) { for (var n = -1, r = 0; r < t.length; r++)if (t[r].identifier === e) { n = r; break } return n } function r(e, r) { for (var o = {}, a = [], s = 0; s < e.length; s++) { var l = e[s], c = r.base ? l[0] + r.base : l[0], u = o[c] || 0, d = "".concat(c, " ").concat(u); o[c] = u + 1; var p = n(d), h = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] }; if (-1 !== p) t[p].references++, t[p].updater(h); else { var f = i(h, r); r.byIndex = s, t.splice(s, 0, { identifier: d, updater: f, references: 1 }) } a.push(d) } return a } function i(e, t) { var n = t.domAPI(t); return n.update(e), function (t) { if (t) { if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer) return; n.update(e = t) } else n.remove() } } e.exports = function (e, i) { var o = r(e = e || [], i = i || {}); return function (e) { e = e || []; for (var a = 0; a < o.length; a++) { var s = n(o[a]); t[s].references-- } for (var l = r(e, i), c = 0; c < o.length; c++) { var u = n(o[c]); 0 === t[u].references && (t[u].updater(), t.splice(u, 1)) } o = l } } }, 569: e => { "use strict"; var t = {}; e.exports = function (e, n) { var r = function (e) { if (void 0 === t[e]) { var n = document.querySelector(e); if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try { n = n.contentDocument.head } catch (e) { n = null } t[e] = n } return t[e] }(e); if (!r) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); r.appendChild(n) } }, 9216: e => { "use strict"; e.exports = function (e) { var t = document.createElement("style"); return e.setAttributes(t, e.attributes), e.insert(t, e.options), t } }, 3565: (e, t, n) => { "use strict"; e.exports = function (e) { var t = n.nc; t && e.setAttribute("nonce", t) } }, 7795: e => { "use strict"; e.exports = function (e) { if ("undefined" == typeof document) return { update: function () { }, remove: function () { } }; var t = e.insertStyleElement(e); return { update: function (n) { !function (e, t, n) { var r = ""; n.supports && (r += "@supports (".concat(n.supports, ") {")), n.media && (r += "@media ".concat(n.media, " {")); var i = void 0 !== n.layer; i && (r += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")), r += n.css, i && (r += "}"), n.media && (r += "}"), n.supports && (r += "}"); var o = n.sourceMap; o && "undefined" != typeof btoa && (r += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), t.styleTagTransform(r, e, t.options) }(t, e, n) }, remove: function () { !function (e) { if (null === e.parentNode) return !1; e.parentNode.removeChild(e) }(t) } } } }, 4589: e => { "use strict"; e.exports = function (e, t) { if (t.styleSheet) t.styleSheet.cssText = e; else { for (; t.firstChild;)t.removeChild(t.firstChild); t.appendChild(document.createTextNode(e)) } } }, 8957: function (e, t, n) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(5893), o = r(n(5551)); t.default = function () { return (0, i.jsx)("div", { children: (0, i.jsx)(o.default, {}) }) } }, 5551: function (e, t, n) { "use strict"; var r, i = this && this.__extends || (r = function (e, t) { return r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) }, r(e, t) }, function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function n() { this.constructor = e } r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) }); Object.defineProperty(t, "__esModule", { value: !0 }); var o = n(5893), a = n(9214), s = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return i(t, e), t.prototype.render = function () { return (0, o.jsx)("div", { style: { position: "fixed", inset: 0 }, children: (0, o.jsx)(a.Tldraw, { id: "tl-draw" }) }) }, t }(n(7294).Component), l = document.getElementById("tl-draw"); window.matchMedia("(prefers-color-scheme: dark)") && (null == l || l.setAttribute("darkMode", "true")), t.default = s }, 2629: function (e, t, n) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(5893), o = r(n(7294)), a = r(n(3935)), s = r(n(8957)); n(8548), a.default.render((0, i.jsx)(o.default.StrictMode, { children: (0, i.jsx)(s.default, {}) }), document.getElementById("root")) }, 3250: (e, t, n) => { "use strict"; var r = n(7294), i = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, o = r.useState, a = r.useEffect, s = r.useLayoutEffect, l = r.useDebugValue; function c(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !i(e, n) } catch (e) { return !0 } } var u = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), r = o({ inst: { value: n, getSnapshot: t } }), i = r[0].inst, u = r[1]; return s((function () { i.value = n, i.getSnapshot = t, c(i) && u({ inst: i }) }), [e, n, t]), a((function () { return c(i) && u({ inst: i }), e((function () { c(i) && u({ inst: i }) })) }), [e]), l(n), n }; t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : u }, 139: (e, t, n) => { "use strict"; var r = n(7294), i = n(1688), o = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, a = i.useSyncExternalStore, s = r.useRef, l = r.useEffect, c = r.useMemo, u = r.useDebugValue; t.useSyncExternalStoreWithSelector = function (e, t, n, r, i) { var d = s(null); if (null === d.current) { var p = { hasValue: !1, value: null }; d.current = p } else p = d.current; d = c((function () { function e(e) { if (!l) { if (l = !0, a = e, e = r(e), void 0 !== i && p.hasValue) { var t = p.value; if (i(t, e)) return s = t } return s = e } if (t = s, o(a, e)) return t; var n = r(e); return void 0 !== i && i(t, n) ? t : (a = e, s = n) } var a, s, l = !1, c = void 0 === n ? null : n; return [function () { return e(t()) }, null === c ? void 0 : function () { return e(c()) }] }), [t, n, r, i]); var h = a(e, d[0], d[1]); return l((function () { p.hasValue = !0, p.value = h }), [h]), u(h), h } }, 1688: (e, t, n) => { "use strict"; e.exports = n(3250) }, 2798: (e, t, n) => { "use strict"; e.exports = n(139) }, 8455: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/a5c897241736f5b49078.woff" }, 3998: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/e3242ba46c44371a37b9.woff2" }, 7413: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/ae30e988a8941d46ed06.woff2" }, 3076: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/7fea63fcf88020662463.woff" }, 6879: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/56ea918eed2581f663ae.woff2" }, 2400: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/d1556684a4c4c4b88f69.woff2" }, 5405: e => { "use strict"; e.exports = "data:font/woff2;base64,d09GMgABAAAAAA/UABAAAAAAKRwAAA90AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGnYbhQocKgZgP1NUQVRIAII4EQgKuSSuAQuCMAABNgIkA4QcBCAFhGIHIAwHGzEhIwPlTFQlxV8k2IZovYP7AKvRqRiDkPoYzTMOHaVEZrl6dTOcwM6PWLjqeNz07yWhUCRYCCqlCoWaURVlXcVm2pl1Zl9Eu28qEBCXtlcowJlgMBOBTASivQJmPJYJcKw0rE8NHys+6BHR37O9ewn/ySiyJgko1JzTblKnSR2tZqudcAlwehQ8sm9/IHm114SLAE7yQKAeIZZPhEv6ZvtrrTc7vW8nwB0gjVj+BZhs9PbLbHr69+bvbMKzAYadCU0AFYH7UUAOEI9cwIirs0CKhL4Txp47oc356i9LLyZQBBoBVXCNcd3APbv7f94BEAwJAACglSFcChEQQETk4EpqruXPA4XycFE8RjrPlMmzFfESZbxCC2/TxweMUK4kADfkQ+DJ2WR0sMIjuxgU74bhXlBA7edgb35FVjHQjwcMa10jwONhXyxIRgC0zq9IHADg+UdXyPMxS0x4fm92e3Nfw1fn3zbsf/7uxf/ZX/tpzT7jPb9Czwxif5UC89/neWUf71FSr4K/vg/T/9AuBwAYAG/4d5Z7of0ksX/S9RfkfQMAD0igQQ4WsIETEsAFGZDNKkYPaySNfIFxK7ZAQThsQjCFAjjAAgx44AVcwIHI7K2xVQMDGMAAPOgFIAABAjagMFP+OJoKEA2gdTlZntLjAUCEfLQTA2CrtgLISTKiGkduy9AxrhTeOLWf3gAPI0z3PftnAvh/fO7QEgCgTbNmzo9DEFatqWfDtNz81T6MAOA/uZ4YCSEECg4AC3C0E2AXYB+KBb8y0fwMJ4NGCScC03QRAdzhTYXxTUdO5vr1l+7SPACFSBBr2nMi164Tgrcb+MGz95qk0Cf2v3AqGgAAmBgCmdTKhOpjUc+mA08aUjqWRGzJOFJwpfKWBBeLIZ6XBEwuhDhSBWQKyRURyUbJJZGHlk8sh0oppRImtczqaFXQq2JQzaiGTiUfDXw18dPMXwurRoHaBGln18mhm1OPEL2CdYkwKNyASEOiDENQ4sEHALAKAIByAEoB4w8wF4B4A3gaAAAGSwIp1qAaApW+Fq+SSoQ83LplrsOo4fDM2IERUF8b2MsICYIiKWkIpRLydfxAhyGQY+YZZQJST9Jxii2UJSFYm+imsfi0ipuEyGFcPtGUJlAJaBaxhIpFEyRJqKo0epTizUuYPK9GHpPL0aTV5dWkqCAQkjmp5VHyAxNmHpXCviDSwslgPiSo+nOkBQHXdWHiI3nCECohqYlwbycAvKtN7NvTC0GFmrlmX/bPC5HaREdPdLrb48tFG7SBhWRSQN39gqD2RvHWVhDB23zA1YfQhJkeIyukMZkA+4RIsScCyGkmsjc4Wz86ptH2Un3MD5VwGGnBxQ3T72ljoqUFO4ALC37mm3pT+pkiIMyJ1CezER0/MDf0oRj/HNkbtmR3MeKr7y7Ht9M0+mVCB15U0IIMf/xlmh49W5SynFtb6LDGLyzFEdja6vCE8gMGeJfPBYhNcDCPJ9ADIXlUu0RgH/vMRD3ehspGM4PK+LGgDppss8dQmVg5SdaCsZi3iY2gxdkrqA4HWj2N01bSIe4dBHztpcSk0dNtqps4Zi9R6e4cidKYxE4d2FlwGtVO0uHbacf9yZHYje0cAERCFBXta9k+jSIqNH1M6qSO3uF6Ah3bmmGhkIlXvWuRHL17S7sorGL5s/d8dHE2ybqE1HU5c33NCUes0QtHD2aNkVNbL8OA4+Utz53WcYO0oyP1NiTvmut1I8BS/DlE74hWPSDRu3vnCj3sbD7Z3i5tZHgrB6atfWnQAx+jO1TltnnMjYA8KrqueR4+thc8wB72MH5kR5JZDbM+boom0ADoTahH1rneU0beFz2NKaAIJy6SC7c9x3korrjrqtiCm0OaQ9bOAB/s5gACVCZGaI75hOIKp1M53Q2Vk5fLizRqSHeJx9AAZMqIXPR0mRKKcBlD3ws7z9WNK277prvfU0ezwHGmiTr23VHXWWPDWNvU6hYU/bjvixB1W/XTmM9R3La2Oe33k81tO3r2zM1Tpi6fiLGTdWnJsaa+7HeEihynZBDdUpYn7bFBqDef729/1+xMyLnF5VRFi7Qr68ygt0YjGxOLj0M6O33ooLx5S1sv0/GN2ZQxSb9b3FKWUz1XkWnz9f7/BfL+f/F/6futjhBRCOAS3jpj91tWtflZyXrUnqvd/O421ZWQvesS5d2hOhey2xKRIFSQCFpNAoA98+f26/tXyguWdmXX/S+eybCisPujsQJ6/QDfm2QF368hfHm/mEydPf1dLm1zXFKlIUY0CJ8Rjz5ClZnfo3BewP2BJC5+z+wiPwzWieef1BUN2DkD4odfIgi+jKRYfK8XPxI30Nd/SsivfXo1npPkGhBm816CcHiRly0cSOAk+z8KwZL1Nw5bl7zGVSbSkcH323m6zw3VrLKlrKzl8vKcleW80uKZrLTF8qTAvrzC1gBGWG64f2tqgX2iLDm6pHFDb65ztCoJDm5WXyk2/vXpEykLpfp4lNP3YiWv3JYqUOuLOKK9K27nWPExAzNfNb9PKDnhh0hLTrIhKCDBZMxLnA1EySpJCml+1HwL10Jy7FJxeFe9M65ncrznbLiKg92CYtZYnlA19wGSVyW3GCpO6CF07eCuu97x769J7/8hV7TqiY/8+AR8pwOVuJZyHN11kfAN/XyMLKnOjJNaPIVLf2pJ4WJ8DW6uEyc9EaOWvGBe3/0NufWbFJ75Tgk8xrR+oFca7tOuOpzyN6VaOaWRh1My4SP/j/RklueQ6JzYaP1HC18dZWnnzvKJxzOlw+aOPvVIBiV/GqbZ30KC7q2PjJHlIc6a2FBj2fd5en/V0TiRNwmsHJ5gt1WtRkPx8JmTSCc9+me2y46/oT+sjk+tzszLLYM/mFHVzrD6xLTItpqI/Bwoa6kROQN+uiyJig1U2bWJTm5hflWCcerY0m0lDlBSiTwcV/ok+uJJhnYJ/TbTd0H+1uknW0ofkQJguurDQ5tdydFNTeExcdVhjsbE+PCW2hjSIFOm20pTO6PCEioyIwwlH8AX74vF7PdPfLwlqCZOGYt2+C049QUXs7R+2rKnBEI5hy01vvtKvOn8+M//kg1y/79p6eCTP7+TNHJu+XFo6mL/vPPfKk+m/KCf1X5L6p5+2JhUUVhUqjIpknj6ZZNWg1Is0BO3N1A55Rqm2bQ6naffavqOw/FXpoUTiTDPtt5yUPXHJRK8QpTW3OAUxsEXPf4BFPygh7fxa9PfGx8Vv79sW280fn+hOW+thqGTfyHmTy5VK1/qfe3krP19McT3Wp+1bm669pso77IWWoH+aPOlArrxDnI+cj8vmUfDnd93z67GPP4CulvOZcLWMzUoL608xnqXPos6OqEy+6jgjoP/piHosJ9eLZv4aFSqF6oa2km5tSVCf+8bHM67HEoDAU/S/9Lif7T0noR+F8pnV3Cxp7omcunUOUh46igtmUvDqx9Iz1TG0DDpfGf4IIrbimpWy+Ncroq4c0d3uczBTpcZ1ElJP6JPfTXPHZYr/vr8R84vVsezF+Xyv0D0y5yfTlMDXQlP4dMcrrv3rRa+zxFfqs7tSHZAgEnukgdHIaw3K9zwqeaT7vTtufSEOarI/oUCuo6US+6sYeuT1qzWO57HKI5OSrEPadm148iju+9N/h5XbH83Y4qNcWSQKn5fqrCawb+Dukp/c0ks3nT24Xde1UrfuU8s2rL2yHOfXsexClTutO1XNK1E1b+QvxDv9Pmn/YLVsomfVsAKwrJs3HXnqY+UzpbMQYbu2ckYT+4Cz91HfQfiodgNKXM5NLPpCnYKWB9NG5g2Lbu3ayLnIm8v+uWWn04tGf1+iNKTsq4W8hay6e85NpvS+HjsGcF/PaFSeNiyOLRXbmZI6P2P//SV3SA3MWjq7G1o5NuAoiisJ3lLHh375g+JPfTqeHO5dOoWRlP0fpOWK5jzs6slo/8vjFWFpVm5t1w485QyUpNpC95BXfYbYlkIgJfZn+5iMu84qsXC55rgTuBdePem9/jgGbwX70P7ySqDnheBzxef3BkT5mLf5iCEbyUvkMrgfWg/WSWC86KeA1MszrTg6QOVMR+Yov8cYppVhfzDGvCXvEAqg/eh/WSV0PMiWAIbQUqJ4DTwvJ4DBORdCAILIRvYAhtBkAhOA8/rOeAACCu08DEUmv7a43mYg+hCE2eQefmoFu4XTXAFeBPevOktPngcb8Xb0HayyqCnRMjgG0oDkOVueRxg5YKr5AVSCW/D27EbT8EkK76UjyVPJQAmd2JJxFU/ZU7GylcXejlcDh+SF0hl8Da8HbthCurxGHbjUZiC1kLubzAFHXgMu/EonoJJ3Ar9hdwpKDT6Ck8Zk+8U/3/ovf/mvx927Y+NEw99AQAACGDFw06MxV0kkawXaLmv2sTQskeVszU8kqXSUbME7ZcvAhPEWMImFiknlmdGLglgm7CwLGQBEbG0JUDlKc5t3WYRmCDGEjaxqMrZYojkh47AhiF9jixI4gABw7ubBWOzn0h+7xEYhvRFsiBJA1i3AnWlmmYBACwThRlZLUD0Lk90LeuhN4FdE+K3qBZXSZUjdy7ZI6zrMjBifuoNML/k8a4CjltmCaIcuWtwjySVbkSP33o4C4iIpe1dgPLKN6jPzMw3+UpXWXjFk0QpR+7M3iPul10jEYJ8llD5EYKpF7rdaAEC9+8aE5CCIFV6IwyvavbvVHk/V3N2zTzyKTdCAJAnHt5d0XX8mB8LJwAA4E3v+z8A4D1tRqln9/8f346eNwF4wQAAIPBbDofYarL89yrx3u78HwsBnE2Fan6RrbcsDRDUTsLY+vhlr3K2/gEBLVSDLo4+RRetkrXz8ii/ZrhA9+Ged/Mv386ulqCDeXP/0orfCMBWJHMS1mAOXoE/VLiEpOZhGZrZ6fV+gLU+3x44mW8PLOebhfk7zQICsEpkY+rFaFOgCboX137AodgbAG4CMMUR2s3iGNLTxXFRXi9OsERQnEGRsOJeTMkvRgrLcHkIgBtcDODOCSQUzTu/GhF28KgkffpNGNShTbthOg52wSLoFPOsRSephvcYsqheUvlsvC9RnUrdZB/uMhJUu6AGDa6O1VdUqp9bPoqNTZsO3Z1GNArSpE8Pm1R3Eu2GShh4i15v7mi5Jb4rUoVG1eZw524NBgULYmfnFJ1BpUubj3bdRKB9rfbrp02WatlnrAMpWdc5k//JuEOarIJXw5UOclfdCZ3ljdvY5EmVrUzLTamMVjUoVUerC4NqaAfiup55joDDvHcjz+J1YhsAAAA=" }, 2240: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/d8f5b01d012b20786bb6.woff" }, 7732: e => { "use strict"; e.exports = "data:font/woff2;base64,d09GMgABAAAAAAPEAA8AAAAAB6QAAANsAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGyAcKgZgP1NUQVSBAAA0EQgKgwyCcAsGAAE2AiQDBgQgBYV+ByAMBxt6BgiOxDgm8i6auAni6f+sr9PdoXd9Z0Uks0RGXNIP1B/IoAxuZww0II4o/597p80J3sUWcmLt15j4Tz6nRtPCwKNAfjQ3eMAbsCxAzjbbDNKPD0M2uZnI6NXPIYAfN14ApN+AYdk4MQCZDGB8Nd5fNGNOCWFOgMRioyplBzZQm9R4YKgfRqYyqOYYpaKu9ybH8bh15/4D9L2MHeY+CUxHdgOoqHoYsHgRFE5sQJQBulHDR44YKT7oO6lh4kfm5+bNkQCqsqhkjgTRfZOpsRLC4KSGRtoxKJQcRQNgYAUIgOwCQBCQPQBoFEr2yQ5QDwOgAA1EaQSIMljAYBCwLpNxZh8MRwBIomCgZD0YwAnsBi4CXQwGY7w+byRSN4uAy19svJv27RObb/PevbOvv2fYWrrdynP4+PVxV9429c08Hu0+cGNSAAqzgiL4t2gldWE1axbu5957TFZee9G96e1G7hGXlfsT52UDz+Z3XrkKKx6fLZ63X2fF1RcC5r2unncuWLEneub5t92b3n1SZOVTf49vMT684NmndJ962rGYNnXbHFjYItki9RixwP39i8E697kvr11Qc9lpofvTpwNVe9DgtW2MTYejIaP3rZMOu1cSE7q1DRdqPDxnYLVG1aud+LBDh8HRmwF7rGpEO+onq08b6GrSMzvYa1ktZ4Pydq4G15LR3+tXf/Kjdh2zE8uCtirV4jYTzfJ/mfK1GTk769/Grqx+ACCAxJ7aevCPwdMC3X5zav0lwPufnHbp4k7/f/f/PdcwkwbsKEjbf2LYNR3ifNAHwXyWqPFAQwIo2UC8uthhjjkCCHoWjRgXcAhmEDo4BIWf16EZ630YBtQONqq1SGenV3v0xEe4t+HHK59zA8KfEcQt/yOEXzmxC6eKYw9eVQv78PM65+jVVBP6KlVmoQr5cuWZw9JGK611ZsmWJ82SlDbLXBUq5ZsXlY5SoVQBYE1Tbyw1R55SuNTSSK78YP5cM7UwS6liLc1QUfD++eZYqExaSxU93Rt3p1JmKFEaxkyJdKl9av+ENc3N9RYB39FaC6100l5XvSUljdO1wcUN7OIemlMzDuxkSWysdJG2VInr5Oae6R1eTKVqXmaGWdL6UiXRDJDGqaMgKpUcrMQcfXtzY5SpuKIaYynT0yDF90tm7Q2zFQ==" }, 2975: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/f35db37ce17a987093e6.woff2" }, 9325: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/5c80075343f0e6b556f9.woff2" }, 8681: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 8353: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/7df0968e0f981f08d253.woff" }, 3221: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 1512: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 7604: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 5726: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 6807: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/06101a7ccf85875d015f.woff2" }, 4279: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/1d8ea3d31970f45e1efa.woff2" }, 5414: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 3102: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/1882629b5eaf2ec74fbf.woff" }, 5582: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 7722: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 549: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 3047: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 7306: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/c0d191aa7fb798623030.woff2" }, 6882: (e, t, n) => { "use strict"; e.exports = n.p + "fonts/fbd4fe33a443c83e04f1.woff2" }, 5417: e => { "use strict"; e.exports = "data:font/woff2;base64,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" }, 9214: (e, t, n) => {
          "use strict"; n.r(t), n.d(t, { AlignStyle: () => oC, AlignType: () => _E, Arrow: () => HA, ColorStyle: () => tC, DashStyle: () => rC, Decoration: () => eC, DistributeType: () => qE, Draw: () => zA, Ellipse: () => FA, FlipType: () => JE, FontSize: () => iC, FontStyle: () => aC, Group: () => jA, Image: () => VA, MoveType: () => XE, Rectangle: () => LA, SessionType: () => GE, SizeStyle: () => nC, Sticky: () => UA, StretchType: () => QE, TDAssetType: () => sC, TDEventHandler: () => WE, TDExportBackground: () => cC, TDExportType: () => lC, TDShapeType: () => $E, TDStatus: () => ZE, TDUserStatus: () => YE, TLDR: () => ZA, Text: () => NA, Tldraw: () => bP, TldrawApp: () => gP, Triangle: () => OA, Video: () => KA, getShapeUtil: () => YA, shapeUtils: () => WA, useFileSystem: () => VE }); var r = {}; n.r(r), n.d(r, { directoryOpen: () => zw, directoryOpenLegacy: () => qw, directoryOpenModern: () => Yw, fileOpen: () => Ow, fileOpenLegacy: () => _w, fileOpenModern: () => Uw, fileSave: () => Nw, fileSaveLegacy: () => $w, fileSaveModern: () => Zw, supported: () => Dw }); var i = n(3379), o = n.n(i), a = n(7795), s = n.n(a), l = n(569), c = n.n(l), u = n(3565), d = n.n(u), p = n(9216), h = n.n(p), f = n(4589), m = n.n(f), g = n(3358), v = {}; v.styleTagTransform = m(), v.setAttributes = d(), v.insert = c().bind(null, "head"), v.domAPI = s(), v.insertStyleElement = h(), o()(g.Z, v), g.Z && g.Z.locals && g.Z.locals; var y = n(8756), b = {}; b.styleTagTransform = m(), b.setAttributes = d(), b.insert = c().bind(null, "head"), b.domAPI = s(), b.insertStyleElement = h(), o()(y.Z, b), y.Z && y.Z.locals && y.Z.locals; var w = n(1073), E = {}; E.styleTagTransform = m(), E.setAttributes = d(), E.insert = c().bind(null, "head"), E.domAPI = s(), E.insertStyleElement = h(), o()(w.Z, E), w.Z && w.Z.locals && w.Z.locals; var C = n(9429), S = {}; S.styleTagTransform = m(), S.setAttributes = d(), S.insert = c().bind(null, "head"), S.domAPI = s(), S.insertStyleElement = h(), o()(C.Z, S), C.Z && C.Z.locals && C.Z.locals; var k = n(2905), x = {}; x.styleTagTransform = m(), x.setAttributes = d(), x.insert = c().bind(null, "head"), x.domAPI = s(), x.insertStyleElement = h(), o()(k.Z, x), k.Z && k.Z.locals && k.Z.locals; var A = n(7294), I = n.t(A, 2), P = Object.defineProperty, M = (e, t, n) => (((e, t, n) => { t in e ? P(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n })(e, "symbol" != typeof t ? t + "" : t, n), n), T = class { static clamp(e, t, n) { return Math.max(t, void 0 !== n ? Math.min(e, n) : e) } static clampV(e, t, n) { return e.map((e => n ? T.clamp(e, t, n) : T.clamp(e, t))) } static cross(e, t, n) { return (t[0] - e[0]) * (n[1] - e[1]) - (n[0] - e[0]) * (t[1] - e[1]) } static snap(e, t = 1) { return [Math.round(e[0] / t) * t, Math.round(e[1] / t) * t] } }, R = T; M(R, "neg", (e => [-e[0], -e[1]])), M(R, "add", ((e, t) => [e[0] + t[0], e[1] + t[1]])), M(R, "addScalar", ((e, t) => [e[0] + t, e[1] + t])), M(R, "sub", ((e, t) => [e[0] - t[0], e[1] - t[1]])), M(R, "subScalar", ((e, t) => [e[0] - t, e[1] - t])), M(R, "vec", ((e, t) => [t[0] - e[0], t[1] - e[1]])), M(R, "mul", ((e, t) => [e[0] * t, e[1] * t])), M(R, "mulV", ((e, t) => [e[0] * t[0], e[1] * t[1]])), M(R, "div", ((e, t) => [e[0] / t, e[1] / t])), M(R, "divV", ((e, t) => [e[0] / t[0], e[1] / t[1]])), M(R, "per", (e => [e[1], -e[0]])), M(R, "dpr", ((e, t) => e[0] * t[0] + e[1] * t[1])), M(R, "cpr", ((e, t) => e[0] * t[1] - t[0] * e[1])), M(R, "len2", (e => e[0] * e[0] + e[1] * e[1])), M(R, "len", (e => Math.hypot(e[0], e[1]))), M(R, "pry", ((e, t) => T.dpr(e, t) / T.len(t))), M(R, "uni", (e => T.div(e, T.len(e)))), M(R, "normalize", (e => T.uni(e))), M(R, "tangent", ((e, t) => T.uni(T.sub(e, t)))), M(R, "dist2", ((e, t) => T.len2(T.sub(e, t)))), M(R, "dist", ((e, t) => Math.hypot(e[1] - t[1], e[0] - t[0]))), M(R, "fastDist", ((e, t) => { let n = [t[0] - e[0], t[1] - e[1]], r = [Math.abs(n[0]), Math.abs(n[1])], i = 1 / Math.max(r[0], r[1]); return i *= 1.29289 - (r[0] + r[1]) * i * .29289, [n[0] * i, n[1] * i] })), M(R, "ang", ((e, t) => Math.atan2(T.cpr(e, t), T.dpr(e, t)))), M(R, "angle", ((e, t) => Math.atan2(t[1] - e[1], t[0] - e[0]))), M(R, "med", ((e, t) => T.mul(T.add(e, t), .5))), M(R, "rot", ((e, t = 0) => [e[0] * Math.cos(t) - e[1] * Math.sin(t), e[0] * Math.sin(t) + e[1] * Math.cos(t)])), M(R, "rotWith", ((e, t, n = 0) => { if (0 === n) return e; let r = Math.sin(n), i = Math.cos(n), o = e[0] - t[0], a = e[1] - t[1], s = o * r + a * i; return [o * i - a * r + t[0], s + t[1]] })), M(R, "isEqual", ((e, t) => e[0] === t[0] && e[1] === t[1])), M(R, "lrp", ((e, t, n) => T.add(e, T.mul(T.sub(t, e), n)))), M(R, "int", ((e, t, n, r, i = 1) => { let o = (T.clamp(n, r) - n) / (r - n); return T.add(T.mul(e, 1 - o), T.mul(t, i)) })), M(R, "ang3", ((e, t, n) => { let r = T.vec(t, e), i = T.vec(t, n); return T.ang(r, i) })), M(R, "abs", (e => [Math.abs(e[0]), Math.abs(e[1])])), M(R, "rescale", ((e, t) => { let n = T.len(e); return [t * e[0] / n, t * e[1] / n] })), M(R, "isLeft", ((e, t, n) => (t[0] - e[0]) * (n[1] - e[1]) - (n[0] - e[0]) * (t[1] - e[1]))), M(R, "clockwise", ((e, t, n) => T.isLeft(e, t, n) > 0)), M(R, "toFixed", (e => e.map((e => Math.round(100 * e) / 100)))), M(R, "nearestPointOnLineThroughPoint", ((e, t, n) => T.add(e, T.mul(t, T.pry(T.sub(n, e), t))))), M(R, "distanceToLineThroughPoint", ((e, t, n) => T.dist(n, T.nearestPointOnLineThroughPoint(e, t, n)))), M(R, "nearestPointOnLineSegment", ((e, t, n, r = !0) => { let i = T.uni(T.sub(t, e)), o = T.add(e, T.mul(i, T.pry(T.sub(n, e), i))); if (r) { if (o[0] < Math.min(e[0], t[0])) return e[0] < t[0] ? e : t; if (o[0] > Math.max(e[0], t[0])) return e[0] > t[0] ? e : t; if (o[1] < Math.min(e[1], t[1])) return e[1] < t[1] ? e : t; if (o[1] > Math.max(e[1], t[1])) return e[1] > t[1] ? e : t } return o })), M(R, "distanceToLineSegment", ((e, t, n, r = !0) => T.dist(n, T.nearestPointOnLineSegment(e, t, n, r)))), M(R, "nearestPointOnBounds", ((e, t) => [T.clamp(t[0], e.minX, e.maxX), T.clamp(t[1], e.minY, e.maxY)])), M(R, "distanceToBounds", ((e, t) => T.dist(t, T.nearestPointOnBounds(e, t)))), M(R, "nudge", ((e, t, n) => T.isEqual(e, t) ? e : T.add(e, T.mul(T.uni(T.sub(t, e)), n)))), M(R, "nudgeAtAngle", ((e, t, n) => [Math.cos(t) * n + e[0], Math.sin(t) * n + e[1]])), M(R, "toPrecision", ((e, t = 4) => [+e[0].toPrecision(t), +e[1].toPrecision(t)])), M(R, "pointsBetween", ((e, t, n = 6) => Array.from(Array(n)).map(((r, i) => { let o = i / (n - 1), a = Math.min(1, .5 + Math.abs(.5 - o)); return [...T.lrp(e, t, o), a] })))), M(R, "slope", ((e, t) => e[0] === t[0] ? NaN : (e[1] - t[1]) / (e[0] - t[0]))), M(R, "max", ((...e) => [Math.max(...e.map((e => e[0]))), Math.max(...e.map((e => e[1])))])), M(R, "min", ((...e) => [Math.min(...e.map((e => e[0]))), Math.min(...e.map((e => e[1])))])); var B = R; const D = { toVector: (e, t) => (void 0 === e && (e = t), Array.isArray(e) ? e : [e, e]), add: (e, t) => [e[0] + t[0], e[1] + t[1]], sub: (e, t) => [e[0] - t[0], e[1] - t[1]], addTo(e, t) { e[0] += t[0], e[1] += t[1] }, subTo(e, t) { e[0] -= t[0], e[1] -= t[1] } }; function L(e, t, n) { return 0 === t || Math.abs(t) === 1 / 0 ? Math.pow(e, 5 * n) : e * t * n / (t + n * e) } function O(e, t, n, r = .15) { return 0 === r ? function (e, t, n) { return Math.max(t, Math.min(e, n)) }(e, t, n) : e < t ? -L(t - e, n - t, r) + t : e > n ? +L(e - n, n - t, r) + n : e } function F(e, t, n) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, "string"); if ("object" != typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function z(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, r) } return n } function H(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? z(Object(n), !0).forEach((function (t) { F(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } const N = { pointer: { start: "down", change: "move", end: "up" }, mouse: { start: "down", change: "move", end: "up" }, touch: { start: "start", change: "move", end: "end" }, gesture: { start: "start", change: "change", end: "end" } }; function j(e) { return e ? e[0].toUpperCase() + e.slice(1) : "" } const U = ["enter", "leave"]; const V = ["gotpointercapture", "lostpointercapture"]; function K(e) { let t = e.substring(2).toLowerCase(); const n = !!~t.indexOf("passive"); n && (t = t.replace("passive", "")); const r = V.includes(t) ? "capturecapture" : "capture", i = !!~t.indexOf(r); return i && (t = t.replace("capture", "")), { device: t, capture: i, passive: n } } function W(e) { return "touches" in e } function Y(e) { return W(e) ? "touch" : "pointerType" in e ? e.pointerType : "mouse" } function G(e) { return W(e) ? function (e) { return "touchend" === e.type || "touchcancel" === e.type ? e.changedTouches : e.targetTouches }(e)[0] : e } function Z(e, t) { try { const n = t.clientX - e.clientX, r = t.clientY - e.clientY, i = (t.clientX + e.clientX) / 2, o = (t.clientY + e.clientY) / 2, a = Math.hypot(n, r); return { angle: -180 * Math.atan2(n, r) / Math.PI, distance: a, origin: [i, o] } } catch (e) { } return null } function X(e, t) { const [n, r] = Array.from(e.touches).filter((e => t.includes(e.identifier))); return Z(n, r) } function _(e) { const t = G(e); return W(e) ? t.identifier : t.pointerId } function Q(e) { const t = G(e); return [t.clientX, t.clientY] } function q(e) { let { deltaX: t, deltaY: n, deltaMode: r } = e; return 1 === r ? (t *= 40, n *= 40) : 2 === r && (t *= 800, n *= 800), [t, n] } function J(e, ...t) { return "function" == typeof e ? e(...t) : e } function $() { } function ee(...e) { return 0 === e.length ? $ : 1 === e.length ? e[0] : function () { let t; for (const n of e) t = n.apply(this, arguments) || t; return t } } function te(e, t) { return Object.assign({}, t, e || {}) } class ne { constructor(e, t, n) { this.ctrl = e, this.args = t, this.key = n, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset()) } get state() { return this.ctrl.state[this.key] } set state(e) { this.ctrl.state[this.key] = e } get shared() { return this.ctrl.state.shared } get eventStore() { return this.ctrl.gestureEventStores[this.key] } get timeoutStore() { return this.ctrl.gestureTimeoutStores[this.key] } get config() { return this.ctrl.config[this.key] } get sharedConfig() { return this.ctrl.config.shared } get handler() { return this.ctrl.handlers[this.key] } reset() { const { state: e, shared: t, ingKey: n, args: r } = this; t[n] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = r, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0 } start(e) { const t = this.state, n = this.config; t._active || (this.reset(), this.computeInitial(), t._active = !0, t.target = e.target, t.currentTarget = e.currentTarget, t.lastOffset = n.from ? J(n.from, t) : t.offset, t.offset = t.lastOffset, t.startTime = t.timeStamp = e.timeStamp) } computeValues(e) { const t = this.state; t._values = e, t.values = this.config.transform(e) } computeInitial() { const e = this.state; e._initial = e._values, e.initial = e.values } compute(e) { const { state: t, config: n, shared: r } = this; t.args = this.args; let i = 0; if (e && (t.event = e, n.preventDefault && e.cancelable && t.event.preventDefault(), t.type = e.type, r.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, r.locked = !!document.pointerLockElement, Object.assign(r, function (e) { const t = {}; if ("buttons" in e && (t.buttons = e.buttons), "shiftKey" in e) { const { shiftKey: n, altKey: r, metaKey: i, ctrlKey: o } = e; Object.assign(t, { shiftKey: n, altKey: r, metaKey: i, ctrlKey: o }) } return t }(e)), r.down = r.pressed = r.buttons % 2 == 1 || r.touches > 0, i = e.timeStamp - t.timeStamp, t.timeStamp = e.timeStamp, t.elapsedTime = t.timeStamp - t.startTime), t._active) { const e = t._delta.map(Math.abs); D.addTo(t._distance, e) } this.axisIntent && this.axisIntent(e); const [o, a] = t._movement, [s, l] = n.threshold, { _step: c, values: u } = t; if (n.hasCustomTransform ? (!1 === c[0] && (c[0] = Math.abs(o) >= s && u[0]), !1 === c[1] && (c[1] = Math.abs(a) >= l && u[1])) : (!1 === c[0] && (c[0] = Math.abs(o) >= s && Math.sign(o) * s), !1 === c[1] && (c[1] = Math.abs(a) >= l && Math.sign(a) * l)), t.intentional = !1 !== c[0] || !1 !== c[1], !t.intentional) return; const d = [0, 0]; if (n.hasCustomTransform) { const [e, t] = u; d[0] = !1 !== c[0] ? e - c[0] : 0, d[1] = !1 !== c[1] ? t - c[1] : 0 } else d[0] = !1 !== c[0] ? o - c[0] : 0, d[1] = !1 !== c[1] ? a - c[1] : 0; this.restrictToAxis && !t._blocked && this.restrictToAxis(d); const p = t.offset, h = t._active && !t._blocked || t.active; h && (t.first = t._active && !t.active, t.last = !t._active && t.active, t.active = r[this.ingKey] = t._active, e && (t.first && ("bounds" in n && (t._bounds = J(n.bounds, t)), this.setup && this.setup()), t.movement = d, this.computeOffset())); const [f, m] = t.offset, [[g, v], [y, b]] = t._bounds; t.overflow = [f < g ? -1 : f > v ? 1 : 0, m < y ? -1 : m > b ? 1 : 0], t._movementBound[0] = !!t.overflow[0] && (!1 === t._movementBound[0] ? t._movement[0] : t._movementBound[0]), t._movementBound[1] = !!t.overflow[1] && (!1 === t._movementBound[1] ? t._movement[1] : t._movementBound[1]); const w = t._active && n.rubberband || [0, 0]; if (t.offset = function (e, [t, n], [r, i]) { const [[o, a], [s, l]] = e; return [O(t, o, a, r), O(n, s, l, i)] }(t._bounds, t.offset, w), t.delta = D.sub(t.offset, p), this.computeMovement(), h && (!t.last || i > 32)) { t.delta = D.sub(t.offset, p); const e = t.delta.map(Math.abs); D.addTo(t.distance, e), t.direction = t.delta.map(Math.sign), t._direction = t._delta.map(Math.sign), !t.first && i > 0 && (t.velocity = [e[0] / i, e[1] / i], t.timeDelta = i) } } emit() { const e = this.state, t = this.shared, n = this.config; if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !n.triggerAllEvents) return; const r = this.handler(H(H(H({}, t), e), {}, { [this.aliasKey]: e.values })); void 0 !== r && (e.memo = r) } clean() { this.eventStore.clean(), this.timeoutStore.clean() } } class re extends ne { constructor(...e) { super(...e), F(this, "aliasKey", "xy") } reset() { super.reset(), this.state.axis = void 0 } init() { this.state.offset = [0, 0], this.state.lastOffset = [0, 0] } computeOffset() { this.state.offset = D.add(this.state.lastOffset, this.state.movement) } computeMovement() { this.state.movement = D.sub(this.state.offset, this.state.lastOffset) } axisIntent(e) { const t = this.state, n = this.config; if (!t.axis && e) { const r = "object" == typeof n.axisThreshold ? n.axisThreshold[Y(e)] : n.axisThreshold; t.axis = function ([e, t], n) { const r = Math.abs(e), i = Math.abs(t); return r > i && r > n ? "x" : i > r && i > n ? "y" : void 0 }(t._movement, r) } t._blocked = (n.lockDirection || !!n.axis) && !t.axis || !!n.axis && n.axis !== t.axis } restrictToAxis(e) { if (this.config.axis || this.config.lockDirection) switch (this.state.axis) { case "x": e[1] = 0; break; case "y": e[0] = 0 } } } const ie = e => e, oe = { enabled: (e = !0) => e, eventOptions: (e, t, n) => H(H({}, n.shared.eventOptions), e), preventDefault: (e = !1) => e, triggerAllEvents: (e = !1) => e, rubberband(e = 0) { switch (e) { case !0: return [.15, .15]; case !1: return [0, 0]; default: return D.toVector(e) } }, from: e => "function" == typeof e ? e : null != e ? D.toVector(e) : void 0, transform(e, t, n) { const r = e || n.shared.transform; return this.hasCustomTransform = !!r, r || ie }, threshold: e => D.toVector(e, 0) }, ae = H(H({}, oe), {}, { axis(e, t, { axis: n }) { if (this.lockDirection = "lock" === n, !this.lockDirection) return n }, axisThreshold: (e = 0) => e, bounds(e = {}) { if ("function" == typeof e) return t => ae.bounds(e(t)); if ("current" in e) return () => e.current; if ("function" == typeof HTMLElement && e instanceof HTMLElement) return e; const { left: t = -1 / 0, right: n = 1 / 0, top: r = -1 / 0, bottom: i = 1 / 0 } = e; return [[t, n], [r, i]] } }), se = { ArrowRight: (e, t = 1) => [e * t, 0], ArrowLeft: (e, t = 1) => [-1 * e * t, 0], ArrowUp: (e, t = 1) => [0, -1 * e * t], ArrowDown: (e, t = 1) => [0, e * t] }, le = "undefined" != typeof window && window.document && window.document.createElement; function ce() { return le && "ontouchstart" in window } const ue = { isBrowser: le, gesture: function () { try { return "constructor" in GestureEvent } catch (e) { return !1 } }(), touch: ce(), touchscreen: ce() || le && window.navigator.maxTouchPoints > 1, pointer: le && "onpointerdown" in window, pointerLock: le && "exitPointerLock" in window.document }, de = { mouse: 0, touch: 0, pen: 8 }, pe = H(H({}, ae), {}, { device(e, t, { pointer: { touch: n = !1, lock: r = !1, mouse: i = !1 } = {} }) { return this.pointerLock = r && ue.pointerLock, ue.touch && n ? "touch" : this.pointerLock ? "mouse" : ue.pointer && !i ? "pointer" : ue.touch ? "touch" : "mouse" }, preventScrollAxis(e, t, { preventScroll: n }) { if (this.preventScrollDelay = "number" == typeof n ? n : n || void 0 === n && e ? 250 : void 0, ue.touchscreen && !1 !== n) return e || (void 0 !== n ? "y" : void 0) }, pointerCapture(e, t, { pointer: { capture: n = !0, buttons: r = 1, keys: i = !0 } = {} }) { return this.pointerButtons = r, this.keys = i, !this.pointerLock && "pointer" === this.device && n }, threshold(e, t, { filterTaps: n = !1, tapsThreshold: r = 3, axis: i }) { const o = D.toVector(e, n ? r : i ? 1 : 0); return this.filterTaps = n, this.tapsThreshold = r, o }, swipe({ velocity: e = .5, distance: t = 50, duration: n = 250 } = {}) { return { velocity: this.transform(D.toVector(e)), distance: this.transform(D.toVector(t)), duration: n } }, delay(e = 0) { switch (e) { case !0: return 180; case !1: return 0; default: return e } }, axisThreshold: e => e ? H(H({}, de), e) : de, keyboardDisplacement: (e = 10) => e }); function he(e) { const [t, n] = e.overflow, [r, i] = e._delta, [o, a] = e._direction; (t < 0 && r > 0 && o < 0 || t > 0 && r < 0 && o > 0) && (e._movement[0] = e._movementBound[0]), (n < 0 && i > 0 && a < 0 || n > 0 && i < 0 && a > 0) && (e._movement[1] = e._movementBound[1]) } const fe = H(H({}, oe), {}, { device(e, t, { shared: n, pointer: { touch: r = !1 } = {} }) { if (n.target && !ue.touch && ue.gesture) return "gesture"; if (ue.touch && r) return "touch"; if (ue.touchscreen) { if (ue.pointer) return "pointer"; if (ue.touch) return "touch" } }, bounds(e, t, { scaleBounds: n = {}, angleBounds: r = {} }) { const i = e => { const t = te(J(n, e), { min: -1 / 0, max: 1 / 0 }); return [t.min, t.max] }, o = e => { const t = te(J(r, e), { min: -1 / 0, max: 1 / 0 }); return [t.min, t.max] }; return "function" != typeof n && "function" != typeof r ? [i(), o()] : e => [i(e), o(e)] }, threshold(e, t, n) { return this.lockDirection = "lock" === n.axis, D.toVector(e, this.lockDirection ? [.1, 3] : 0) }, modifierKey: e => void 0 === e ? "ctrlKey" : e, pinchOnWheel: (e = !0) => e }), me = H(H({}, ae), {}, { mouseOnly: (e = !0) => e }), ge = ae, ve = ae, ye = H(H({}, ae), {}, { mouseOnly: (e = !0) => e }), be = new Map, we = new Map; function Ee(e) { be.set(e.key, e.engine), we.set(e.key, e.resolver) } const Ce = { key: "drag", engine: class extends re { constructor(...e) { super(...e), F(this, "ingKey", "dragging") } reset() { super.reset(); const e = this.state; e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this) } setup() { const e = this.state; if (e._bounds instanceof HTMLElement) { const t = e._bounds.getBoundingClientRect(), n = e.currentTarget.getBoundingClientRect(), r = { left: t.left - n.left + e.offset[0], right: t.right - n.right + e.offset[0], top: t.top - n.top + e.offset[1], bottom: t.bottom - n.bottom + e.offset[1] }; e._bounds = ae.bounds(r) } } cancel() { const e = this.state; e.canceled || (e.canceled = !0, e._active = !1, setTimeout((() => { this.compute(), this.emit() }), 0)) } setActive() { this.state._active = this.state._pointerActive || this.state._keyboardActive } clean() { this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean() } pointerDown(e) { const t = this.config, n = this.state; if (null != e.buttons && (Array.isArray(t.pointerButtons) ? !t.pointerButtons.includes(e.buttons) : -1 !== t.pointerButtons && t.pointerButtons !== e.buttons)) return; const r = this.ctrl.setEventIds(e); t.pointerCapture && e.target.setPointerCapture(e.pointerId), r && r.size > 1 && n._pointerActive || (this.start(e), this.setupPointer(e), n._pointerId = _(e), n._pointerActive = !0, this.computeValues(Q(e)), this.computeInitial(), t.preventScrollAxis && "mouse" !== Y(e) ? (n._active = !1, this.setupScrollPrevention(e)) : t.delay > 0 ? (this.setupDelayTrigger(e), t.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e)) } startPointerDrag(e) { const t = this.state; t._active = !0, t._preventScroll = !0, t._delayed = !1, this.compute(e), this.emit() } pointerMove(e) { const t = this.state, n = this.config; if (!t._pointerActive) return; const r = _(e); if (void 0 !== t._pointerId && r !== t._pointerId) return; const i = Q(e); return document.pointerLockElement === e.target ? t._delta = [e.movementX, e.movementY] : (t._delta = D.sub(i, t._values), this.computeValues(i)), D.addTo(t._movement, t._delta), this.compute(e), t._delayed && t.intentional ? (this.timeoutStore.remove("dragDelay"), t.active = !1, void this.startPointerDrag(e)) : n.preventScrollAxis && !t._preventScroll ? t.axis ? t.axis === n.preventScrollAxis || "xy" === n.preventScrollAxis ? (t._active = !1, void this.clean()) : (this.timeoutStore.remove("startPointerDrag"), void this.startPointerDrag(e)) : void 0 : void this.emit() } pointerUp(e) { this.ctrl.setEventIds(e); try { this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId) } catch (e) { } const t = this.state, n = this.config; if (!t._active || !t._pointerActive) return; const r = _(e); if (void 0 !== t._pointerId && r !== t._pointerId) return; this.state._pointerActive = !1, this.setActive(), this.compute(e); const [i, o] = t._distance; if (t.tap = i <= n.tapsThreshold && o <= n.tapsThreshold, t.tap && n.filterTaps) t._force = !0; else { const [e, r] = t._delta, [i, o] = t._movement, [a, s] = n.swipe.velocity, [l, c] = n.swipe.distance, u = n.swipe.duration; if (t.elapsedTime < u) { const n = Math.abs(e / t.timeDelta), u = Math.abs(r / t.timeDelta); n > a && Math.abs(i) > l && (t.swipe[0] = Math.sign(e)), u > s && Math.abs(o) > c && (t.swipe[1] = Math.sign(r)) } } this.emit() } pointerClick(e) { !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation()) } setupPointer(e) { const t = this.config, n = t.device; t.pointerLock && e.currentTarget.requestPointerLock(), t.pointerCapture || (this.eventStore.add(this.sharedConfig.window, n, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "cancel", this.pointerUp.bind(this))) } pointerClean() { this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock() } preventScroll(e) { this.state._preventScroll && e.cancelable && e.preventDefault() } setupScrollPrevention(e) { this.state._preventScroll = !1, function (e) { "persist" in e && "function" == typeof e.persist && e.persist() }(e); const t = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), { passive: !1 }); this.eventStore.add(this.sharedConfig.window, "touch", "end", t), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", t), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e) } setupDelayTrigger(e) { this.state._delayed = !0, this.timeoutStore.add("dragDelay", (() => { this.state._step = [0, 0], this.startPointerDrag(e) }), this.config.delay) } keyDown(e) { const t = se[e.key]; if (t) { const n = this.state, r = e.shiftKey ? 10 : e.altKey ? .1 : 1; this.start(e), n._delta = t(this.config.keyboardDisplacement, r), n._keyboardActive = !0, D.addTo(n._movement, n._delta), this.compute(e), this.emit() } } keyUp(e) { e.key in se && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit()) } bind(e) { const t = this.config.device; e(t, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(t, "change", this.pointerMove.bind(this)), e(t, "end", this.pointerUp.bind(this)), e(t, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), { capture: !0, passive: !1 }) } }, resolver: pe }, Se = { key: "hover", engine: class extends re { constructor(...e) { super(...e), F(this, "ingKey", "hovering") } enter(e) { this.config.mouseOnly && "mouse" !== e.pointerType || (this.start(e), this.computeValues(Q(e)), this.compute(e), this.emit()) } leave(e) { if (this.config.mouseOnly && "mouse" !== e.pointerType) return; const t = this.state; if (!t._active) return; t._active = !1; const n = Q(e); t._movement = t._delta = D.sub(n, t._values), this.computeValues(n), this.compute(e), t.delta = t.movement, this.emit() } bind(e) { e("pointer", "enter", this.enter.bind(this)), e("pointer", "leave", this.leave.bind(this)) } }, resolver: ye }, ke = { key: "move", engine: class extends re { constructor(...e) { super(...e), F(this, "ingKey", "moving") } move(e) { this.config.mouseOnly && "mouse" !== e.pointerType || (this.state._active ? this.moveChange(e) : this.moveStart(e), this.timeoutStore.add("moveEnd", this.moveEnd.bind(this))) } moveStart(e) { this.start(e), this.computeValues(Q(e)), this.compute(e), this.computeInitial(), this.emit() } moveChange(e) { if (!this.state._active) return; const t = Q(e), n = this.state; n._delta = D.sub(t, n._values), D.addTo(n._movement, n._delta), this.computeValues(t), this.compute(e), this.emit() } moveEnd(e) { this.state._active && (this.state._active = !1, this.compute(e), this.emit()) } bind(e) { e("pointer", "change", this.move.bind(this)), e("pointer", "leave", this.moveEnd.bind(this)) } }, resolver: me }, xe = { key: "pinch", engine: class extends ne { constructor(...e) { super(...e), F(this, "ingKey", "pinching"), F(this, "aliasKey", "da") } init() { this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = new Map } reset() { super.reset(); const e = this.state; e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0 } computeOffset() { const { type: e, movement: t, lastOffset: n } = this.state; this.state.offset = "wheel" === e ? D.add(t, n) : [(1 + t[0]) * n[0], t[1] + n[1]] } computeMovement() { const { offset: e, lastOffset: t } = this.state; this.state.movement = [e[0] / t[0], e[1] - t[1]] } axisIntent() { const e = this.state, [t, n] = e._movement; if (!e.axis) { const r = 30 * Math.abs(t) - Math.abs(n); r < 0 ? e.axis = "angle" : r > 0 && (e.axis = "scale") } } restrictToAxis(e) { this.config.lockDirection && ("scale" === this.state.axis ? e[1] = 0 : "angle" === this.state.axis && (e[0] = 0)) } cancel() { const e = this.state; e.canceled || setTimeout((() => { e.canceled = !0, e._active = !1, this.compute(), this.emit() }), 0) } touchStart(e) { this.ctrl.setEventIds(e); const t = this.state, n = this.ctrl.touchIds; if (t._active && t._touchIds.every((e => n.has(e)))) return; if (n.size < 2) return; this.start(e), t._touchIds = Array.from(n).slice(0, 2); const r = X(e, t._touchIds); r && this.pinchStart(e, r) } pointerStart(e) { if (null != e.buttons && e.buttons % 2 != 1) return; this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId); const t = this.state, n = t._pointerEvents, r = this.ctrl.pointerIds; if (t._active && Array.from(n.keys()).every((e => r.has(e)))) return; if (n.size < 2 && n.set(e.pointerId, e), t._pointerEvents.size < 2) return; this.start(e); const i = Z(...Array.from(n.values())); i && this.pinchStart(e, i) } pinchStart(e, t) { this.state.origin = t.origin, this.computeValues([t.distance, t.angle]), this.computeInitial(), this.compute(e), this.emit() } touchMove(e) { if (!this.state._active) return; const t = X(e, this.state._touchIds); t && this.pinchMove(e, t) } pointerMove(e) { const t = this.state._pointerEvents; if (t.has(e.pointerId) && t.set(e.pointerId, e), !this.state._active) return; const n = Z(...Array.from(t.values())); n && this.pinchMove(e, n) } pinchMove(e, t) { const n = this.state, r = n._values[1], i = t.angle - r; let o = 0; Math.abs(i) > 270 && (o += Math.sign(i)), this.computeValues([t.distance, t.angle - 360 * o]), n.origin = t.origin, n.turns = o, n._movement = [n._values[0] / n._initial[0] - 1, n._values[1] - n._initial[1]], this.compute(e), this.emit() } touchEnd(e) { this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some((e => !this.ctrl.touchIds.has(e))) && (this.state._active = !1, this.compute(e), this.emit()) } pointerEnd(e) { const t = this.state; this.ctrl.setEventIds(e); try { e.target.releasePointerCapture(e.pointerId) } catch (e) { } t._pointerEvents.has(e.pointerId) && t._pointerEvents.delete(e.pointerId), t._active && t._pointerEvents.size < 2 && (t._active = !1, this.compute(e), this.emit()) } gestureStart(e) { e.cancelable && e.preventDefault(); const t = this.state; t._active || (this.start(e), this.computeValues([e.scale, e.rotation]), t.origin = [e.clientX, e.clientY], this.compute(e), this.emit()) } gestureMove(e) { if (e.cancelable && e.preventDefault(), !this.state._active) return; const t = this.state; this.computeValues([e.scale, e.rotation]), t.origin = [e.clientX, e.clientY]; const n = t._movement; t._movement = [e.scale - 1, e.rotation], t._delta = D.sub(t._movement, n), this.compute(e), this.emit() } gestureEnd(e) { this.state._active && (this.state._active = !1, this.compute(e), this.emit()) } wheel(e) { const t = this.config.modifierKey; t && !(Array.isArray(t) ? t.find((t => e[t])) : e[t]) || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))) } wheelStart(e) { this.start(e), this.wheelChange(e) } wheelChange(e) { "uv" in e || e.cancelable && e.preventDefault(); const t = this.state; t._delta = [-q(e)[1] / 100 * t.offset[0], 0], D.addTo(t._movement, t._delta), he(t), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit() } wheelEnd() { this.state._active && (this.state._active = !1, this.compute(), this.emit()) } bind(e) { const t = this.config.device; t && (e(t, "start", this[t + "Start"].bind(this)), e(t, "change", this[t + "Move"].bind(this)), e(t, "end", this[t + "End"].bind(this)), e(t, "cancel", this[t + "End"].bind(this)), e("lostPointerCapture", "", this[t + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), { passive: !1 }) } }, resolver: fe }, Ae = { key: "scroll", engine: class extends re { constructor(...e) { super(...e), F(this, "ingKey", "scrolling") } scroll(e) { this.state._active || this.start(e), this.scrollChange(e), this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this)) } scrollChange(e) { e.cancelable && e.preventDefault(); const t = this.state, n = function (e) { var t, n; const { scrollX: r, scrollY: i, scrollLeft: o, scrollTop: a } = e.currentTarget; return [null !== (t = null != r ? r : o) && void 0 !== t ? t : 0, null !== (n = null != i ? i : a) && void 0 !== n ? n : 0] }(e); t._delta = D.sub(n, t._values), D.addTo(t._movement, t._delta), this.computeValues(n), this.compute(e), this.emit() } scrollEnd() { this.state._active && (this.state._active = !1, this.compute(), this.emit()) } bind(e) { e("scroll", "", this.scroll.bind(this)) } }, resolver: ge }, Ie = { key: "wheel", engine: class extends re { constructor(...e) { super(...e), F(this, "ingKey", "wheeling") } wheel(e) { this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)) } wheelChange(e) { const t = this.state; t._delta = q(e), D.addTo(t._movement, t._delta), he(t), this.compute(e), this.emit() } wheelEnd() { this.state._active && (this.state._active = !1, this.compute(), this.emit()) } bind(e) { e("wheel", "", this.wheel.bind(this)) } }, resolver: ve }; const Pe = { target(e) { if (e) return () => "current" in e ? e.current : e }, enabled: (e = !0) => e, window: (e = (ue.isBrowser ? window : void 0)) => e, eventOptions: ({ passive: e = !0, capture: t = !1 } = {}) => ({ passive: e, capture: t }), transform: e => e }, Me = ["target", "eventOptions", "window", "enabled", "transform"]; function Te(e = {}, t) { const n = {}; for (const [r, i] of Object.entries(t)) switch (typeof i) { case "function": n[r] = i.call(n, e[r], r, e); break; case "object": n[r] = Te(e[r], i); break; case "boolean": i && (n[r] = e[r]) }return n } class Re { constructor(e, t) { F(this, "_listeners", new Set), this._ctrl = e, this._gestureKey = t } add(e, t, n, r, i) { const o = this._listeners, a = function (e, t = "") { const n = N[e]; return e + (n && n[t] || t) }(t, n), s = H(H({}, this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}), i); e.addEventListener(a, r, s); const l = () => { e.removeEventListener(a, r, s), o.delete(l) }; return o.add(l), l } clean() { this._listeners.forEach((e => e())), this._listeners.clear() } } class Be { constructor() { F(this, "_timeouts", new Map) } add(e, t, n = 140, ...r) { this.remove(e), this._timeouts.set(e, window.setTimeout(t, n, ...r)) } remove(e) { const t = this._timeouts.get(e); t && window.clearTimeout(t) } clean() { this._timeouts.forEach((e => { window.clearTimeout(e) })), this._timeouts.clear() } } class De { constructor(e) { var t, n; F(this, "gestures", new Set), F(this, "_targetEventStore", new Re(this)), F(this, "gestureEventStores", {}), F(this, "gestureTimeoutStores", {}), F(this, "handlers", {}), F(this, "config", {}), F(this, "pointerIds", new Set), F(this, "touchIds", new Set), F(this, "state", { shared: { shiftKey: !1, metaKey: !1, ctrlKey: !1, altKey: !1 } }), t = this, (n = e).drag && Le(t, "drag"), n.wheel && Le(t, "wheel"), n.scroll && Le(t, "scroll"), n.move && Le(t, "move"), n.pinch && Le(t, "pinch"), n.hover && Le(t, "hover") } setEventIds(e) { return W(e) ? (this.touchIds = new Set(function (e) { return function (e) { return Array.from(e.touches).filter((t => { var n, r; return t.target === e.currentTarget || (null === (n = e.currentTarget) || void 0 === n || null === (r = n.contains) || void 0 === r ? void 0 : r.call(n, t.target)) })) }(e).map((e => e.identifier)) }(e)), this.touchIds) : "pointerId" in e ? ("pointerup" === e.type || "pointercancel" === e.type ? this.pointerIds.delete(e.pointerId) : "pointerdown" === e.type && this.pointerIds.add(e.pointerId), this.pointerIds) : void 0 } applyHandlers(e, t) { this.handlers = e, this.nativeHandlers = t } applyConfig(e, t) { this.config = function (e, t, n = {}) { const r = e, { target: i, eventOptions: o, window: a, enabled: s, transform: l } = r, c = function (e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i }(r, Me); if (n.shared = Te({ target: i, eventOptions: o, window: a, enabled: s, transform: l }, Pe), t) { const e = we.get(t); n[t] = Te(H({ shared: n.shared }, c), e) } else for (const e in c) { const t = we.get(e); t && (n[e] = Te(H({ shared: n.shared }, c[e]), t)) } return n }(e, t, this.config) } clean() { this._targetEventStore.clean(); for (const e of this.gestures) this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean() } effect() { return this.config.shared.target && this.bind(), () => this._targetEventStore.clean() } bind(...e) { const t = this.config.shared, n = {}; let r; if (!t.target || (r = t.target(), r)) { if (t.enabled) { for (const t of this.gestures) { const i = this.config[t], o = Oe(n, i.eventOptions, !!r); i.enabled && new (be.get(t))(this, e, t).bind(o) } const i = Oe(n, t.eventOptions, !!r); for (const t in this.nativeHandlers) i(t, "", (n => this.nativeHandlers[t](H(H({}, this.state.shared), {}, { event: n, args: e }))), void 0, !0) } for (const e in n) n[e] = ee(...n[e]); if (!r) return n; for (const e in n) { const { device: t, capture: i, passive: o } = K(e); this._targetEventStore.add(r, t, "", n[e], { capture: i, passive: o }) } } } } function Le(e, t) { e.gestures.add(t), e.gestureEventStores[t] = new Re(e, t), e.gestureTimeoutStores[t] = new Be } const Oe = (e, t, n) => (r, i, o, a = {}, s = !1) => { var l, c; const u = null !== (l = a.capture) && void 0 !== l ? l : t.capture, d = null !== (c = a.passive) && void 0 !== c ? c : t.passive; let p = s ? r : function (e, t = "", n = !1) { const r = N[e], i = r && r[t] || t; return "on" + j(e) + j(i) + (function (e = !1, t) { return e && !U.includes(t) }(n, i) ? "Capture" : "") }(r, i, u); n && d && (p += "Passive"), e[p] = e[p] || [], e[p].push(o) }, Fe = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/; function ze(e, t, n, r, i, o) { if (!e.has(n)) return; if (!be.has(r)) return; const a = n + "Start", s = n + "End"; i[r] = e => { let r; return e.first && a in t && t[a](e), n in t && (r = t[n](e)), e.last && s in t && t[s](e), r }, o[r] = o[r] || {} } function He(e, t) { const n = ([Ce, xe, Ae, Ie, ke, Se].forEach(Ee), function (e, t) { const { handlers: n, nativeHandlers: r, config: i } = function (e, t) { const [n, r, i] = function (e) { const t = {}, n = {}, r = new Set; for (let i in e) Fe.test(i) ? (r.add(RegExp.lastMatch), n[i] = e[i]) : t[i] = e[i]; return [n, t, r] }(e), o = {}; return ze(i, n, "onDrag", "drag", o, t), ze(i, n, "onWheel", "wheel", o, t), ze(i, n, "onScroll", "scroll", o, t), ze(i, n, "onPinch", "pinch", o, t), ze(i, n, "onMove", "move", o, t), ze(i, n, "onHover", "hover", o, t), { handlers: o, config: t, nativeHandlers: r } }(e, t || {}); return function (e, t = {}, n, r) { const i = A.useMemo((() => new De(e)), []); if (i.applyHandlers(e, r), i.applyConfig(t, n), A.useEffect(i.effect.bind(i)), A.useEffect((() => i.clean.bind(i)), []), void 0 === t.target) return i.bind.bind(i) }(n, i, void 0, r) }); return n(e, t || {}) } function Ne(e, t, n, r = (e => e)) { return e * r(.5 - t * (.5 - n)) } function je(e, t) { return [e[0] + t[0], e[1] + t[1]] } function Ue(e, t) { return [e[0] - t[0], e[1] - t[1]] } function Ve(e, t) { return [e[0] * t, e[1] * t] } function Ke(e) { return [e[1], -e[0]] } function We(e, t) { return e[0] * t[0] + e[1] * t[1] } function Ye(e, t) { return e[0] === t[0] && e[1] === t[1] } function Ge(e, t) { return function (e) { return e[0] * e[0] + e[1] * e[1] }(Ue(e, t)) } function Ze(e) { return function (e, t) { return [e[0] / t, e[1] / t] }(e, function (e) { return Math.hypot(e[0], e[1]) }(e)) } function Xe(e, t) { return Math.hypot(e[1] - t[1], e[0] - t[0]) } function _e(e, t, n) { let r = Math.sin(n), i = Math.cos(n), o = e[0] - t[0], a = e[1] - t[1], s = o * r + a * i; return [o * i - a * r + t[0], s + t[1]] } function Qe(e, t, n) { return je(e, Ve(Ue(t, e), n)) } function qe(e, t, n) { return je(e, Ve(t, n)) } var { min: Je, PI: $e } = Math, et = $e + 1e-4; function tt(e, t = {}) { let { size: n = 16, smoothing: r = .5, thinning: i = .5, simulatePressure: o = !0, easing: a = (e => e), start: s = {}, end: l = {}, last: c = !1 } = t, { cap: u = !0, easing: d = (e => e * (2 - e)) } = s, { cap: p = !0, easing: h = (e => --e * e * e + 1) } = l; if (0 === e.length || n <= 0) return []; let f, m = e[e.length - 1].runningLength, g = !1 === s.taper ? 0 : !0 === s.taper ? Math.max(n, m) : s.taper, v = !1 === l.taper ? 0 : !0 === l.taper ? Math.max(n, m) : l.taper, y = Math.pow(n * r, 2), b = [], w = [], E = e.slice(0, 10).reduce(((e, t) => { let r = t.pressure; if (o) { let i = Je(1, t.distance / n), o = Je(1, 1 - i); r = Je(1, e + .275 * i * (o - e)) } return (e + r) / 2 }), e[0].pressure), C = Ne(n, i, e[e.length - 1].pressure, a), S = e[0].vector, k = e[0].point, x = k, A = k, I = x, P = !1; for (let t = 0; t < e.length; t++) { let { pressure: r } = e[t], { point: s, vector: l, distance: c, runningLength: u } = e[t]; if (t < e.length - 1 && m - u < 3) continue; if (i) { if (o) { let e = Je(1, c / n), t = Je(1, 1 - e); r = Je(1, E + .275 * e * (t - E)) } C = Ne(n, i, r, a) } else C = n / 2; void 0 === f && (f = C); let p = u < g ? d(u / g) : 1, M = m - u < v ? h((m - u) / v) : 1; C = Math.max(.01, C * Math.min(p, M)); let T = (t < e.length - 1 ? e[t + 1] : e[t]).vector, R = t < e.length - 1 ? We(l, T) : 1, B = null !== R && R < 0; if (We(l, S) < 0 && !P || B) { let e = Ve(Ke(S), C); for (let t = 1 / 13, n = 0; n <= 1; n += t)A = _e(Ue(s, e), s, et * n), b.push(A), I = _e(je(s, e), s, et * -n), w.push(I); k = A, x = I, B && (P = !0); continue } if (P = !1, t === e.length - 1) { let e = Ve(Ke(l), C); b.push(Ue(s, e)), w.push(je(s, e)); continue } let D = Ve(Ke(Qe(T, l, R)), C); A = Ue(s, D), (t <= 1 || Ge(k, A) > y) && (b.push(A), k = A), I = je(s, D), (t <= 1 || Ge(x, I) > y) && (w.push(I), x = I), E = r, S = l } let M = e[0].point.slice(0, 2), T = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : je(e[0].point, [1, 1]), R = [], B = []; if (1 === e.length) { if (!g && !v || c) { let e = qe(M, Ze(Ke(Ue(M, T))), -(f || C)), t = []; for (let n = 1 / 13, r = n; r <= 1; r += n)t.push(_e(e, M, 2 * et * r)); return t } } else { if (!(g || v && 1 === e.length)) if (u) for (let e = 1 / 13, t = e; t <= 1; t += e) { let e = _e(w[0], M, et * t); R.push(e) } else { let e = Ue(b[0], w[0]), t = Ve(e, .5), n = Ve(e, .51); R.push(Ue(M, t), Ue(M, n), je(M, n), je(M, t)) } let t = Ke(function (e) { return [-e[0], -e[1]] }(e[e.length - 1].vector)); if (v || g && 1 === e.length) B.push(T); else if (p) { let e = qe(T, t, C); for (let t = 1 / 29, n = t; n < 1; n += t)B.push(_e(e, T, 3 * et * n)) } else B.push(je(T, Ve(t, C)), je(T, Ve(t, .99 * C)), Ue(T, Ve(t, .99 * C)), Ue(T, Ve(t, C))) } return b.concat(B, w.reverse(), R) } function nt(e, t = {}) { var n; let { streamline: r = .5, size: i = 16, last: o = !1 } = t; if (0 === e.length) return []; let a = .15 + .85 * (1 - r), s = Array.isArray(e[0]) ? e : e.map((({ x: e, y: t, pressure: n = .5 }) => [e, t, n])); if (2 === s.length) { let e = s[1]; s = s.slice(0, -1); for (let t = 1; t < 5; t++)s.push(Qe(s[0], e, t / 4)) } 1 === s.length && (s = [...s, [...je(s[0], [1, 1]), ...s[0].slice(2)]]); let l = [{ point: [s[0][0], s[0][1]], pressure: s[0][2] >= 0 ? s[0][2] : .25, vector: [1, 1], distance: 0, runningLength: 0 }], c = !1, u = 0, d = l[0], p = s.length - 1; for (let e = 1; e < s.length; e++) { let t = o && e === p ? s[e].slice(0, 2) : Qe(d.point, s[e], a); if (Ye(d.point, t)) continue; let n = Xe(t, d.point); if (u += n, e < p && !c) { if (u < i) continue; c = !0 } d = { point: t, pressure: s[e][2] >= 0 ? s[e][2] : .5, vector: Ze(Ue(d.point, t)), distance: n, runningLength: u }, l.push(d) } return l[0].vector = (null == (n = l[1]) ? void 0 : n.vector) || [0, 0], l } var rt = function (e, t = {}) { return tt(nt(e, t), t) }, it = Object.defineProperty, ot = Object.defineProperties, at = Object.getOwnPropertyDescriptors, st = Object.getOwnPropertySymbols, lt = Object.prototype.hasOwnProperty, ct = Object.prototype.propertyIsEnumerable, ut = (e, t, n) => t in e ? it(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, dt = (e, t) => { for (var n in t || (t = {})) lt.call(t, n) && ut(e, n, t[n]); if (st) for (var n of st(t)) ct.call(t, n) && ut(e, n, t[n]); return e }, pt = (e, t) => ot(e, at(t)); function ht(e, ...t) { return { didIntersect: t.length > 0, message: e, points: t } } function ft(e, t, n = 0) { let r = [e[0] + t[0] / 2, e[1] + t[1] / 2], i = R.rotWith(e, r, n), o = R.rotWith(R.add(e, [t[0], 0]), r, n), a = R.rotWith(R.add(e, t), r, n), s = R.rotWith(R.add(e, [0, t[1]]), r, n); return [["top", [i, o]], ["right", [o, a]], ["bottom", [a, s]], ["left", [s, i]]] } function mt(e, t, n, r) { let [i, o] = e, [a, s] = t, [l, c] = n, [u, d] = r; if (s / a != (d - c) / (u - l)) { let e = a * (d - c) - s * (u - l); if (0 !== e) { let t = ((o - c) * (u - l) - (i - l) * (d - c)) / e, n = ((o - c) * a - (i - l) * s) / e; if (t >= 0 && n >= 0 && n <= 1) return ht("intersection", [i + t * a, o + t * s]) } } return ht("no intersection") } function gt(e, t, n, r, i, o) { return wt(e, R.mul(t, 999999999), n, r, i, o) } function vt(e, t, n, r = 0) { let { minX: i, minY: o, width: a, height: s } = n; return function (e, t, n, r, i = 0) { return function (e, t, n, r, i) { return ft(e, t, n).reduce(((e, [t, [n, o]]) => { let a = mt(r, i, n, o); return a && e.push(ht(t, ...a.points)), e }), []).filter((e => e.didIntersect)) }(n, r, i, e, t) }(e, t, [i, o], [a, s], r) } function yt(e, t, n, r) { let i = R.sub(e, n), o = R.sub(r, n), a = R.sub(t, e), s = o[0] * i[1] - o[1] * i[0], l = a[0] * i[1] - a[1] * i[0], c = o[1] * a[0] - o[0] * a[1]; if (0 === s || 0 === l) return ht("coincident"); if (0 === c) return ht("parallel"); if (0 !== c) { let t = s / c, n = l / c; if (0 <= t && t <= 1 && 0 <= n && n <= 1) return ht("intersection", R.add(e, R.mul(a, t))) } return ht("no intersection") } function bt(e, t, n, r) { let i = (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]), o = 2 * ((t[0] - e[0]) * (e[0] - n[0]) + (t[1] - e[1]) * (e[1] - n[1])), a = o * o - 4 * i * (n[0] * n[0] + n[1] * n[1] + e[0] * e[0] + e[1] * e[1] - 2 * (n[0] * e[0] + n[1] * e[1]) - r * r); if (a < 0) return ht("outside"); if (0 === a) return ht("tangent"); let s = Math.sqrt(a), l = (-o + s) / (2 * i), c = (-o - s) / (2 * i); if ((l < 0 || l > 1) && (c < 0 || c > 1)) return ht(l < 0 && c < 0 || l > 1 && c > 1 ? "outside" : "inside"); let u = []; return 0 <= l && l <= 1 && u.push(R.lrp(e, t, l)), 0 <= c && c <= 1 && u.push(R.lrp(e, t, c)), ht("intersection", ...u) } function wt(e, t, n, r, i, o = 0) { if (0 === r || 0 === i || R.isEqual(e, t)) return ht("no intersection"); r = r < 0 ? r : -r, i = i < 0 ? i : -i, e = R.sub(R.rotWith(e, n, -o), n), t = R.sub(R.rotWith(t, n, -o), n); let a = R.sub(t, e), s = a[0] * a[0] / r / r + a[1] * a[1] / i / i, l = 2 * e[0] * a[0] / r / r + 2 * e[1] * a[1] / i / i, c = [], u = l * l - 4 * s * (e[0] * e[0] / r / r + e[1] * e[1] / i / i - 1); if (0 === u) c.push(-l / 2 / s); else if (u > 0) { let e = Math.sqrt(u); c.push((-l + e) / 2 / s), c.push((-l - e) / 2 / s) } let d = c.filter((e => e >= 0 && e <= 1)).map((r => R.add(n, R.add(e, R.mul(R.sub(t, e), r))))).map((e => R.rotWith(e, n, o))); return ht("intersection", ...d) } function Et(e, t, n) { return function (e, t, n) { let { minX: r, minY: i, width: o, height: a } = e; return function (e, t, n, r) { return St(n, r, e, t) }(t, n, [r, i], [o, a]) }(n, e, t) } function Ct(e, t, n) { let r = []; for (let i = 1; i < n.length; i++) { let o = yt(e, t, n[i - 1], n[i]); o && r.push(...o.points) } return 0 === r.length ? ht("no intersection") : ht("intersection", ...n) } function St(e, t, n, r) { return ft(e, t).reduce(((e, [t, [i, o]]) => { let a = yt(n, r, i, o); return a && e.push(ht(t, ...a.points)), e }), []).filter((e => e.didIntersect)) } function kt(e, t, n, r, i, o) { return ft(e, t).reduce(((e, [t, [a, s]]) => { let l = function (e, t, n, r, i, o) { return function (e, t, n, r, i, o) { let a = R.angle(n, i), s = R.angle(n, o), l = function (e, t, n, r = 0, i, o) { return t === n ? bt(i, o, e, t) : wt(i, o, e, t, n, r) }(n, r, r, 0, e, t); if (!l.didIntersect) return ht("no intersection"); let c = l.points.filter((e => function (e, t, n) { if (n === e || n === t) return !0; let r = 2 * Math.PI, i = (t - e + r) % r, o = (n - e + r) % r; return i <= Math.PI != o > i }(a, s, R.angle(n, e)))); return 0 === c.length ? ht("no intersection") : ht("intersection", ...c) }(i, o, e, t, n, r) }(n, r, i, o, a, s); return l && e.push(pt(dt({}, l), { message: t })), e }), []).filter((e => e.didIntersect)) } function xt(e, t, n, r = 0, i, o) { return t === n ? function (e, t, n, r) { return ft(e, t).reduce(((e, [t, [i, o]]) => { let a = bt(i, o, n, r); return a && e.push(pt(dt({}, a), { message: t })), e }), []).filter((e => e.didIntersect)) }(i, o, e, t) : function (e, t, n, r, i, o = 0) { return ft(e, t).reduce(((e, [t, [a, s]]) => { let l = wt(a, s, n, r, i, o); return l && e.push(pt(dt({}, l), { message: t })), e }), []).filter((e => e.didIntersect)) }(i, o, e, t, n, r) } function At(e, t) { return function (e, t) { return function (e, t, n) { return ft(e, t).reduce(((e, [t, [r, i]]) => { let o = Ct(r, i, n); return o.didIntersect && e.push(ht(t, ...o.points)), e }), []).filter((e => e.didIntersect)) }([t.minX, t.minY], [t.width, t.height], e) }(t, e) } function It(e, t) { return function (e, t, n) { return ft(e, t).reduce(((e, [t, [r, i]]) => { let o = function (e, t, n) { let r = []; for (let i = 1; i < n.length + 1; i++) { let o = yt(e, t, n[i - 1], n[i % n.length]); o && r.push(...o.points) } return 0 === r.length ? ht("no intersection") : ht("intersection", ...n) }(r, i, n); return o.didIntersect && e.push(ht(t, ...o.points)), e }), []).filter((e => e.didIntersect)) }([t.minX, t.minY], [t.width, t.height], e) } var Pt = Object.defineProperty, Mt = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, Rt = Object.getOwnPropertySymbols, Bt = Object.prototype.hasOwnProperty, Dt = Object.prototype.propertyIsEnumerable, Lt = (e, t, n) => t in e ? Pt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ot = (e, t) => { for (var n in t || (t = {})) Bt.call(t, n) && Lt(e, n, t[n]); if (Rt) for (var n of Rt(t)) Dt.call(t, n) && Lt(e, n, t[n]); return e }, Ft = (e, t) => Mt(e, Tt(t)), zt = (e, t) => { var n = {}; for (var r in e) Bt.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && Rt) for (var r of Rt(e)) t.indexOf(r) < 0 && Dt.call(e, r) && (n[r] = e[r]); return n }, Ht = (e, t, n) => (Lt(e, "symbol" != typeof t ? t + "" : t, n), n), Nt = A.createContext({}); function jt() { return A.useContext(Nt) } var Ut = (e => (e.TransformSelected = "transform_selected", e.TranslateSelected = "translate_selected", e.TransformAll = "transform_all", e.TranslateAll = "translate_all", e))(Ut || {}), Vt = (e => (e.Top = "top_edge", e.Right = "right_edge", e.Bottom = "bottom_edge", e.Left = "left_edge", e))(Vt || {}), Kt = (e => (e.TopLeft = "top_left_corner", e.TopRight = "top_right_corner", e.BottomRight = "bottom_right_corner", e.BottomLeft = "bottom_left_corner", e))(Kt || {}), Wt = (e => (e.minX = "minX", e.midX = "midX", e.maxX = "maxX", e.minY = "minY", e.midY = "midY", e.maxY = "maxY", e))(Wt || {}); String.prototype.replaceAll || (String.prototype.replaceAll = function (e, t) { return "[object regexp]" === Object.prototype.toString.call(e).toLowerCase() ? this.replace(e, t) : this.replace(new RegExp(e, "g"), t) }); var Yt = 2 * Math.PI, Gt = class { static lerp(e, t, n) { return e * (1 - (n = Gt.clamp(n, 0, 1))) + t * n } static lerpColor(e, t, n = .5) { function r(e) { let t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e); return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] } let i = r(e) || [0, 0, 0], o = r(t) || [0, 0, 0], a = i.slice(); for (let e = 0; e < 3; e++)a[e] = Math.round(a[e] + n * (o[e] - i[e])); return function (e) { return "#" + ((1 << 24) + (e[0] << 16) + (e[1] << 8) + e[2]).toString(16).slice(1) }(a) } static modulate(e, t, n, r = !1) { let [i, o] = t, [a, s] = n, l = a + (e - i) / (o - i) * (s - a); return r ? a < s ? Math.max(Math.min(l, s), a) : Math.max(Math.min(l, a), s) : l } static clamp(e, t, n) { return Math.max(t, void 0 !== n ? Math.min(e, n) : e) } static deepClone(e) { if (null === e) return e; if (Array.isArray(e)) return [...e]; if ("object" == typeof e) { let t = Ot({}, e); return Object.keys(t).forEach((n => t[n] = "object" == typeof e[n] ? Gt.deepClone(e[n]) : e[n])), t } return e } static rng(e = "") { let t = 0, n = 0, r = 0, i = 0; function o() { let e = t ^ t << 11; return t = n, n = r, r = i, i ^= (i >>> 19 ^ e ^ e >>> 8) >>> 0, i / 4294967296 } for (let n = 0; n < e.length + 64; n++)t ^= 0 | e.charCodeAt(n), o(); return o } static pointsToLineSegments(e, t = !1) { let n = []; for (let t = 1; t < e.length; t++)n.push([e[t - 1], e[t]]); return t && n.push([e[e.length - 1], e[0]]), n } static getRectangleSides(e, t, n = 0) { let r = [e[0] + t[0] / 2, e[1] + t[1] / 2], i = R.rotWith(e, r, n), o = R.rotWith(R.add(e, [t[0], 0]), r, n), a = R.rotWith(R.add(e, t), r, n), s = R.rotWith(R.add(e, [0, t[1]]), r, n); return [["top", [i, o]], ["right", [o, a]], ["bottom", [a, s]], ["left", [s, i]]] } static circleFromThreePoints(e, t, n) { let [r, i] = e, [o, a] = t, [s, l] = n, c = r * (a - l) - i * (o - s) + o * l - s * a, u = -((r * r + i * i) * (l - a) + (o * o + a * a) * (i - l) + (s * s + l * l) * (a - i)) / (2 * c), d = -((r * r + i * i) * (o - s) + (o * o + a * a) * (s - r) + (s * s + l * l) * (r - o)) / (2 * c); return [u, d, Math.hypot(u - r, d - i)] } static perimeterOfEllipse(e, t) { let n = Math.pow(e - t, 2) / Math.pow(e + t, 2); return Math.PI * (e + t) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n))) } static shortAngleDist(e, t) { let n = 2 * Math.PI, r = (t - e) % n; return 2 * r % n - r } static longAngleDist(e, t) { return 2 * Math.PI - Gt.shortAngleDist(e, t) } static lerpAngles(e, t, n) { return e + Gt.shortAngleDist(e, t) * n } static angleDelta(e, t) { return Gt.shortAngleDist(e, t) } static getSweep(e, t, n) { return Gt.angleDelta(R.angle(e, t), R.angle(e, n)) } static clampRadians(e) { return (2 * Math.PI + e) % (2 * Math.PI) } static snapAngleToSegments(e, t) { let n = 2 * Math.PI / t; return Math.floor((Gt.clampRadians(e) + n / 2) / n) * n } static isAngleBetween(e, t, n) { if (n === e || n === t) return !0; let r = (t - e + Yt) % Yt, i = (n - e + Yt) % Yt; return r <= Math.PI != i > r } static degreesToRadians(e) { return e * Math.PI / 180 } static radiansToDegrees(e) { return 180 * e / Math.PI } static getArcLength(e, t, n, r) { let i = Gt.getSweep(e, n, r); return t * (2 * Math.PI) * (i / (2 * Math.PI)) } static getSweepFlag(e, t, n) { let r = R.angle(e, n); return (R.angle(e, t) - r + 3 * Math.PI) % (2 * Math.PI) - Math.PI > 0 ? 0 : 1 } static getLargeArcFlag(e, t, n) { let r = R.angle(n, e), i = (R.angle(n, t) - r + 3 * Math.PI) % (2 * Math.PI) - Math.PI; return Math.abs(i) > Math.PI / 2 ? 0 : 1 } static getArcDashOffset(e, t, n, r, i) { let o = Gt.getSweepFlag(e, n, r), a = Gt.getArcLength(e, t, n, r); return -(o < 0 ? a : 2 * Math.PI * e[2] - a) / 2 + i } static getEllipseDashOffset(e, t) { return -2 * Math.PI * e[2] / 2 - t } static pointInCircle(e, t, n) { return R.dist(e, t) <= n } static pointInEllipse(e, t, n, r, i = 0) { i = i || 0; let o = Math.cos(i), a = Math.sin(i), s = R.sub(e, t), l = o * s[0] + a * s[1], c = a * s[0] - o * s[1]; return l * l / (n * n) + c * c / (r * r) <= 1 } static pointInRect(e, t) { return !(e[0] < t[0] || e[0] > e[0] + t[0] || e[1] < t[1] || e[1] > e[1] + t[1]) } static pointInPolygon(e, t) { let n = 0; return t.forEach(((r, i) => { let o = t[(i + 1) % t.length]; r[1] <= e[1] ? o[1] > e[1] && R.cross(r, o, e) > 0 && (n += 1) : o[1] <= e[1] && R.cross(r, o, e) < 0 && (n -= 1) })), 0 !== n } static pointInBounds(e, t) { return !(e[0] < t.minX || e[0] > t.maxX || e[1] < t.minY || e[1] > t.maxY) } static pointInPolyline(e, t, n = 3) { for (let r = 1; r < t.length; r++)if (R.distanceToLineSegment(t[r - 1], t[r], e) < n) return !0; return !1 } static getBoundsSides(e) { return this.getRectangleSides([e.minX, e.minY], [e.width, e.height]) } static expandBounds(e, t) { return { minX: e.minX - t, minY: e.minY - t, maxX: e.maxX + t, maxY: e.maxY + t, width: e.width + 2 * t, height: e.height + 2 * t } } static boundsCollide(e, t) { return !(e.maxX < t.minX || e.minX > t.maxX || e.maxY < t.minY || e.minY > t.maxY) } static boundsContain(e, t) { return e.minX < t.minX && e.minY < t.minY && e.maxY > t.maxY && e.maxX > t.maxX } static boundsContained(e, t) { return Gt.boundsContain(t, e) } static boundsAreEqual(e, t) { return !(t.maxX !== e.maxX || t.minX !== e.minX || t.maxY !== e.maxY || t.minY !== e.minY) } static getBoundsFromPoints(e, t = 0) { let n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0; if (e.length < 2) n = 0, r = 0, i = 1, o = 1; else for (let [t, a] of e) n = Math.min(t, n), r = Math.min(a, r), i = Math.max(t, i), o = Math.max(a, o); return 0 !== t ? Gt.getBoundsFromPoints(e.map((e => R.rotWith(e, [(n + i) / 2, (r + o) / 2], t)))) : { minX: n, minY: r, maxX: i, maxY: o, width: Math.max(1, i - n), height: Math.max(1, o - r) } } static centerBounds(e, t) { let n = this.getBoundsCenter(e), r = t[0] - n[0], i = t[1] - n[1]; return this.translateBounds(e, [r, i]) } static snapBoundsToGrid(e, t) { let n = Math.round(e.minX / t) * t, r = Math.round(e.minY / t) * t, i = Math.round(e.maxX / t) * t, o = Math.round(e.maxY / t) * t; return { minX: n, minY: r, maxX: i, maxY: o, width: Math.max(1, i - n), height: Math.max(1, o - r) } } static translateBounds(e, t) { return { minX: e.minX + t[0], minY: e.minY + t[1], maxX: e.maxX + t[0], maxY: e.maxY + t[1], width: e.width, height: e.height } } static rotateBounds(e, t, n) { let [r, i] = R.rotWith([e.minX, e.minY], t, n), [o, a] = R.rotWith([e.maxX, e.maxY], t, n); return { minX: r, minY: i, maxX: o, maxY: a, width: e.width, height: e.height } } static getRotatedEllipseBounds(e, t, n, r, i = 0) { let o = Math.cos(i), a = Math.sin(i), s = Math.hypot(n * o, r * a), l = Math.hypot(n * a, r * o); return { minX: e + n - s, minY: t + r - l, maxX: e + n + s, maxY: t + r + l, width: 2 * s, height: 2 * l } } static getExpandedBounds(e, t) { let n = Math.min(e.minX, t.minX), r = Math.min(e.minY, t.minY), i = Math.max(e.maxX, t.maxX), o = Math.max(e.maxY, t.maxY); return { minX: n, minY: r, maxX: i, maxY: o, width: Math.abs(i - n), height: Math.abs(o - r) } } static getCommonBounds(e) { if (e.length < 2) return e[0]; let t = e[0]; for (let n = 1; n < e.length; n++)t = Gt.getExpandedBounds(t, e[n]); return t } static getRotatedCorners(e, t = 0) { let n = [e.minX + e.width / 2, e.minY + e.height / 2]; return [[e.minX, e.minY], [e.maxX, e.minY], [e.maxX, e.maxY], [e.minX, e.maxY]].map((e => R.rotWith(e, n, t))) } static getTransformedBoundingBox(e, t, n, r = 0, i = !1) { let [o, a] = [e.minX, e.minY], [s, l] = [e.maxX, e.maxY], [c, u] = [e.minX, e.minY], [d, p] = [e.maxX, e.maxY]; if ("center" === t) return { minX: c + n[0], minY: u + n[1], maxX: d + n[0], maxY: p + n[1], width: d - c, height: p - u, scaleX: 1, scaleY: 1 }; let [h, f] = R.rot(n, -r); switch (t) { case "top_edge": case "top_left_corner": case "top_right_corner": u += f; break; case "bottom_edge": case "bottom_left_corner": case "bottom_right_corner": p += f }switch (t) { case "left_edge": case "top_left_corner": case "bottom_left_corner": c += h; break; case "right_edge": case "top_right_corner": case "bottom_right_corner": d += h }let m = s - o, g = l - a, v = (d - c) / m, y = (p - u) / g, b = v < 0, w = y < 0, E = Math.abs(d - c), C = Math.abs(p - u); if (i) { let e = m / g, n = e < E / C, r = E * (y < 0 ? 1 : -1) * (1 / e), i = C * (v < 0 ? 1 : -1) * e; switch (t) { case "top_left_corner": n ? u = p + r : c = d + i; break; case "top_right_corner": n ? u = p + r : d = c - i; break; case "bottom_right_corner": n ? p = u - r : d = c - i; break; case "bottom_left_corner": n ? p = u - r : c = d + i; break; case "bottom_edge": case "top_edge": { let t = (c + d) / 2, n = C * e; c = t - n / 2, d = t + n / 2; break } case "left_edge": case "right_edge": { let t = (u + p) / 2, n = E / e; u = t - n / 2, p = t + n / 2; break } } } if (r % (2 * Math.PI) != 0) { let e = [0, 0], n = R.med([o, a], [s, l]), i = R.med([c, u], [d, p]); switch (t) { case "top_left_corner": e = R.sub(R.rotWith([d, p], i, r), R.rotWith([s, l], n, r)); break; case "top_right_corner": e = R.sub(R.rotWith([c, p], i, r), R.rotWith([o, l], n, r)); break; case "bottom_right_corner": e = R.sub(R.rotWith([c, u], i, r), R.rotWith([o, a], n, r)); break; case "bottom_left_corner": e = R.sub(R.rotWith([d, u], i, r), R.rotWith([s, a], n, r)); break; case "top_edge": e = R.sub(R.rotWith(R.med([c, p], [d, p]), i, r), R.rotWith(R.med([o, l], [s, l]), n, r)); break; case "left_edge": e = R.sub(R.rotWith(R.med([d, u], [d, p]), i, r), R.rotWith(R.med([s, a], [s, l]), n, r)); break; case "bottom_edge": e = R.sub(R.rotWith(R.med([c, u], [d, u]), i, r), R.rotWith(R.med([o, a], [s, a]), n, r)); break; case "right_edge": e = R.sub(R.rotWith(R.med([c, u], [c, p]), i, r), R.rotWith(R.med([o, a], [o, l]), n, r)) }[c, u] = R.sub([c, u], e), [d, p] = R.sub([d, p], e) } return d < c && ([d, c] = [c, d]), p < u && ([p, u] = [u, p]), { minX: c, minY: u, maxX: d, maxY: p, width: d - c, height: p - u, scaleX: (d - c) / (s - o || 1) * (b ? -1 : 1), scaleY: (p - u) / (l - a || 1) * (w ? -1 : 1) } } static getTransformAnchor(e, t, n) { let r = e; switch (e) { case "top_left_corner": r = t && n ? "bottom_right_corner" : t ? "top_right_corner" : n ? "bottom_left_corner" : "bottom_right_corner"; break; case "top_right_corner": r = t && n ? "bottom_left_corner" : t ? "top_left_corner" : n ? "bottom_right_corner" : "bottom_left_corner"; break; case "bottom_right_corner": r = t && n ? "top_left_corner" : t ? "bottom_left_corner" : n ? "top_right_corner" : "top_left_corner"; break; case "bottom_left_corner": r = t && n ? "top_right_corner" : t ? "bottom_right_corner" : n ? "top_left_corner" : "top_right_corner" }return r } static getRelativeTransformedBoundingBox(e, t, n, r, i) { let o = (r ? t.maxX - n.maxX : n.minX - t.minX) / t.width, a = (i ? t.maxY - n.maxY : n.minY - t.minY) / t.height, s = n.width / t.width, l = n.height / t.height, c = e.minX + e.width * o, u = e.minY + e.height * a, d = e.width * s, p = e.height * l; return { minX: c, minY: u, maxX: c + d, maxY: u + p, width: d, height: p } } static getRotatedSize(e, t) { let n = R.div(e, 2), r = [[0, 0], [e[0], 0], e, [0, e[1]]].map((e => R.rotWith(e, n, t))), i = Gt.getBoundsFromPoints(r); return [i.width, i.height] } static getBoundsCenter(e) { return [e.minX + e.width / 2, e.minY + e.height / 2] } static getBoundsWithCenter(e) { let t = Gt.getBoundsCenter(e); return Ft(Ot({}, e), { midX: t[0], midY: t[1] }) } static getCommonTopLeft(e) { let t = [1 / 0, 1 / 0]; return e.forEach((e => { t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]) })), t } static getFromCache(e, t, n) { let r = e.get(t); if (void 0 === r && (e.set(t, n()), r = e.get(t), void 0 === r)) throw Error("Cache did not include item!"); return r } static uniqueId(e = "") { return e ? ((Number(e) ^ 16 * Math.random()) >> Number(e) / 4).toString(16) : "10000000-1000-4000-8000-100000000000".replace(/[018]/g, Gt.uniqueId) } static rotateArray(e, t) { return e.map(((n, r) => e[(r + t) % e.length])) } static debounce(e, t = 0) { let n; return function (...r) { clearTimeout(n), n = setTimeout((() => e.apply(r)), t) } } static getSvgPathFromStroke(e, t = !0) { let n = e.length; if (n < 4) return ""; let r = e[0], i = e[1], o = e[2], a = `M${r[0].toFixed(2)},${r[1].toFixed(2)} Q${i[0].toFixed(2)},${i[1].toFixed(2)} ${Xt(i[0], o[0]).toFixed(2)},${Xt(i[1], o[1]).toFixed(2)} T`; for (let t = 2, o = n - 1; t < o; t++)r = e[t], i = e[t + 1], a += `${Xt(r[0], i[0]).toFixed(2)},${Xt(r[1], i[1]).toFixed(2)} `; return t && (a += "Z"), a } static getSvgPathFromStrokePoints(e, t = !1) { let n = e.length; if (n < 4) return ""; let r = e[0].point, i = e[1].point, o = e[2].point, a = `M${r[0].toFixed(2)},${r[1].toFixed(2)} Q${i[0].toFixed(2)},${i[1].toFixed(2)} ${Xt(i[0], o[0]).toFixed(2)},${Xt(i[1], o[1]).toFixed(2)} T`; for (let t = 2, o = n - 1; t < o; t++)r = e[t].point, i = e[t + 1].point, a += `${Xt(r[0], i[0]).toFixed(2)},${Xt(r[1], i[1]).toFixed(2)} `; return t && (a += "Z"), a } static getPerfectDashProps(e, t, n, r = 1, i = !0, o = 2) { let a, s, l; if ("dashed" === n.toLowerCase()) a = t * o, l = 1, s = i ? (a / 2).toString() : "0"; else { if ("dotted" !== n.toLowerCase()) return { strokeDasharray: "none", strokeDashoffset: "none" }; a = t / 100, l = 100, s = "0" } let c = Math.floor(e / a / (2 * l)); return c -= c % r, c = Math.max(c, 4), { strokeDasharray: [a, Math.max(a, (e - c * a) / (i ? c : c - 1))].join(" "), strokeDashoffset: s } } static isMobileSafari() { if ("undefined" == typeof window) return !1; let e = window.navigator.userAgent, t = !!e.match(/iPad/i) || !!e.match(/iPhone/i), n = !!e.match(/WebKit/i); return t && n && !e.match(/CriOS/i) } static throttle(e, t) { let n, r; return function (...i) { return n || (n = !0, setTimeout((() => n = !1), t), r = e(...i)), r } } static isDarwin() { return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform) } static metaKey(e) { return Gt.isDarwin() ? e.metaKey : e.ctrlKey } static lns(e) { let t = e.split(""); return t.push(...t.splice(0, Math.round(t.length / 5))), t.push(...t.splice(0, Math.round(t.length / 4))), t.push(...t.splice(0, Math.round(t.length / 3))), t.push(...t.splice(0, Math.round(t.length / 2))), t.reverse().map((e => +e ? +e < 5 ? +e + 5 : +e > 5 ? +e - 5 : e : e)).join("") } }, Zt = Gt; function Xt(e, t) { return (e + t) / 2 } Ht(Zt, "getSnapPoints", ((e, t, n) => { let r = Ot({}, e), i = [0, 0], o = [], a = { minX: { id: "minX", isSnapped: !1 }, midX: { id: "midX", isSnapped: !1 }, maxX: { id: "maxX", isSnapped: !1 }, minY: { id: "minY", isSnapped: !1 }, midY: { id: "midY", isSnapped: !1 }, maxY: { id: "maxY", isSnapped: !1 } }, s = ["midX", "minX", "maxX"], l = ["midY", "minY", "maxY"], c = t.map((e => { let t = s.flatMap(((t, n) => s.map(((i, o) => { let a = r[t] - e[i], s = Math.abs(a); return { f: t, t: i, gap: a, distance: s, isCareful: 0 === n || n + o === 3 } })))), n = l.flatMap(((t, n) => l.map(((i, o) => { let a = r[t] - e[i], s = Math.abs(a); return { f: t, t: i, gap: a, distance: s, isCareful: 0 === n || n + o === 3 } })))); return [e, t, n] })), u = 1 / 0, d = 1 / 0, p = 1 / 0, h = 1 / 0; return c.forEach((([e, t, r]) => { t.forEach((e => { e.distance < n && e.distance < p && (p = e.distance, u = e.gap) })), r.forEach((e => { e.distance < n && e.distance < h && (h = e.distance, d = e.gap) })) })), c.forEach((([e, t, n]) => { u !== 1 / 0 && t.forEach((t => { Math.abs(t.gap - u) < 2 && (a[t.f] = Ft(Ot({}, a[t.f]), { isSnapped: !0, to: e[t.t], B: e, distance: t.distance })) })), d !== 1 / 0 && n.forEach((t => { Math.abs(t.gap - d) < 2 && (a[t.f] = Ft(Ot({}, a[t.f]), { isSnapped: !0, to: e[t.t], B: e, distance: t.distance })) })) })), i[0] = u === 1 / 0 ? 0 : u, i[1] = d === 1 / 0 ? 0 : d, r.minX -= i[0], r.midX -= i[0], r.maxX -= i[0], r.minY -= i[1], r.midY -= i[1], r.maxY -= i[1], s.forEach((e => { let t = a[e]; if (!t.isSnapped) return; let { id: n, B: i } = t, s = r[n]; o.push("minX" === n ? [[s, r.midY], [s, i.minY], [s, i.maxY]] : [[s, r.minY], [s, r.maxY], [s, i.minY], [s, i.maxY]]) })), l.forEach((e => { let t = a[e]; if (!t.isSnapped) return; let { id: n, B: i } = t, s = r[n]; o.push("midY" === n ? [[r.midX, s], [i.minX, s], [i.maxX, s]] : [[r.minX, s], [r.maxX, s], [i.minX, s], [i.maxX, s]]) })), { offset: i, snapLines: o } })), Ht(Zt, "deepMerge", ((e, t) => { let n = Ot({}, e), r = Object.entries(t); for (let [e, t] of r) n[e] = t !== Object(t) || Array.isArray(t) ? t : Gt.deepMerge(n[e], t); return n })); var _t = Zt; var Qt = 10; function qt(e, t, n, r, i, o = !1, a = !1, s, l) { let c = { shape: e, asset: e.assetId ? i[e.assetId] : void 0, meta: s, isChildOfSelected: a, isGhost: e.isGhost || o, isEditing: r.editingId === e.id, isBinding: l === e.id, isSelected: r.selectedIds.includes(e.id), isHovered: r.hoveredId === e.id || void 0 !== e.children && (r.hoveredId && e.children.includes(r.hoveredId) || e.children.some((e => r.selectedIds.includes(e)))) }; t.push(c), e.children && (c.children = [], e.children.map((e => n[e])).filter((e => n[e.id])).sort(((e, t) => e.childIndex - t.childIndex)).forEach((e => qt(e, c.children, n, r, i, c.isGhost, c.isSelected || c.isChildOfSelected, s)))) } function Jt(e, t, n, r) { let { callbacks: i, shapeUtils: o, bounds: a } = jt(), s = A.useRef(), l = A.useRef(-1), c = A.useRef(new Set), u = A.useRef(new Set), { selectedIds: d, camera: p } = t, [h, f] = R.sub(R.div([0, 0], p.zoom), p.point), [m, g] = R.sub(R.div([a.width, a.height], p.zoom), p.point), v = { minX: h, minY: f, maxX: m, maxY: g, height: m - h, width: g - f }, y = u.current, b = c.current; y.clear(), b.clear(), Object.values(e.shapes).filter((e => o[e.type].isStateful || d.includes(e.id) || function (e, t) { return Zt.boundsContain(t, e) || Zt.boundsCollide(t, e) }(o[e.type].getBounds(e), v))).forEach((t => { if (t.parentId === e.id) return b.add(t.id), void y.add(t); let n = e.shapes[t.parentId]; if (void 0 === n) throw Error(`A shape (${t.id}) has a parent (${t.parentId}) that does not exist!`); b.add(n.id), y.add(n) })), y.size !== l.current && (s.current && clearTimeout(s.current), s.current = requestAnimationFrame((() => { var e; null == (e = i.onRenderCountChange) || e.call(i, Array.from(b.values())) })), l.current = y.size); let w = t.bindingId ? e.bindings[t.bindingId].toId : void 0, E = []; return y.forEach((i => { if (void 0 === i) throw Error("Rendered shapes included a missing shape"); qt(i, E, e.shapes, t, n, i.isGhost, !1, r, w) })), E.sort(((e, t) => e.shape.childIndex - t.shape.childIndex)), E } var $t = new Map; var en = { accent: "rgb(255, 0, 0)", brushFill: "rgba(0,0,0,.05)", brushStroke: "rgba(0,0,0,.25)", brushDashStroke: "rgba(0,0,0,.6)", selectStroke: "rgb(66, 133, 244)", selectFill: "rgba(65, 132, 244, 0.05)", binding: "rgba(65, 132, 244, 0.12)", background: "rgb(248, 249, 250)", foreground: "rgb(51, 51, 51)", grid: "rgba(144, 144, 144, 1)" }, tn = ((e, ...t) => e.reduce(((e, n, r) => e + n + (r < t.length ? t[r] : "")), ""))`
    .tl-container {
      --tl-zoom: 1;
      --tl-scale: calc(1 / var(--tl-zoom));
      --tl-padding: calc(64px * max(1, var(--tl-scale)));
      --tl-performance-all: auto;
      --tl-performance-selected: auto;
      position: relative;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      box-sizing: border-box;
      padding: 0px;
      margin: 0px;
      z-index: 100;
      overflow: hidden;
      touch-action: none;
      overscroll-behavior: none;
      background-color: var(--tl-background);
    }
    .tl-container * {
      box-sizing: border-box;
    }
    .tl-overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      touch-action: none;
      pointer-events: none;
    }
    .tl-grid {
      position: absolute;
      width: 100%;
      height: 100%;
      touch-action: none;
      pointer-events: none;
      user-select: none;
    }
    .tl-snap-line {
      stroke: var(--tl-accent);
      stroke-width: calc(1px * var(--tl-scale));
    }
    .tl-snap-point {
      stroke: var(--tl-accent);
      stroke-width: calc(1px * var(--tl-scale));
    }
    .tl-canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      touch-action: none;
      pointer-events: all;
      overflow: clip;
    }
    .tl-layer {
      position: absolute;
      top: 0px;
      left: 0px;
      height: 0px;
      width: 0px;
      contain: layout style size;
    }
    .tl-absolute {
      position: absolute;
      top: 0px;
      left: 0px;
      transform-origin: center center;
      contain: layout style size;
    }
    .tl-positioned {
      position: absolute;
      top: 0px;
      left: 0px;
      transform-origin: center center;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      contain: layout style size;
      will-change: var(--tl-performance-all);
    }
    .tl-positioned-svg {
      width: 100%;
      height: 100%;
      overflow: hidden;
      contain: layout style size;
    }
    .tl-positioned-div {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      padding: var(--tl-padding);
      overflow: hidden;
      contain: layout style size;
    }
    .tl-positioned-selected {
      will-change: var(--tl-performance-selected);
    }
    .tl-inner-div {
      position: relative;
      width: 100%;
      height: 100%;
    }
    .tl-stroke-hitarea {
      fill: none;
      stroke: transparent;
      stroke-width: calc(24px * var(--tl-scale));
      pointer-events: stroke;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .tl-fill-hitarea {
      fill: transparent;
      stroke: transparent;
      stroke-width: calc(24px * var(--tl-scale));
      pointer-events: all;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .tl-counter-scaled {
      transform: scale(var(--tl-scale));
    }
    .tl-dashed {
      stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));
    }
    .tl-transparent {
      fill: transparent;
      stroke: transparent;
    }
    .tl-cursor-ns {
      cursor: ns-resize;
    }
    .tl-cursor-ew {
      cursor: ew-resize;
    }
    .tl-cursor-nesw {
      cursor: nesw-resize;
    }
    .tl-cursor-nwse {
      cursor: nwse-resize;
    }
    .tl-corner-handle {
      stroke: var(--tl-selectStroke);
      fill: var(--tl-background);
      stroke-width: calc(1.5px * var(--tl-scale));
    }
    .tl-rotate-handle {
      stroke: var(--tl-selectStroke);
      fill: var(--tl-background);
      stroke-width: calc(1.5px * var(--tl-scale));
      cursor: grab;
    }
    .tl-binding {
      fill: var(--tl-selectFill);
      stroke: var(--tl-selectStroke);
      stroke-width: calc(1px * var(--tl-scale));
      pointer-events: none;
    }
    .tl-user {
      left: calc(-15px * var(--tl-scale));
      top: calc(-15px * var(--tl-scale));
      height: calc(35px * var(--tl-scale));
      width: calc(35px * var(--tl-scale));
      transform: scale(var(--tl-scale));
      pointer-events: none;
      will-change: transform;
    }
    .tl-animated {
      transition: transform 200ms linear;
    }
    .tl-indicator {
      fill: transparent;
      stroke-width: calc(1.5px * var(--tl-scale));
      pointer-events: none;
    }
    .tl-user-indicator-bounds {
      border-style: solid;
      border-width: calc(1px * var(--tl-scale));
    }
    .tl-hovered {
      stroke: var(--tl-selectStroke);
    }
    .tl-selected {
      stroke: var(--tl-selectStroke);
    }
    .tl-locked {
      stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));
    }
    .tl-editing {
      stroke-width: calc(2.5px * min(5, var(--tl-scale)));
    }
    .tl-performance {
      will-change: transform, contents;
    }
    .tl-clone-target {
      pointer-events: all;
    }
    .tl-clone-target:hover .tl-clone-button {
      opacity: 1;
    }
    .tl-clone-button-target {
      cursor: pointer;
      pointer-events: all;
    }
    .tl-clone-button-target:hover .tl-clone-button {
      fill: var(--tl-selectStroke);
    }
    .tl-clone-button {
      opacity: 0;
      r: calc(8px * var(--tl-scale));
      stroke-width: calc(1.5px * var(--tl-scale));
      stroke: var(--tl-selectStroke);
      fill: var(--tl-background);
    }
    .tl-bounds {
      pointer-events: none;
      contain: layout style size;
    }
    .tl-bounds-bg {
      stroke: none;
      fill: var(--tl-selectFill);
      pointer-events: all;
      contain: layout style size;
    }
    .tl-bounds-center {
      fill: transparent;
      stroke: var(--tl-selectStroke);
      stroke-width: calc(1.5px * var(--tl-scale));
    }
    .tl-brush {
      fill: var(--tl-brushFill);
      stroke: var(--tl-brushStroke);
      stroke-width: calc(1px * var(--tl-scale));
      pointer-events: none;
      contain: layout style size;
    }
    .tl-dashed-brush-line {
      fill: none;
      stroke: var(--tl-brushDashStroke);
      stroke-width: calc(1px * var(--tl-scale));
      pointer-events: none;
    }
    .tl-brush.dashed {
      stroke: none;
    }
    .tl-handle {
      pointer-events: all;
      cursor: grab;
    }
    .tl-handle:hover .tl-handle-bg {
      fill: var(--tl-selectFill);
    }
    .tl-handle:hover .tl-handle-bg > * {
      stroke: var(--tl-selectFill);
    }
    .tl-handle:active .tl-handle-bg {
      cursor: grabbing;
      fill: var(--tl-selectFill);
    }
    .tl-handle:active .tl-handle-bg > * {
      stroke: var(--tl-selectFill);
    }
    .tl-handle {
      fill: var(--tl-background);
      stroke: var(--tl-selectStroke);
      stroke-width: 1.5px;
    }
    .tl-handle-bg {
      fill: transparent;
      stroke: none;
      pointer-events: all;
      r: calc(16px / max(1, var(--tl-zoom)));
    }
    .tl-binding-indicator {
      fill: transparent;
      stroke: var(--tl-binding);
    }
    .tl-centered-g {
      transform: translate(var(--tl-padding), var(--tl-padding));
    }
    .tl-current-parent > *[data-shy='true'] {
      opacity: 1;
    }
    .tl-binding {
      fill: none;
      stroke: var(--tl-selectStroke);
      stroke-width: calc(2px * var(--tl-scale));
    }
    .tl-grid-dot {
      fill: var(--tl-grid);
    }
    .tl-erase-line {
      stroke-linejoin: round;
      stroke-linecap: round;
      pointer-events: none;
      fill: var(--tl-grid);
      opacity: 0.32;
    }
  `; function nn(e, t) { (function (e, t, n = ":root") { A.useLayoutEffect((() => { let r = document.createElement("style"), i = function (e, t) { return Object.keys(t).reduce(((n, r) => { let i = t[r]; return i ? n + `--${e}-${r}: ${i};\n` : n }), "") }(e, t); return r.setAttribute("id", `${e}-theme`), r.setAttribute("data-selector", n), r.innerHTML = `\n        ${n} {\n          ${i}\n        }\n      `, document.head.appendChild(r), () => { r && document.head.contains(r) && document.head.removeChild(r) } }), [e, t, n]) })("tl", A.useMemo((() => Ot(Ot({}, en), e)), [e]), t), function (e, t) { A.useLayoutEffect((() => { if ($t.get(e)) return () => { }; let n = document.createElement("style"); return n.innerHTML = t, n.setAttribute("id", e), document.head.appendChild(n), $t.set(e, n), () => { n && document.head.contains(n) && (document.head.removeChild(n), $t.delete(e)) } }), [e, t]) }("tl-canvas", tn) } function rn(e) { let { callbacks: t, inputs: n } = jt(), r = A.useCallback((r => { var i, o, a, s; if (r.dead || (r.dead = !0, !n.pointerIsValid(r))) return; null == (i = r.currentTarget) || i.setPointerCapture(r.pointerId); let l = n.pointerDown(r, e); 2 !== r.button ? (0 === r.button && (null == (a = t.onPointBoundsHandle) || a.call(t, l, r)), null == (s = t.onPointerDown) || s.call(t, l, r)) : null == (o = t.onRightPointBoundsHandle) || o.call(t, l, r) }), [n, t, e]), i = A.useCallback((r => { var i, o, a; if (r.dead || (r.dead = !0, 2 === r.button || !n.pointerIsValid(r))) return; let s = n.pointerUp(r, e), l = n.isDoubleClick(); 0 === r.button && (l && !(s.altKey || s.metaKey) && (null == (i = t.onDoubleClickBoundsHandle) || i.call(t, s, r)), null == (o = t.onReleaseBoundsHandle) || o.call(t, s, r)), null == (a = t.onPointerUp) || a.call(t, s, r) }), [n, t, e]), o = A.useCallback((r => { var i, o; if (r.dead || (r.dead = !0, !n.pointerIsValid(r)) || 2 === r.buttons) return; let a = n.pointerMove(r, e); 1 === r.buttons && r.currentTarget.hasPointerCapture(r.pointerId) && (null == (i = t.onDragBoundsHandle) || i.call(t, a, r)), null == (o = t.onPointerMove) || o.call(t, a, r) }), [n, t, e]), a = A.useCallback((r => { var i; !n.pointerIsValid(r) || null == (i = t.onHoverBoundsHandle) || i.call(t, n.pointerEnter(r, e), r) }), [n, t, e]), s = A.useCallback((r => { var i; !n.pointerIsValid(r) || null == (i = t.onUnhoverBoundsHandle) || i.call(t, n.pointerEnter(r, e), r) }), [n, t, e]); return { onPointerDown: r, onPointerUp: i, onPointerEnter: a, onPointerMove: o, onPointerLeave: s } } function on(e, t) { return [(e[0] + t.point[0]) * t.zoom, (e[1] + t.point[1]) * t.zoom] } function an(e, t) { return e[t.type] } function sn(e, t = 0) { let n = A.useRef(null); return A.useLayoutEffect((() => { let r = n.current, i = `\n    translate(\n      calc(${e.minX}px - var(--tl-padding)),\n      calc(${e.minY}px - var(--tl-padding))\n    )\n    rotate(${t + (e.rotation || 0)}rad)`; r.style.setProperty("transform", i), r.style.setProperty("width", `calc(${Math.floor(e.width)}px + (var(--tl-padding) * 2))`), r.style.setProperty("height", `calc(${Math.floor(e.height)}px + (var(--tl-padding) * 2))`) }), [e, t]), n } var ln = A.memo((function (e) { var t = e, { id: n, bounds: r, rotation: i = 0, isGhost: o = !1, isSelected: a = !1, children: s } = t, l = zt(t, ["id", "bounds", "rotation", "isGhost", "isSelected", "children"]); let c = sn(r, i); return A.createElement("div", Ot({ id: n, ref: c, className: `tl-positioned${o ? " tl-ghost" : ""}${a ? " tl-positioned-selected" : ""}`, "aria-label": "container", "data-testid": "container" }, l), s) })), cn = A.memo((function ({ brush: e, zoom: t, dashed: n }) { return A.createElement(ln, { bounds: e, rotation: 0 }, A.createElement(gn, null, A.createElement("rect", { className: "tl-brush" + (n ? " dashed" : ""), opacity: 1, x: 0, y: 0, width: e.width, height: e.height, "aria-label": "brush" }), n && A.createElement("g", { className: "tl-dashed-brush-line" }, A.createElement(un, { x1: 0, y1: 0, x2: e.width, y2: 0, zoom: t }), A.createElement(un, { x1: e.width, y1: 0, x2: e.width, y2: e.height, zoom: t }), A.createElement(un, { x1: 0, y1: e.height, x2: e.width, y2: e.height, zoom: t }), A.createElement(un, { x1: 0, y1: 0, x2: 0, y2: e.height, zoom: t })))) })); function un({ x1: e, y1: t, x2: n, y2: r, zoom: i }) { let o = _t.getPerfectDashProps(Math.hypot(n - e, r - t), 1 / i, "dashed", 1, !0, 3); return A.createElement("line", { x1: e, y1: t, x2: n, y2: r, strokeWidth: 1 / i, strokeDasharray: o.strokeDasharray, strokeDashoffset: o.strokeDashoffset }) } var dn = A.memo((({ color: e }) => A.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 35 35", fill: "none", fillRule: "evenodd" }, A.createElement("g", { fill: "rgba(0,0,0,.2)", transform: "translate(1,1)" }, A.createElement("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), A.createElement("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })), A.createElement("g", { fill: "white" }, A.createElement("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), A.createElement("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })), A.createElement("g", { fill: e }, A.createElement("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }), A.createElement("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" }))))), pn = A.memo((function ({ points: e, zoom: t }) { if (0 === e.length) return null; let n = _t.getSvgPathFromStroke(rt(e, { size: 16 / t, start: { taper: !0 } })); return A.createElement("path", { d: n, className: "tl-erase-line" }) })), hn = [[-1, .15, 64], [.05, .375, 16], [.15, 1, 4], [.7, 2.5, 1]]; function fn({ grid: e, camera: t }) { return A.createElement("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("defs", null, hn.map((([n, r, i], o) => { let a = i * e * t.zoom, s = t.point[0] * t.zoom, l = t.point[1] * t.zoom, c = s > 0 ? s % a : a + s % a, u = l > 0 ? l % a : a + l % a, d = t.zoom < r ? _t.modulate(t.zoom, [n, r], [0, 1]) : 1; return A.createElement("pattern", { key: `grid-pattern-${o}`, id: `grid-${o}`, width: a, height: a, patternUnits: "userSpaceOnUse" }, A.createElement("circle", { className: "tl-grid-dot", cx: c, cy: u, r: 1, opacity: d })) }))), hn.map(((e, t) => A.createElement("rect", { key: `grid-rect-${t}`, width: "100%", height: "100%", fill: `url(#grid-${t})` })))) } var mn = A.memo((function ({ camera: { zoom: e, point: t }, children: n }) { let r = 2.5 / e; return A.createElement("svg", { className: "tl-overlay" }, A.createElement("defs", null, A.createElement("g", { id: "tl-snap-point" }, A.createElement("path", { className: "tl-snap-point", d: `M ${-r},${-r} L ${r},${r} M ${-r},${r} L ${r},${-r}` }))), A.createElement("g", { transform: `scale(${e}) translate(${t})` }, n)) })), gn = A.memo(A.forwardRef((function (e, t) { var n = e, { id: r, className: i = "", children: o } = n, a = zt(n, ["id", "className", "children"]); return A.createElement("svg", Ot({ ref: t, className: `tl-positioned-svg ${i}` }, a), A.createElement("g", { id: r, className: "tl-centered-g" }, o)) }))), vn = A.memo((function ({ bounds: e, isLocked: t, isHidden: n }) { return A.createElement("rect", { className: ["tl-bounds-center", t ? "tl-dashed" : ""].join(" "), x: -1, y: -1, width: e.width + 2, height: e.height + 2, opacity: n ? 0 : 1, pointerEvents: "none", "aria-label": "center handle" }) })), yn = { right: 0, bottomRight: 45, bottom: 90, bottomLeft: 135, left: 180, topLeft: 225, top: 270, topRight: 315 }, bn = A.memo((function ({ bounds: e, side: t, targetSize: n, size: r }) { let i = 2 * n, o = { left: -i, topLeft: -i, bottomLeft: -i, right: e.width, topRight: e.width, bottomRight: e.width, top: e.width / 2 - i / 2, bottom: e.width / 2 - i / 2 }[t], a = { left: e.height / 2 - i / 2, right: e.height / 2 - i / 2, top: 2 * -i, topLeft: -i, topRight: -i, bottom: e.height, bottomLeft: e.height, bottomRight: e.height }[t], { callbacks: s, inputs: l } = jt(), c = A.useCallback((e => { var n; e.stopPropagation(); let r = l.pointerDown(e, t); null == (n = s.onShapeClone) || n.call(s, r, e) }), [s.onShapeClone]); return A.createElement("g", { className: "tl-clone-target", transform: `translate(${o}, ${a})`, "aria-label": "clone button" }, A.createElement("rect", { className: "tl-transparent", width: 2 * n, height: 2 * n }), A.createElement("g", { className: "tl-clone-button-target", onPointerDown: c, transform: `translate(${n}, ${n}) rotate(${yn[t]})` }, A.createElement("circle", { className: "tl-transparent ", r: n }), A.createElement("path", { className: "tl-clone-button", d: `M -${r / 2},-${r / 2} L ${r / 2},0 -${r / 2},${r / 2} Z`, strokeLinejoin: "round" }))) })), wn = A.memo((function ({ targetSize: e, size: t, bounds: n }) { return A.createElement(A.Fragment, null, A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "top" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "right" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "bottom" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "left" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "topLeft" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "topRight" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "bottomLeft" }), A.createElement(bn, { targetSize: e, size: t, bounds: n, side: "bottomRight" })) })), En = { top_left_corner: "tl-cursor-nwse", top_right_corner: "tl-cursor-nesw", bottom_right_corner: "tl-cursor-nwse", bottom_left_corner: "tl-cursor-nesw" }, Cn = A.memo((function ({ size: e, targetSize: t, isHidden: n, corner: r, bounds: i }) { let o = rn(r), a = "top_left_corner" === r || "top_right_corner" === r, s = "top_left_corner" === r || "bottom_left_corner" === r; return A.createElement("g", { opacity: n ? 0 : 1 }, A.createElement("rect", Ot({ className: "tl-transparent " + (n ? "" : En[r]), "aria-label": "corner transparent", x: (s ? -1 : i.width + 1) - t, y: (a ? -1 : i.height + 1) - t, width: 2 * t, height: 2 * t, pointerEvents: n ? "none" : "all" }, o)), A.createElement("rect", { className: "tl-corner-handle", "aria-label": "corner handle", x: (s ? -1 : i.width + 1) - e / 2, y: (a ? -1 : i.height + 1) - e / 2, width: e, height: e, pointerEvents: "none" })) })), Sn = { top_edge: "tl-cursor-ns", right_edge: "tl-cursor-ew", bottom_edge: "tl-cursor-ns", left_edge: "tl-cursor-ew" }, kn = A.memo((function ({ size: e, isHidden: t, bounds: n, edge: r }) { let i = rn(r), o = "top_edge" === r || "bottom_edge" === r, a = "right_edge" === r || "bottom_edge" === r, { height: s, width: l } = n; return A.createElement("rect", Ot({ pointerEvents: t ? "none" : "all", className: "tl-transparent tl-edge-handle " + (t ? "" : Sn[r]), "aria-label": `${r} handle`, opacity: t ? 0 : 1, x: o ? e / 2 : (a ? l + 1 : -1) - e / 2, y: o ? (a ? s + 1 : -1) - e / 2 : e / 2, width: o ? Math.max(0, l + 1 - e) : e, height: o ? e : Math.max(0, s + 1 - e) }, i)) })), xn = A.memo((function ({ size: e, bounds: t, isHidden: n }) { let r = rn("left"), i = rn("center"), o = rn("right"); return A.createElement("g", { cursor: "grab", transform: `translate(${t.width / 2 - 4 * e}, ${t.height + 2 * e})`, "aria-label": "link handle" }, A.createElement("g", { className: "tl-transparent", pointerEvents: n ? "none" : "all" }, A.createElement("rect", Ot({ x: 0, y: 0, width: 2 * e, height: 2 * e }, r)), A.createElement("rect", Ot({ x: 3 * e, y: 0, width: 2 * e, height: 2 * e }, i)), A.createElement("rect", Ot({ x: 6 * e, y: 0, width: 2 * e, height: 2 * e }, o))), A.createElement("g", { className: "tl-rotate-handle", transform: `translate(${e / 2}, ${e / 2})`, "aria-label": "link rotate handle" }, A.createElement("path", { d: `M 0,${e / 2} L ${e},${e} ${e},0 Z`, pointerEvents: "none", opacity: n ? 0 : 1 }), A.createElement("path", { transform: `translate(${3 * e}, 0)`, d: `M 0,0 L ${e},0 ${e / 2},${e} Z`, pointerEvents: "none", opacity: n ? 0 : 1 }), A.createElement("path", { transform: `translate(${6 * e}, 0)`, d: `M ${e},${e / 2} L 0,0 0,${e} Z`, pointerEvents: "none", opacity: n ? 0 : 1 }))) })), An = A.memo((function ({ bounds: e, targetSize: t, size: n, isHidden: r }) { let i = rn("rotate"); return A.createElement("g", { cursor: "grab", opacity: r ? 0 : 1 }, A.createElement("circle", Ot({ className: "tl-transparent", "aria-label": "rotate handle transparent", cx: e.width / 2, cy: -2 * n, r: t, pointerEvents: r ? "none" : "all" }, i)), A.createElement("circle", { className: "tl-rotate-handle", "aria-label": "rotate handle", cx: e.width / 2, cy: -2 * n, r: n / 2, pointerEvents: "none" })) })), In = A.memo((function ({ zoom: e, bounds: t, viewportWidth: n, rotation: r, isHidden: i, isLocked: o, hideCloneHandles: a, hideResizeHandles: s, hideRotateHandle: l, hideBindingHandles: c }) { let u = (n < 768 ? 16 : 8) / e, d = 8 / e, p = Math.min(t.width, t.height) * e, h = !l && !i && !o && p > 32, f = !i && !o && p > 24, m = !i && !o && p > 20, g = !a && p > 24; return A.createElement(ln, { bounds: t, rotation: r }, A.createElement(gn, null, A.createElement(vn, { bounds: t, isLocked: o, isHidden: i }), s || o ? null : A.createElement(A.Fragment, null, A.createElement(kn, { targetSize: u, size: d, bounds: t, edge: "top_edge", isHidden: !f }), A.createElement(kn, { targetSize: u, size: d, bounds: t, edge: "right_edge", isHidden: !f }), A.createElement(kn, { targetSize: u, size: d, bounds: t, edge: "bottom_edge", isHidden: !f }), A.createElement(kn, { targetSize: u, size: d, bounds: t, edge: "left_edge", isHidden: !f }), A.createElement(Cn, { targetSize: u, size: d, bounds: t, isHidden: i || !m, corner: "top_left_corner" }), A.createElement(Cn, { targetSize: u, size: d, bounds: t, isHidden: i || !m, corner: "top_right_corner" }), A.createElement(Cn, { targetSize: u, size: d, bounds: t, isHidden: i || !m, corner: "bottom_right_corner" }), A.createElement(Cn, { targetSize: u, size: d, bounds: t, isHidden: i || !m, corner: "bottom_left_corner" })), h && A.createElement(An, { targetSize: u, size: d, bounds: t, isHidden: !f }), g && A.createElement(wn, { bounds: t, targetSize: u, size: d }), !c && A.createElement(xn, { targetSize: u, size: d, bounds: t, isHidden: !f }))) })), Pn = A.memo((function ({ bounds: e, rotation: t, isHidden: n }) { let r = function () { let { callbacks: e, inputs: t } = jt(); return A.useMemo((() => ({ onPointerDown: n => { var r, i, o, a; if (n.dead || (n.dead = !0, !t.pointerIsValid(n))) return; if (2 === n.button) return void (null == (r = e.onRightPointBounds) || r.call(e, t.pointerDown(n, "bounds"), n)); let s = t.pointerDown(n, "bounds"); null == (i = n.currentTarget) || i.setPointerCapture(n.pointerId), 0 === n.button && (null == (o = e.onPointBounds) || o.call(e, s, n)), null == (a = e.onPointerDown) || a.call(e, s, n) }, onPointerUp: n => { var r, i, o, a; if (n.dead || (n.dead = !0, 2 === n.button) || (t.activePointer = void 0, !t.pointerIsValid(n))) return; let s = t.isDoubleClick(), l = t.pointerUp(n, "bounds"); n.currentTarget.hasPointerCapture(n.pointerId) && (null == (r = n.currentTarget) || r.releasePointerCapture(n.pointerId)), 0 === n.button && (s && !(l.altKey || l.metaKey) && (null == (i = e.onDoubleClickBounds) || i.call(e, l, n)), null == (o = e.onReleaseBounds) || o.call(e, l, n)), null == (a = e.onPointerUp) || a.call(e, l, n) }, onPointerMove: n => { var r, i; if (n.dead || (n.dead = !0, !t.pointerIsValid(n))) return; 1 === n.buttons && n.currentTarget.hasPointerCapture(n.pointerId) && (null == (r = e.onDragBounds) || r.call(e, t.pointerMove(n, "bounds"), n)); let o = t.pointerMove(n, "bounds"); null == (i = e.onPointerMove) || i.call(e, o, n) }, onPointerEnter: n => { var r; !t.pointerIsValid(n) || null == (r = e.onHoverBounds) || r.call(e, t.pointerEnter(n, "bounds"), n) }, onPointerLeave: n => { var r; !t.pointerIsValid(n) || null == (r = e.onUnhoverBounds) || r.call(e, t.pointerEnter(n, "bounds"), n) } })), [t, e]) }(); return A.createElement(ln, { bounds: e, rotation: t }, A.createElement(gn, null, A.createElement("rect", Ot({ className: "tl-bounds-bg", "aria-label": "bounds bg", width: e.width, height: e.height, opacity: n ? 0 : 1 }, r)))) })), Mn = A.memo((function ({ id: e, point: t }) { let n = function (e) { let { inputs: t, callbacks: n } = jt(); return A.useMemo((() => ({ onPointerDown: r => { var i, o, a; if (r.dead || (r.dead = !0, !t.pointerIsValid(r)) || 2 === r.button) return; null == (i = r.currentTarget) || i.setPointerCapture(r.pointerId); let s = t.pointerDown(r, e); 0 === r.button && (null == (o = n.onPointHandle) || o.call(n, s, r)), null == (a = n.onPointerDown) || a.call(n, s, r) }, onPointerUp: r => { var i, o, a, s; if (r.dead || (r.dead = !0, !t.pointerIsValid(r)) || 2 === r.button) return; let l = t.isDoubleClick(), c = t.pointerUp(r, e); r.currentTarget.hasPointerCapture(r.pointerId) && (null == (i = r.currentTarget) || i.releasePointerCapture(r.pointerId), 0 === r.button && (l && !(c.altKey || c.metaKey) && (null == (o = n.onDoubleClickHandle) || o.call(n, c, r)), null == (a = n.onReleaseHandle) || a.call(n, c, r))), null == (s = n.onPointerUp) || s.call(n, c, r) }, onPointerMove: r => { var i, o; if (r.dead || (r.dead = !0, !t.pointerIsValid(r)) || 2 === r.buttons) return; let a = t.pointerMove(r, e); 1 === r.buttons && r.currentTarget.hasPointerCapture(r.pointerId) && (null == (i = n.onDragHandle) || i.call(n, a, r)), null == (o = n.onPointerMove) || o.call(n, a, r) }, onPointerEnter: r => { var i; if (!t.pointerIsValid(r)) return; let o = t.pointerEnter(r, e); null == (i = n.onHoverHandle) || i.call(n, o, r) }, onPointerLeave: r => { var i; if (!t.pointerIsValid(r)) return; let o = t.pointerEnter(r, e); null == (i = n.onUnhoverHandle) || i.call(n, o, r) } })), [t, n, e]) }(e); return A.createElement(ln, { bounds: _t.translateBounds({ minX: 0, minY: 0, maxX: 0, maxY: 0, width: 0, height: 0 }, t) }, A.createElement(gn, null, A.createElement("g", Ot({ className: "tl-handle", "aria-label": "handle" }, n), A.createElement("circle", { className: "tl-handle-bg", pointerEvents: "all" }), A.createElement("circle", { className: "tl-counter-scaled tl-handle", pointerEvents: "none", r: 4 })))) })), Tn = A.memo((function ({ shape: e, zoom: t }) { if (void 0 === e.handles) return null; let n = null, r = Object.values(e.handles).reduce(((r, i) => { let o = R.add(i.point, e.point); return (!n || R.dist(o, n) * t >= 32) && (r.push(i), n = o), r }), []); return 1 === r.length ? null : A.createElement(A.Fragment, null, r.map((t => A.createElement(Mn, { key: e.id + "_" + t.id, id: t.id, point: R.add(t.point, e.point) })))) })), Rn = A.memo((function (e) { let t = e.utils.getRef(e.shape); return A.createElement(e.utils.Component, Ot({ ref: t }, e)) }), ((e, t) => e.isHovered === t.isHovered && e.isSelected === t.isSelected && e.isEditing === t.isEditing && e.isBinding === t.isBinding && e.isGhost === t.isGhost && e.meta === t.meta && (t.shape === e.shape || !t.utils.shouldRender(t.shape, e.shape)))), Bn = A.memo((function (e) { var t = e, { shape: n, utils: r, meta: i } = t, o = zt(t, ["shape", "utils", "meta"]); let { callbacks: a } = jt(), s = r.getBounds(n), l = function (e) { let { rPageState: t, rSelectionBounds: n, callbacks: r, inputs: i } = A.useContext(Nt); return A.useMemo((() => ({ onPointerDown: o => { var a, s, l, c, u, d, p; if (o.dead || (o.dead = !0, !i.pointerIsValid(o))) return; if (2 === o.button) return void (null == (a = r.onRightPointShape) || a.call(r, i.pointerDown(o, e), o)); let h = i.pointerDown(o, e); if (null == (s = o.currentTarget) || s.setPointerCapture(o.pointerId), n.current && Zt.pointInBounds(h.point, n.current) && !t.current.selectedIds.includes(e)) return 0 === o.button && (null == (l = r.onPointBounds) || l.call(r, i.pointerDown(o, "bounds"), o), null == (c = r.onPointShape) || c.call(r, h, o)), void (null == (u = r.onPointerDown) || u.call(r, h, o)); 0 === o.button && (null == (d = r.onPointShape) || d.call(r, h, o)), null == (p = r.onPointerDown) || p.call(r, h, o) }, onPointerUp: t => { var n, o, a, s; if (t.dead || (t.dead = !0, !i.pointerIsValid(t)) || 2 === t.button) return; i.activePointer = void 0; let l = i.isDoubleClick(), c = i.pointerUp(t, e); t.pointerId && t.currentTarget.hasPointerCapture(t.pointerId) && (null == (n = t.currentTarget) || n.releasePointerCapture(t.pointerId)), 0 === t.button && (l && !(c.altKey || c.metaKey) && (null == (o = r.onDoubleClickShape) || o.call(r, c, t)), null == (a = r.onReleaseShape) || a.call(r, c, t)), null == (s = r.onPointerUp) || s.call(r, c, t) }, onPointerMove: t => { var n, o; if (t.dead || (t.dead = !0, 2 === t.buttons || !i.pointerIsValid(t) || i.pointer && t.pointerId !== i.pointer.pointerId)) return; let a = i.pointerMove(t, e); 1 === t.buttons && t.currentTarget.hasPointerCapture(t.pointerId) && (null == (n = r.onDragShape) || n.call(r, a, t)), null == (o = r.onPointerMove) || o.call(r, a, t) }, onPointerEnter: t => { var n; if (!i.pointerIsValid(t)) return; let o = i.pointerEnter(t, e); null == (n = r.onHoverShape) || n.call(r, o, t) }, onPointerLeave: t => { var n; if (!i.pointerIsValid(t)) return; let o = i.pointerEnter(t, e); null == (n = r.onUnhoverShape) || n.call(r, o, t) } })), [i, r, e]) }(n.id); return A.createElement(ln, { id: n.id, bounds: s, rotation: n.rotation, "data-shape": n.type, isGhost: o.isGhost, isSelected: o.isSelected }, A.createElement(Rn, Ot({ shape: n, utils: r, meta: i, events: l, bounds: s, onShapeChange: a.onShapeChange, onShapeBlur: a.onShapeBlur }, o))) })), Dn = A.memo((function (e) { var t = e, { shape: n, utils: r, meta: i, children: o } = t, a = zt(t, ["shape", "utils", "meta", "children"]); return A.createElement(A.Fragment, null, A.createElement(Bn, Ot({ shape: n, utils: r[n.type], meta: i }, a)), o && o.map((e => A.createElement(Dn, Ot({ key: e.shape.id, utils: r }, e))))) })), Ln = A.memo((function ({ isHovered: e = !1, isSelected: t = !1, isEditing: n = !1, shape: r, user: i, meta: o }) { let { shapeUtils: a } = jt(), s = a[r.type], l = s.getBounds(r), c = sn(l, r.rotation); return A.createElement("div", { ref: c, draggable: !1, className: ["tl-indicator", "tl-absolute", t && !i ? "tl-selected" : "tl-hovered", n ? "tl-editing" : "", r.isLocked ? "tl-locked" : ""].join(" ") }, A.createElement("svg", { width: "100%", height: "100%" }, A.createElement("g", { className: "tl-centered-g", stroke: null == i ? void 0 : i.color }, A.createElement(s.Indicator, { shape: r, meta: o, user: i, bounds: l, isSelected: t, isHovered: e })))) })), On = A.memo((function ({ page: e, pageState: t, assets: n, hideBounds: r, hideHandles: i, hideIndicators: o, hideBindingHandles: a, hideCloneHandles: s, hideRotateHandle: l, hideResizeHandles: c, meta: u }) { let d, { bounds: p, shapeUtils: h } = jt(), f = Jt(e, t, n, u), { bounds: m, isLinked: g, isLocked: v, rotation: y } = function (e, t, n) { let r, { rSelectionBounds: i } = jt(), { selectedIds: o } = t, a = A.useRef(), s = 0, l = !1, c = !1; if (1 === o.length) { let t = o[0], i = e.shapes[t]; if (!i) throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${t}`); s = i.rotation || 0, l = i.isLocked || !1; let a = an(n, i); r = a.hideBounds ? void 0 : a.getBounds(i) } else if (o.length > 1) { let t = o.map((t => e.shapes[t])); s = 0, l = t.every((e => e.isLocked)), r = t.reduce(((e, t, r) => 0 === r ? an(n, t).getRotatedBounds(t) : _t.getExpandedBounds(e, an(n, t).getRotatedBounds(t))), {}) } if (r) { let [n, a] = on([r.minX, r.minY], t.camera), [s, l] = on([r.maxX, r.maxY], t.camera); c = !!Object.values(e.bindings).find((e => o.includes(e.toId) || o.includes(e.fromId))), i.current = { minX: n, minY: a, maxX: s, maxY: l, width: s - n, height: l - a } } else i.current = null; let u = a.current; return u && r ? r && u.minX === r.minX && u.minY === r.minY && u.maxX === r.maxX && u.maxY === r.maxY && (r = a.current) : a.current = r, { bounds: r, rotation: s, isLocked: l, isLinked: c } }(e, t, h), { selectedIds: b, hoveredId: w, editingId: E, camera: { zoom: C } } = t, S = o, k = !0, x = !1, I = b.map((t => e.shapes[t])); if (1 === I.length) { let e = I[0]; x = E === e.id, x && (S = !0); let t = h[e.type]; k = s || !t.showCloneHandles, void 0 !== e.handles && !x && (d = e) } return A.createElement(A.Fragment, null, m && A.createElement(Pn, { bounds: m, rotation: y, isHidden: r }), f.map((e => A.createElement(Dn, Ot({ key: e.shape.id, utils: h }, e)))), !S && I.map((e => A.createElement(Ln, { key: "selected_" + e.id, shape: e, meta: u, isSelected: !0, isEditing: x }))), !S && w && w !== E && A.createElement(Ln, { key: "hovered_" + w, shape: e.shapes[w], meta: u, isHovered: !0 }), m && A.createElement(In, { zoom: C, bounds: m, viewportWidth: p.width, isLocked: v, rotation: y, isHidden: r, hideRotateHandle: l, hideResizeHandles: c, hideBindingHandles: a || !g, hideCloneHandles: k }), !i && d && A.createElement(Tn, { shape: d, zoom: C })) })), Fn = A.memo((function ({ snapLine: e }) { let t = _t.getBoundsFromPoints(e); return A.createElement(A.Fragment, null, A.createElement("line", { className: "tl-snap-line", x1: t.minX, y1: t.minY, x2: t.maxX, y2: t.maxY }), e.map((([e, t], n) => A.createElement("use", { key: n, href: "#tl-snap-point", x: e, y: t })))) })), zn = A.memo((function ({ snapLines: e }) { return A.createElement(A.Fragment, null, e.map(((e, t) => A.createElement(Fn, { key: t, snapLine: e })))) })); function Hn({ user: e, Cursor: t }) { let n = A.useRef(null); return A.useLayoutEffect((() => { n.current && (n.current.style.transform = `translate(${e.point[0]}px, ${e.point[1]}px)`) }), [e.point]), A.createElement("div", { ref: n, className: "tl-absolute tl-user tl-counter-scaled " + (e.session ? "" : "tl-animated") }, A.createElement(t, { id: e.id, color: e.color, metadata: e.metadata })) } function Nn({ userId: e, users: t, Cursor: n }) { return A.createElement(A.Fragment, null, Object.values(t).filter((t => t && t.id !== e)).map((e => A.createElement(Hn, { key: e.id, user: e, Cursor: n })))) } function jn({ userId: e, users: t, meta: n, page: r }) { let { shapeUtils: i } = jt(); return A.createElement(A.Fragment, null, Object.values(t).filter(Boolean).filter((t => t.id !== e && t.selectedIds.length > 0)).map((e => { let t = e.selectedIds.map((e => r.shapes[e])).filter(Boolean); if (0 === t.length) return null; let o = _t.getCommonBounds(t.map((e => i[e.type].getBounds(e)))); return A.createElement(A.Fragment, { key: e.id + "_shapes" }, A.createElement("div", { className: "tl-absolute tl-user-indicator-bounds", style: { backgroundColor: e.color + "0d", borderColor: e.color + "78", transform: `translate(${o.minX}px, ${o.minY}px)`, width: o.width, height: o.height, pointerEvents: "none" } }), t.map((t => A.createElement(Ln, { key: `${e.id}_${t.id}_indicator`, shape: t, user: e, meta: n, isHovered: !0 })))) }))) } var Un = A.memo((function ({ id: e, page: t, pageState: n, assets: r, snapLines: i, eraseLine: o, grid: a, users: s, userId: l, components: c = {}, meta: u, performanceMode: d, showDashedBrush: p, hideHandles: h, hideBounds: f, hideIndicators: m, hideBindingHandles: g, hideCloneHandles: v, hideResizeHandles: y, hideRotateHandle: b, hideGrid: w, onBoundsChange: E, hideCursors: C }) { var S; let k = A.useRef(null), x = A.useRef(n.camera.zoom); x.current = n.camera.zoom, function (e, t) { let n = A.useRef(void 0), r = A.useRef(void 0), i = A.useRef([0, 0]), o = A.useRef(0), { inputs: a, bounds: s, callbacks: l } = jt(); A.useEffect((() => { let e = e => e.preventDefault(); return document.addEventListener("gesturestart", e), document.addEventListener("gesturechange", e), () => { document.removeEventListener("gesturestart", e), document.removeEventListener("gesturechange", e) } }), []); let c = A.useCallback((({ event: e }) => { var t, n, r, i; if (e.preventDefault(), a.isPinching || e.timeStamp <= o.current) return; o.current = e.timeStamp; let [c, u, d] = function (e) { let { deltaY: t, deltaX: n } = e, r = 0; if (e.ctrlKey || e.metaKey) { let n = Math.sign(e.deltaY), i = t; Math.abs(e.deltaY) > Qt && (i = Qt * n), r = i } return [n, t, r] }(e); if ((e.altKey || e.ctrlKey || e.metaKey) && 0 === e.buttons) { let i = [...null != (n = null == (t = a.pointer) ? void 0 : t.point) ? n : [s.width / 2, s.height / 2], .618 * d], o = a.pan(i, e); return void (null == (r = l.onZoom) || r.call(l, Ft(Ot({}, o), { delta: i }), e)) } let p = R.mul(e.shiftKey && !_t.isDarwin() ? [u, 0] : [c, u], .5); if (R.isEqual(p, [0, 0])) return; let h = a.pan(p, e); null == (i = l.onPan) || i.call(l, h, e) }), [l, a, s]), u = A.useCallback((({ origin: e, event: o }) => { var s; if (o instanceof WheelEvent) return; let c = t.current; if (!c || o.target !== c && !c.contains(o.target)) return; let u = a.pinch(e, e); a.isPinching = !0, null == (s = l.onPinchStart) || s.call(l, u, o), r.current = u.point, n.current = u.origin, i.current = [0, 0] }), [l, a, s]), d = A.useCallback((({ origin: e, offset: o, event: s }) => { var c; if (s instanceof WheelEvent) return; let u = t.current; if (s.target !== u && !(null == u ? void 0 : u.contains(s.target)) || !n.current) return; let d = a.pinch(e, n.current), p = R.sub(d.delta, i.current); i.current = d.delta, null == (c = l.onPinch) || c.call(l, Ft(Ot({}, d), { point: d.point, origin: n.current, delta: [...p, o[0]] }), s), r.current = e }), [l, a, s]), p = A.useCallback((({ origin: e, event: o }) => { var s; let c = t.current; if (o.target !== c && !(null == c ? void 0 : c.contains(o.target))) return; let u = a.pinch(e, e); a.isPinching = !1, null == (s = l.onPinchEnd) || s.call(l, u, o), r.current = void 0, n.current = void 0, i.current = [0, 0] }), []); He({ onWheel: c, onPinchStart: u, onPinch: d, onPinchEnd: p }, { target: t, eventOptions: { passive: !1 }, pinch: { from: [e.current, 0], scaleBounds: () => ({ from: e.current, max: 5, min: .1 }) } }) }(x, k), function (e, t) { let { inputs: n, callbacks: r } = jt(), i = A.useRef(!1), o = A.useCallback((() => { var o, a; if (i.current) { let i = null == (o = e.current) ? void 0 : o.getBoundingClientRect(); if (i) { let e = { minX: i.left, maxX: i.left + i.width, minY: i.top, maxY: i.top + i.height, width: i.width, height: i.height }; n.bounds = e, t(e), null == (a = r.onBoundsChange) || a.call(r, e) } } else i.current = !0 }), [e, n, r.onBoundsChange]); A.useEffect((() => { let t = e.current ? (e => { let t = e.parentElement; for (; t;) { if (t === document.body) return document; let { overflowY: e } = window.getComputedStyle(t); if (t.scrollHeight > t.clientHeight && ("auto" === e || "scroll" === e || "overlay" === e)) return t; t = t.parentElement } return document })(e.current) : document, n = Zt.debounce(o, 100); return t.addEventListener("scroll", n), window.addEventListener("resize", n), () => { t.removeEventListener("scroll", n), window.removeEventListener("resize", n) } }), []), A.useEffect((() => { let t = new ResizeObserver((e => { n.isPinching || e[0].contentRect && o() })); return e.current && t.observe(e.current), () => { t.disconnect() } }), [e, n]), A.useEffect((() => { o() }), [e]) }(k, E), function () { let { callbacks: e } = jt(); (0, A.useEffect)((() => { function t() { var t; null == (t = e.onShapeBlur) || t.call(e) } return _t.isMobileSafari() ? (document.addEventListener("focusout", t), () => document.removeEventListener("focusout", t)) : () => null }), [e]) }(), function (e) { let { bounds: t } = jt(); A.useEffect((() => { let n = e => { e.preventDefault() }, r = e => { let n = e.touches[0].pageX, r = e.touches[0].radiusX || 0; (n - r < 10 || n + r > t.width - 10) && e.preventDefault() }, i = e.current; return i ? (i.addEventListener("gestureend", n), i.addEventListener("gesturechange", n), i.addEventListener("gesturestart", n), i.addEventListener("touchstart", r), () => { i && (i.removeEventListener("gestureend", n), i.removeEventListener("gesturechange", n), i.removeEventListener("gesturestart", n), i.removeEventListener("touchstart", r)) }) : () => { } }), [e, t.width]) }(k); let I = A.useRef(null), P = A.useRef(null); (function (e, t, n) { let r = A.useRef(), i = A.useRef(); A.useLayoutEffect((() => { let { zoom: o, point: a } = n.camera, s = o !== r.current, l = a !== i.current; if (r.current = o, i.current = a, s || l) { let n = e.current; if (t && "current" in t) { let e = t.current; s && e && e.style.setProperty("--tl-zoom", o.toString()), n && n.style.setProperty("transform", `scale(${o}) translateX(${a[0]}px) translateY(${a[1]}px)`) } } }), [n.camera.zoom, n.camera.point]) })(P, I, n), function (e, t) { A.useLayoutEffect((() => { if (t && "current" in t) { let n = null == t ? void 0 : t.current; if (!n) return; switch (e) { case "transform_selected": n.style.setProperty("--tl-performance-all", "auto"), n.style.setProperty("--tl-performance-selected", "transform, contents"); break; case "transform_all": n.style.setProperty("--tl-performance-all", "transform, contents"), n.style.setProperty("--tl-performance-selected", "transform, contents"); break; case "translate_selected": n.style.setProperty("--tl-performance-all", "auto"), n.style.setProperty("--tl-performance-selected", "transform"); break; case "translate_all": n.style.setProperty("--tl-performance-all", "transform"), n.style.setProperty("--tl-performance-selected", "transform"); break; default: n.style.setProperty("--tl-performance-all", "auto"), n.style.setProperty("--tl-performance-selected", "auto") } } }), [e]) }(d, I), function () { let { inputs: e, callbacks: t } = jt(); A.useEffect((() => { let n = n => { var r; null == (r = t.onKeyDown) || r.call(t, n.key, e.keydown(n), n) }, r = n => { var r; e.keyup(n), null == (r = t.onKeyUp) || r.call(t, n.key, e.keyup(n), n) }; return window.addEventListener("keydown", n), window.addEventListener("keyup", r), () => { window.removeEventListener("keydown", n), window.removeEventListener("keyup", r) } }), [e, t]) }(); let M = function () { let { callbacks: e, inputs: t } = jt(); return A.useMemo((() => ({ onPointerDown: n => { var r, i, o; if (n.dead || (n.dead = !0, !t.pointerIsValid(n))) return; if (n.currentTarget.setPointerCapture(n.pointerId), 2 === n.button) return void (null == (r = e.onRightPointCanvas) || r.call(e, t.pointerDown(n, "canvas"), n)); let a = t.pointerDown(n, "canvas"); 0 === n.button && (null == (i = e.onPointCanvas) || i.call(e, a, n)), null == (o = e.onPointerDown) || o.call(e, a, n) }, onPointerMove: n => { var r, i; if (n.dead || (n.dead = !0, !t.pointerIsValid(n))) return; let o = t.pointerMove(n, "canvas"); 1 === n.buttons && n.currentTarget.hasPointerCapture(n.pointerId) && (null == (r = e.onDragCanvas) || r.call(e, o, n)), null == (i = e.onPointerMove) || i.call(e, o, n) }, onPointerUp: n => { var r, i, o, a, s; if (n.dead || (n.dead = !0, t.activePointer = void 0, !t.pointerIsValid(n))) return; let l = t.isDoubleClick(), c = t.pointerUp(n, "canvas"); 2 !== n.button ? (n.currentTarget.hasPointerCapture(n.pointerId) && (null == (i = n.currentTarget) || i.releasePointerCapture(n.pointerId)), 0 === n.button && (l && !(c.altKey || c.metaKey) && (null == (o = e.onDoubleClickCanvas) || o.call(e, c, n)), null == (a = e.onReleaseCanvas) || a.call(e, c, n)), null == (s = e.onPointerUp) || s.call(e, c, n)) : null == (r = e.onPointerUp) || r.call(e, c, n) }, onDrop: e.onDrop, onDragOver: e.onDragOver })), [e, t]) }(); return A.createElement("div", { id: e, className: "tl-container", ref: I }, A.createElement("div", Ot({ id: "canvas", className: "tl-absolute tl-canvas", ref: k }, M), !w && a && A.createElement(fn, { grid: a, camera: n.camera }), A.createElement("div", { ref: P, className: "tl-absolute tl-layer", "data-testid": "layer" }, A.createElement(On, { page: t, pageState: n, assets: r, hideBounds: f, hideIndicators: m, hideHandles: h, hideBindingHandles: g, hideCloneHandles: v, hideResizeHandles: y, hideRotateHandle: b, meta: u }), s && l && A.createElement(jn, { userId: l, users: s, page: t, meta: u }), n.brush && A.createElement(cn, { brush: n.brush, dashed: p, zoom: n.camera.zoom }), s && !C && A.createElement(Nn, { userId: l, users: s, Cursor: null != (S = null == c ? void 0 : c.Cursor) ? S : dn })), A.createElement(mn, { camera: n.camera }, o && A.createElement(pn, { points: o, zoom: n.camera.zoom }), i && A.createElement(zn, { snapLines: i })))) })), Vn = class { constructor() { Ht(this, "pointer"), Ht(this, "keyboard"), Ht(this, "keys", {}), Ht(this, "isPinching", !1), Ht(this, "bounds", { minX: 0, maxX: 640, minY: 0, maxY: 480, width: 640, height: 480 }), Ht(this, "pointerUpTime", 0), Ht(this, "activePointer"), Ht(this, "panStart", (e => { var t, n; let { shiftKey: r, ctrlKey: i, metaKey: o, altKey: a } = e, s = { target: "wheel", pointerId: (null == (t = this.pointer) ? void 0 : t.pointerId) || 0, origin: (null == (n = this.pointer) ? void 0 : n.origin) || [0, 0], delta: [0, 0], pressure: .5, point: Vn.getPoint(e, this.bounds), shiftKey: r, ctrlKey: i, metaKey: o, altKey: a, spaceKey: this.keys[" "] }; return this.pointer = s, s })), Ht(this, "pan", ((e, t) => { if (!this.pointer || "wheel" !== this.pointer.target) return this.panStart(t); let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = t, a = this.pointer, s = Vn.getPoint(t, this.bounds), l = Ft(Ot({}, a), { target: "wheel", delta: e, point: s, shiftKey: n, ctrlKey: r, metaKey: i, altKey: o, spaceKey: this.keys[" "] }); return this.pointer = l, l })), Ht(this, "keydown", (e => { var t, n; let { shiftKey: r, ctrlKey: i, metaKey: o, altKey: a } = e; return this.keys[e.key] = !0, { point: (null == (t = this.pointer) ? void 0 : t.point) || [0, 0], origin: (null == (n = this.pointer) ? void 0 : n.origin) || [0, 0], key: e.key, keys: Object.keys(this.keys), shiftKey: r, ctrlKey: i, metaKey: Zt.isDarwin() ? o : i, altKey: a } })), Ht(this, "keyup", (e => { var t, n; let { shiftKey: r, ctrlKey: i, metaKey: o, altKey: a } = e; return delete this.keys[e.key], { point: (null == (t = this.pointer) ? void 0 : t.point) || [0, 0], origin: (null == (n = this.pointer) ? void 0 : n.origin) || [0, 0], key: e.key, keys: Object.keys(this.keys), shiftKey: r, ctrlKey: i, metaKey: Zt.isDarwin() ? o : i, altKey: a } })) } pointerIsValid(e) { if ("pointerId" in e && this.activePointer && this.activePointer !== e.pointerId) return !1; if ("touches" in e) { let t = e.changedTouches[0]; if (this.activePointer && this.activePointer !== t.identifier) return !1 } return !0 } touchStart(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = e.changedTouches[0]; this.activePointer = a.identifier; let s = { target: t, pointerId: a.identifier, origin: Vn.getPoint(a, this.bounds), delta: [0, 0], point: Vn.getPoint(a, this.bounds), pressure: Vn.getPressure(a), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }; return this.pointer = s, s } touchEnd(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = e.changedTouches[0], s = { target: t, pointerId: a.identifier, origin: Vn.getPoint(a, this.bounds), delta: [0, 0], point: Vn.getPoint(a, this.bounds), pressure: Vn.getPressure(a), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }; return this.pointer = s, this.activePointer = void 0, s } touchMove(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = e.changedTouches[0], s = this.pointer, l = Vn.getPoint(a, this.bounds), c = (null == s ? void 0 : s.point) ? R.sub(l, s.point) : [0, 0], u = Ft(Ot({ origin: l }, s), { target: t, pointerId: a.identifier, point: l, delta: c, pressure: Vn.getPressure(a), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }); return this.pointer = u, u } pointerDown(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = Vn.getPoint(e, this.bounds); this.activePointer = e.pointerId; let s = { target: t, pointerId: e.pointerId, origin: a, point: a, delta: [0, 0], pressure: Vn.getPressure(e), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }; return this.pointer = s, s } pointerEnter(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = Vn.getPoint(e, this.bounds), s = { target: t, pointerId: e.pointerId, origin: a, delta: [0, 0], point: a, pressure: Vn.getPressure(e), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }; return this.pointer = s, s } pointerMove(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = this.pointer, s = Vn.getPoint(e, this.bounds), l = (null == a ? void 0 : a.point) ? R.sub(s, a.point) : [0, 0], c = Ft(Ot({ origin: s }, a), { target: t, pointerId: e.pointerId, point: s, delta: l, pressure: Vn.getPressure(e), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }); return this.pointer = c, c } pointerUp(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = e, a = this.pointer, s = Vn.getPoint(e, this.bounds), l = (null == a ? void 0 : a.point) ? R.sub(s, a.point) : [0, 0]; this.activePointer = void 0; let c = Ft(Ot({ origin: s }, a), { target: t, pointerId: e.pointerId, point: s, delta: l, pressure: Vn.getPressure(e), shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }); return this.pointer = c, this.pointerUpTime = performance.now(), c } isDoubleClick() { if (!this.pointer) return !1; let { origin: e, point: t } = this.pointer, n = performance.now() - this.pointerUpTime < 250 && R.dist(e, t) < 4; return n && (this.activePointer = void 0), n } clear() { this.pointer = void 0 } resetDoubleClick() { this.pointerUpTime = 0 } pinch(e, t) { let { shiftKey: n, ctrlKey: r, metaKey: i, altKey: o } = this.keys, a = { pointerId: 0, target: "pinch", origin: t, delta: R.sub(t, e), point: R.sub(R.toFixed(e), [this.bounds.minX, this.bounds.minY]), pressure: .5, shiftKey: n, ctrlKey: r, metaKey: Zt.isDarwin() ? i : r, altKey: o, spaceKey: this.keys[" "] }; return this.pointer = a, a } reset() { this.pointerUpTime = 0, this.pointer = void 0, this.keyboard = void 0, this.activePointer = void 0, this.keys = {} } static getPoint(e, t) { return [+e.clientX.toFixed(2) - t.minX, +e.clientY.toFixed(2) - t.minY] } static getPressure(e) { return "pressure" in e && +e.pressure.toFixed(2) || .5 } static commandKey() { return Zt.isDarwin() ? "" : "Ctrl" } }, Kn = (new Vn, Object.freeze({})), Wn = A.memo((function (e) { var t = e, { id: n = "tl", shapeUtils: r, page: i, pageState: o, assets: a = Kn, users: s, userId: l, theme: c, meta: u, snapLines: d, eraseLine: p, grid: h, containerRef: f, performanceMode: m, components: g, hideHandles: v = !1, hideIndicators: y = !1, hideCloneHandles: b = !1, hideBindingHandles: w = !1, hideResizeHandles: E = !1, hideRotateHandles: C = !1, hideBounds: S = !1, hideGrid: k = !0, showDashedBrush: x = !1, hideCursors: I } = t, P = zt(t, ["id", "shapeUtils", "page", "pageState", "assets", "users", "userId", "theme", "meta", "snapLines", "eraseLine", "grid", "containerRef", "performanceMode", "components", "hideHandles", "hideIndicators", "hideCloneHandles", "hideBindingHandles", "hideResizeHandles", "hideRotateHandles", "hideBounds", "hideGrid", "showDashedBrush", "hideCursors"]); nn(c, "#" + n); let M = A.useRef(null), T = A.useRef(o); A.useEffect((() => { T.current = o }), [o]); let [R, B] = A.useState((() => ({ callbacks: P, shapeUtils: r, rSelectionBounds: M, rPageState: T, bounds: { minX: 0, minY: 0, maxX: 1 / 0, maxY: 1 / 0, width: 1 / 0, height: 1 / 0 }, inputs: new Vn }))), D = A.useCallback((e => { B((t => Ft(Ot({}, t), { bounds: e }))) }), []); return A.createElement(Nt.Provider, { value: R }, A.createElement(Un, { id: n, page: i, pageState: o, assets: a, snapLines: d, eraseLine: p, grid: h, users: s, userId: l, externalContainerRef: f, hideBounds: S, hideIndicators: y, hideHandles: v, hideCloneHandles: b, hideBindingHandles: w, hideRotateHandle: C, hideResizeHandles: E, hideGrid: k, showDashedBrush: x, onBoundsChange: D, performanceMode: m, components: g, meta: u, hideCursors: I })) })), Yn = A.memo(A.forwardRef((function (e, t) { var n = e, { children: r, className: i = "" } = n, o = zt(n, ["children", "className"]); return A.createElement("div", Ot({ ref: t, className: `tl-positioned-div ${i}`, draggable: !1 }, o), A.createElement("div", { className: "tl-inner-div" }, r)) }))), Gn = class { constructor() { Ht(this, "refMap", new Map), Ht(this, "boundsCache", new WeakMap), Ht(this, "showCloneHandles", !1), Ht(this, "hideBounds", !1), Ht(this, "isStateful", !1), Ht(this, "shouldRender", ((e, t) => !0)), Ht(this, "getRef", (e => (this.refMap.has(e.id) || this.refMap.set(e.id, A.createRef()), this.refMap.get(e.id)))), Ht(this, "hitTestBounds", ((e, t) => { let n = this.getBounds(e), r = _t.getRotatedCorners(n, e.rotation); return r.every((e => _t.pointInBounds(e, t))) || It(r, t).length > 0 })), Ht(this, "getRotatedBounds", (e => _t.getBoundsFromPoints(_t.getRotatedCorners(this.getBounds(e), e.rotation)))) } }; Ht(Gn, "Component", (e => A.forwardRef(e))), Ht(Gn, "Indicator", (e => e)); var Zn = n(5800), Xn = function (e, t) { return Xn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) }, Xn(e, t) }; function _n(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function n() { this.constructor = e } Xn(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n) } var Qn = function () { return Qn = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, Qn.apply(this, arguments) }; function qn(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var i = 0; for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]) } return n } function Jn(e, t, n) { if (n || 2 === arguments.length) for (var r, i = 0, o = t.length; i < o; i++)!r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]); return e.concat(r || Array.prototype.slice.call(t)) } Object.create, Object.create, "function" == typeof SuppressedError && SuppressedError, n(8679); var $n, er, tr, nr = "undefined" == typeof window || window.__REACT_INTL_BYPASS_GLOBAL_CONTEXT__ ? A.createContext(null) : window.__REACT_INTL_CONTEXT__ || (window.__REACT_INTL_CONTEXT__ = A.createContext(null)), rr = (nr.Consumer, nr.Provider), ir = nr; function or(e, t, n) { if (void 0 === n && (n = Error), !e) throw new n(t) } function ar(e) { return e.type === er.literal } function sr(e) { return e.type === er.argument } function lr(e) { return e.type === er.number } function cr(e) { return e.type === er.date } function ur(e) { return e.type === er.time } function dr(e) { return e.type === er.select } function pr(e) { return e.type === er.plural } function hr(e) { return e.type === er.pound } function fr(e) { return e.type === er.tag } function mr(e) { return !(!e || "object" != typeof e || e.type !== tr.number) } function gr(e) { return !(!e || "object" != typeof e || e.type !== tr.dateTime) } !function (e) { e[e.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE", e[e.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT", e[e.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT", e[e.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE", e[e.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE", e[e.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE", e[e.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON", e[e.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON", e[e.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON", e[e.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON", e[e.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE", e[e.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS", e[e.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE", e[e.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE", e[e.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR", e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR", e[e.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT", e[e.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT", e[e.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR", e[e.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR", e[e.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR", e[e.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE", e[e.INVALID_TAG = 23] = "INVALID_TAG", e[e.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME", e[e.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG", e[e.UNCLOSED_TAG = 27] = "UNCLOSED_TAG" }($n || ($n = {})), function (e) { e[e.literal = 0] = "literal", e[e.argument = 1] = "argument", e[e.number = 2] = "number", e[e.date = 3] = "date", e[e.time = 4] = "time", e[e.select = 5] = "select", e[e.plural = 6] = "plural", e[e.pound = 7] = "pound", e[e.tag = 8] = "tag" }(er || (er = {})), function (e) { e[e.number = 0] = "number", e[e.dateTime = 1] = "dateTime" }(tr || (tr = {})); var vr = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/, yr = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g; function br(e) { var t = {}; return e.replace(yr, (function (e) { var n = e.length; switch (e[0]) { case "G": t.era = 4 === n ? "long" : 5 === n ? "narrow" : "short"; break; case "y": t.year = 2 === n ? "2-digit" : "numeric"; break; case "Y": case "u": case "U": case "r": throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead"); case "q": case "Q": throw new RangeError("`q/Q` (quarter) patterns are not supported"); case "M": case "L": t.month = ["numeric", "2-digit", "short", "long", "narrow"][n - 1]; break; case "w": case "W": throw new RangeError("`w/W` (week) patterns are not supported"); case "d": t.day = ["numeric", "2-digit"][n - 1]; break; case "D": case "F": case "g": throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead"); case "E": t.weekday = 4 === n ? "short" : 5 === n ? "narrow" : "short"; break; case "e": if (n < 4) throw new RangeError("`e..eee` (weekday) patterns are not supported"); t.weekday = ["short", "long", "narrow", "short"][n - 4]; break; case "c": if (n < 4) throw new RangeError("`c..ccc` (weekday) patterns are not supported"); t.weekday = ["short", "long", "narrow", "short"][n - 4]; break; case "a": t.hour12 = !0; break; case "b": case "B": throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead"); case "h": t.hourCycle = "h12", t.hour = ["numeric", "2-digit"][n - 1]; break; case "H": t.hourCycle = "h23", t.hour = ["numeric", "2-digit"][n - 1]; break; case "K": t.hourCycle = "h11", t.hour = ["numeric", "2-digit"][n - 1]; break; case "k": t.hourCycle = "h24", t.hour = ["numeric", "2-digit"][n - 1]; break; case "j": case "J": case "C": throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead"); case "m": t.minute = ["numeric", "2-digit"][n - 1]; break; case "s": t.second = ["numeric", "2-digit"][n - 1]; break; case "S": case "A": throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead"); case "z": t.timeZoneName = n < 4 ? "short" : "long"; break; case "Z": case "O": case "v": case "V": case "X": case "x": throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead") }return "" })), t } var wr = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i, Er = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g, Cr = /^(@+)?(\+|#+)?[rs]?$/g, Sr = /(\*)(0+)|(#+)(0+)|(0+)/g, kr = /^(0+)$/; function xr(e) { var t = {}; return "r" === e[e.length - 1] ? t.roundingPriority = "morePrecision" : "s" === e[e.length - 1] && (t.roundingPriority = "lessPrecision"), e.replace(Cr, (function (e, n, r) { return "string" != typeof r ? (t.minimumSignificantDigits = n.length, t.maximumSignificantDigits = n.length) : "+" === r ? t.minimumSignificantDigits = n.length : "#" === n[0] ? t.maximumSignificantDigits = n.length : (t.minimumSignificantDigits = n.length, t.maximumSignificantDigits = n.length + ("string" == typeof r ? r.length : 0)), "" })), t } function Ar(e) { switch (e) { case "sign-auto": return { signDisplay: "auto" }; case "sign-accounting": case "()": return { currencySign: "accounting" }; case "sign-always": case "+!": return { signDisplay: "always" }; case "sign-accounting-always": case "()!": return { signDisplay: "always", currencySign: "accounting" }; case "sign-except-zero": case "+?": return { signDisplay: "exceptZero" }; case "sign-accounting-except-zero": case "()?": return { signDisplay: "exceptZero", currencySign: "accounting" }; case "sign-never": case "+_": return { signDisplay: "never" } } } function Ir(e) { var t; if ("E" === e[0] && "E" === e[1] ? (t = { notation: "engineering" }, e = e.slice(2)) : "E" === e[0] && (t = { notation: "scientific" }, e = e.slice(1)), t) { var n = e.slice(0, 2); if ("+!" === n ? (t.signDisplay = "always", e = e.slice(2)) : "+?" === n && (t.signDisplay = "exceptZero", e = e.slice(2)), !kr.test(e)) throw new Error("Malformed concise eng/scientific notation"); t.minimumIntegerDigits = e.length } return t } function Pr(e) { return Ar(e) || {} } function Mr(e) { for (var t = {}, n = 0, r = e; n < r.length; n++) { var i = r[n]; switch (i.stem) { case "percent": case "%": t.style = "percent"; continue; case "%x100": t.style = "percent", t.scale = 100; continue; case "currency": t.style = "currency", t.currency = i.options[0]; continue; case "group-off": case ",_": t.useGrouping = !1; continue; case "precision-integer": case ".": t.maximumFractionDigits = 0; continue; case "measure-unit": case "unit": t.style = "unit", t.unit = i.options[0].replace(/^(.*?)-/, ""); continue; case "compact-short": case "K": t.notation = "compact", t.compactDisplay = "short"; continue; case "compact-long": case "KK": t.notation = "compact", t.compactDisplay = "long"; continue; case "scientific": t = Qn(Qn(Qn({}, t), { notation: "scientific" }), i.options.reduce((function (e, t) { return Qn(Qn({}, e), Pr(t)) }), {})); continue; case "engineering": t = Qn(Qn(Qn({}, t), { notation: "engineering" }), i.options.reduce((function (e, t) { return Qn(Qn({}, e), Pr(t)) }), {})); continue; case "notation-simple": t.notation = "standard"; continue; case "unit-width-narrow": t.currencyDisplay = "narrowSymbol", t.unitDisplay = "narrow"; continue; case "unit-width-short": t.currencyDisplay = "code", t.unitDisplay = "short"; continue; case "unit-width-full-name": t.currencyDisplay = "name", t.unitDisplay = "long"; continue; case "unit-width-iso-code": t.currencyDisplay = "symbol"; continue; case "scale": t.scale = parseFloat(i.options[0]); continue; case "integer-width": if (i.options.length > 1) throw new RangeError("integer-width stems only accept a single optional option"); i.options[0].replace(Sr, (function (e, n, r, i, o, a) { if (n) t.minimumIntegerDigits = r.length; else { if (i && o) throw new Error("We currently do not support maximum integer digits"); if (a) throw new Error("We currently do not support exact integer digits") } return "" })); continue }if (kr.test(i.stem)) t.minimumIntegerDigits = i.stem.length; else if (Er.test(i.stem)) { if (i.options.length > 1) throw new RangeError("Fraction-precision stems only accept a single optional option"); i.stem.replace(Er, (function (e, n, r, i, o, a) { return "*" === r ? t.minimumFractionDigits = n.length : i && "#" === i[0] ? t.maximumFractionDigits = i.length : o && a ? (t.minimumFractionDigits = o.length, t.maximumFractionDigits = o.length + a.length) : (t.minimumFractionDigits = n.length, t.maximumFractionDigits = n.length), "" })); var o = i.options[0]; "w" === o ? t = Qn(Qn({}, t), { trailingZeroDisplay: "stripIfInteger" }) : o && (t = Qn(Qn({}, t), xr(o))) } else if (Cr.test(i.stem)) t = Qn(Qn({}, t), xr(i.stem)); else { var a = Ar(i.stem); a && (t = Qn(Qn({}, t), a)); var s = Ir(i.stem); s && (t = Qn(Qn({}, t), s)) } } return t } var Tr, Rr = { "001": ["H", "h"], AC: ["H", "h", "hb", "hB"], AD: ["H", "hB"], AE: ["h", "hB", "hb", "H"], AF: ["H", "hb", "hB", "h"], AG: ["h", "hb", "H", "hB"], AI: ["H", "h", "hb", "hB"], AL: ["h", "H", "hB"], AM: ["H", "hB"], AO: ["H", "hB"], AR: ["H", "h", "hB", "hb"], AS: ["h", "H"], AT: ["H", "hB"], AU: ["h", "hb", "H", "hB"], AW: ["H", "hB"], AX: ["H"], AZ: ["H", "hB", "h"], BA: ["H", "hB", "h"], BB: ["h", "hb", "H", "hB"], BD: ["h", "hB", "H"], BE: ["H", "hB"], BF: ["H", "hB"], BG: ["H", "hB", "h"], BH: ["h", "hB", "hb", "H"], BJ: ["H", "hB"], BL: ["H", "hB"], BM: ["h", "hb", "H", "hB"], BN: ["hb", "hB", "h", "H"], BO: ["H", "hB", "h", "hb"], BQ: ["H"], BR: ["H", "hB"], BS: ["h", "hb", "H", "hB"], BT: ["h", "H"], BW: ["H", "h", "hb", "hB"], BZ: ["H", "h", "hb", "hB"], CA: ["h", "hb", "H", "hB"], CC: ["H", "h", "hb", "hB"], CD: ["hB", "H"], CF: ["H", "h", "hB"], CG: ["H", "hB"], CH: ["H", "hB", "h"], CI: ["H", "hB"], CK: ["H", "h", "hb", "hB"], CL: ["H", "h", "hB", "hb"], CM: ["H", "h", "hB"], CN: ["H", "hB", "hb", "h"], CO: ["h", "H", "hB", "hb"], CP: ["H"], CR: ["H", "h", "hB", "hb"], CU: ["H", "h", "hB", "hb"], CV: ["H", "hB"], CX: ["H", "h", "hb", "hB"], CY: ["h", "H", "hb", "hB"], CZ: ["H"], DE: ["H", "hB"], DG: ["H", "h", "hb", "hB"], DJ: ["h", "H"], DK: ["H"], DM: ["h", "hb", "H", "hB"], DO: ["h", "H", "hB", "hb"], DZ: ["h", "hB", "hb", "H"], EA: ["H", "h", "hB", "hb"], EC: ["H", "hB", "h", "hb"], EE: ["H", "hB"], EG: ["h", "hB", "hb", "H"], EH: ["h", "hB", "hb", "H"], ER: ["h", "H"], ES: ["H", "hB", "h", "hb"], ET: ["hB", "hb", "h", "H"], FI: ["H"], FJ: ["h", "hb", "H", "hB"], FK: ["H", "h", "hb", "hB"], FM: ["h", "hb", "H", "hB"], FR: ["H", "hB"], GA: ["H", "hB"], GB: ["H", "h", "hb", "hB"], GD: ["h", "hb", "H", "hB"], GE: ["H", "hB", "h"], GF: ["H", "hB"], GG: ["H", "h", "hb", "hB"], GH: ["h", "H"], GI: ["H", "h", "hb", "hB"], GM: ["h", "hb", "H", "hB"], GN: ["H", "hB"], GP: ["H", "hB"], GQ: ["H", "hB", "h", "hb"], GR: ["h", "H", "hb", "hB"], GT: ["H", "h", "hB", "hb"], GU: ["h", "hb", "H", "hB"], GW: ["H", "hB"], GY: ["h", "hb", "H", "hB"], HK: ["h", "hB", "hb", "H"], HN: ["H", "h", "hB", "hb"], HR: ["H", "hB"], IC: ["H", "h", "hB", "hb"], ID: ["H"], IE: ["H", "h", "hb", "hB"], IL: ["H", "hB"], IM: ["H", "h", "hb", "hB"], IN: ["h", "H"], IO: ["H", "h", "hb", "hB"], IQ: ["h", "hB", "hb", "H"], IR: ["hB", "H"], IS: ["H"], IT: ["H", "hB"], JE: ["H", "h", "hb", "hB"], JM: ["h", "hb", "H", "hB"], JO: ["h", "hB", "hb", "H"], JP: ["H", "h", "K"], KE: ["hB", "hb", "H", "h"], KG: ["H", "h", "hB", "hb"], KH: ["hB", "h", "H", "hb"], KI: ["h", "hb", "H", "hB"], KM: ["H", "h", "hB", "hb"], KN: ["h", "hb", "H", "hB"], KP: ["h", "H", "hB", "hb"], KR: ["h", "H", "hB", "hb"], KW: ["h", "hB", "hb", "H"], KY: ["h", "hb", "H", "hB"], KZ: ["H", "hB"], LA: ["H", "hb", "hB", "h"], LB: ["h", "hB", "hb", "H"], LC: ["h", "hb", "H", "hB"], LI: ["H", "hB", "h"], LK: ["H", "h", "hB", "hb"], LR: ["h", "hb", "H", "hB"], LS: ["h", "H"], LT: ["H", "h", "hb", "hB"], LU: ["H", "h", "hB"], LV: ["H", "hB", "hb", "h"], LY: ["h", "hB", "hb", "H"], MA: ["H", "h", "hB", "hb"], MC: ["H", "hB"], MD: ["H", "hB"], ME: ["H", "hB", "h"], MF: ["H", "hB"], MH: ["h", "hb", "H", "hB"], MK: ["H", "h", "hb", "hB"], ML: ["H"], MM: ["hB", "hb", "H", "h"], MN: ["H", "h", "hb", "hB"], MO: ["h", "hB", "hb", "H"], MP: ["h", "hb", "H", "hB"], MQ: ["H", "hB"], MR: ["h", "hB", "hb", "H"], MS: ["H", "h", "hb", "hB"], MW: ["h", "hb", "H", "hB"], MX: ["H", "h", "hB", "hb"], MY: ["hb", "hB", "h", "H"], MZ: ["H", "hB"], NA: ["h", "H", "hB", "hb"], NC: ["H", "hB"], NE: ["H"], NF: ["H", "h", "hb", "hB"], NG: ["H", "h", "hb", "hB"], NI: ["H", "h", "hB", "hb"], NL: ["H", "hB"], NP: ["H", "h", "hB"], NR: ["H", "h", "hb", "hB"], NU: ["H", "h", "hb", "hB"], NZ: ["h", "hb", "H", "hB"], OM: ["h", "hB", "hb", "H"], PA: ["h", "H", "hB", "hb"], PE: ["H", "hB", "h", "hb"], PF: ["H", "h", "hB"], PG: ["h", "H"], PH: ["h", "hB", "hb", "H"], PK: ["h", "hB", "H"], PM: ["H", "hB"], PN: ["H", "h", "hb", "hB"], PR: ["h", "H", "hB", "hb"], PS: ["h", "hB", "hb", "H"], PT: ["H", "hB"], PW: ["h", "H"], PY: ["H", "h", "hB", "hb"], QA: ["h", "hB", "hb", "H"], RE: ["H", "hB"], RO: ["H", "hB"], RS: ["H", "hB", "h"], RU: ["H"], SA: ["h", "hB", "hb", "H"], SB: ["h", "hb", "H", "hB"], SC: ["H", "h", "hB"], SD: ["h", "hB", "hb", "H"], SE: ["H"], SG: ["h", "hb", "H", "hB"], SH: ["H", "h", "hb", "hB"], SI: ["H", "hB"], SJ: ["H"], SK: ["H"], SL: ["h", "hb", "H", "hB"], SM: ["H", "h", "hB"], SN: ["H", "h", "hB"], SO: ["h", "H"], SR: ["H", "hB"], SS: ["h", "hb", "H", "hB"], ST: ["H", "hB"], SV: ["H", "h", "hB", "hb"], SX: ["H", "h", "hb", "hB"], SY: ["h", "hB", "hb", "H"], SZ: ["h", "hb", "H", "hB"], TA: ["H", "h", "hb", "hB"], TC: ["h", "hb", "H", "hB"], TD: ["h", "H", "hB"], TF: ["H", "h", "hB"], TG: ["H", "hB"], TL: ["H", "hB", "hb", "h"], TN: ["h", "hB", "hb", "H"], TO: ["h", "H"], TR: ["H", "hB"], TT: ["h", "hb", "H", "hB"], TW: ["hB", "hb", "h", "H"], TZ: ["hB", "hb", "H", "h"], UA: ["H", "hB", "h"], UG: ["hB", "hb", "H", "h"], UM: ["h", "hb", "H", "hB"], US: ["h", "hb", "H", "hB"], UY: ["H", "h", "hB", "hb"], UZ: ["H", "hB", "h"], VA: ["H", "h", "hB"], VC: ["h", "hb", "H", "hB"], VE: ["h", "H", "hB", "hb"], VG: ["h", "hb", "H", "hB"], VI: ["h", "hb", "H", "hB"], VU: ["h", "H"], WF: ["H", "hB"], WS: ["h", "H"], XK: ["H", "hB", "h"], YE: ["h", "hB", "hb", "H"], YT: ["H", "hB"], ZA: ["H", "h", "hb", "hB"], ZM: ["h", "hb", "H", "hB"], "af-ZA": ["H", "h", "hB", "hb"], "ar-001": ["h", "hB", "hb", "H"], "ca-ES": ["H", "h", "hB"], "en-001": ["h", "hb", "H", "hB"], "es-BO": ["H", "h", "hB", "hb"], "es-BR": ["H", "h", "hB", "hb"], "es-EC": ["H", "h", "hB", "hb"], "es-ES": ["H", "h", "hB", "hb"], "es-GQ": ["H", "h", "hB", "hb"], "es-PE": ["H", "h", "hB", "hb"], "fr-CA": ["H", "h", "hB"], "gl-ES": ["H", "h", "hB"], "gu-IN": ["hB", "hb", "h", "H"], "hi-IN": ["hB", "h", "H"], "it-CH": ["H", "h", "hB"], "it-IT": ["H", "h", "hB"], "kn-IN": ["hB", "h", "H"], "ml-IN": ["hB", "h", "H"], "mr-IN": ["hB", "hb", "h", "H"], "pa-IN": ["hB", "hb", "h", "H"], "ta-IN": ["hB", "h", "hb", "H"], "te-IN": ["hB", "h", "H"], "zu-ZA": ["H", "hB", "hb", "h"] }; function Br(e) { var t = e.hourCycle; if (void 0 === t && e.hourCycles && e.hourCycles.length && (t = e.hourCycles[0]), t) switch (t) { case "h24": return "k"; case "h23": return "H"; case "h12": return "h"; case "h11": return "K"; default: throw new Error("Invalid hourCycle") }var n, r = e.language; return "root" !== r && (n = e.maximize().region), (Rr[n || ""] || Rr[r || ""] || Rr["".concat(r, "-001")] || Rr["001"])[0] } var Dr = new RegExp("^".concat(vr.source, "*")), Lr = new RegExp("".concat(vr.source, "*$")); function Or(e, t) { return { start: e, end: t } } var Fr = !!String.prototype.startsWith && "_a".startsWith("a", 1), zr = !!String.fromCodePoint, Hr = !!Object.fromEntries, Nr = !!String.prototype.codePointAt, jr = !!String.prototype.trimStart, Ur = !!String.prototype.trimEnd, Vr = Number.isSafeInteger ? Number.isSafeInteger : function (e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e && Math.abs(e) <= 9007199254740991 }, Kr = !0; try { Kr = "a" === (null === (Tr = qr("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu").exec("a")) || void 0 === Tr ? void 0 : Tr[0]) } catch (e) { Kr = !1 } var Wr, Yr = Fr ? function (e, t, n) { return e.startsWith(t, n) } : function (e, t, n) { return e.slice(n, n + t.length) === t }, Gr = zr ? String.fromCodePoint : function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; for (var n, r = "", i = e.length, o = 0; i > o;) { if ((n = e[o++]) > 1114111) throw RangeError(n + " is not a valid code point"); r += n < 65536 ? String.fromCharCode(n) : String.fromCharCode(55296 + ((n -= 65536) >> 10), n % 1024 + 56320) } return r }, Zr = Hr ? Object.fromEntries : function (e) { for (var t = {}, n = 0, r = e; n < r.length; n++) { var i = r[n], o = i[0], a = i[1]; t[o] = a } return t }, Xr = Nr ? function (e, t) { return e.codePointAt(t) } : function (e, t) { var n = e.length; if (!(t < 0 || t >= n)) { var r, i = e.charCodeAt(t); return i < 55296 || i > 56319 || t + 1 === n || (r = e.charCodeAt(t + 1)) < 56320 || r > 57343 ? i : r - 56320 + (i - 55296 << 10) + 65536 } }, _r = jr ? function (e) { return e.trimStart() } : function (e) { return e.replace(Dr, "") }, Qr = Ur ? function (e) { return e.trimEnd() } : function (e) { return e.replace(Lr, "") }; function qr(e, t) { return new RegExp(e, t) } if (Kr) { var Jr = qr("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu"); Wr = function (e, t) { var n; return Jr.lastIndex = t, null !== (n = Jr.exec(e)[1]) && void 0 !== n ? n : "" } } else Wr = function (e, t) { for (var n = []; ;) { var r = Xr(e, t); if (void 0 === r || ni(r) || ri(r)) break; n.push(r), t += r >= 65536 ? 2 : 1 } return Gr.apply(void 0, n) }; var $r = function () { function e(e, t) { void 0 === t && (t = {}), this.message = e, this.position = { offset: 0, line: 1, column: 1 }, this.ignoreTag = !!t.ignoreTag, this.locale = t.locale, this.requiresOtherClause = !!t.requiresOtherClause, this.shouldParseSkeletons = !!t.shouldParseSkeletons } return e.prototype.parse = function () { if (0 !== this.offset()) throw Error("parser can only be used once"); return this.parseMessage(0, "", !1) }, e.prototype.parseMessage = function (e, t, n) { for (var r = []; !this.isEOF();) { var i = this.char(); if (123 === i) { if ((o = this.parseArgument(e, n)).err) return o; r.push(o.val) } else { if (125 === i && e > 0) break; if (35 !== i || "plural" !== t && "selectordinal" !== t) { if (60 === i && !this.ignoreTag && 47 === this.peek()) { if (n) break; return this.error($n.UNMATCHED_CLOSING_TAG, Or(this.clonePosition(), this.clonePosition())) } if (60 === i && !this.ignoreTag && ei(this.peek() || 0)) { if ((o = this.parseTag(e, t)).err) return o; r.push(o.val) } else { var o; if ((o = this.parseLiteral(e, t)).err) return o; r.push(o.val) } } else { var a = this.clonePosition(); this.bump(), r.push({ type: er.pound, location: Or(a, this.clonePosition()) }) } } } return { val: r, err: null } }, e.prototype.parseTag = function (e, t) { var n = this.clonePosition(); this.bump(); var r = this.parseTagName(); if (this.bumpSpace(), this.bumpIf("/>")) return { val: { type: er.literal, value: "<".concat(r, "/>"), location: Or(n, this.clonePosition()) }, err: null }; if (this.bumpIf(">")) { var i = this.parseMessage(e + 1, t, !0); if (i.err) return i; var o = i.val, a = this.clonePosition(); if (this.bumpIf("</")) { if (this.isEOF() || !ei(this.char())) return this.error($n.INVALID_TAG, Or(a, this.clonePosition())); var s = this.clonePosition(); return r !== this.parseTagName() ? this.error($n.UNMATCHED_CLOSING_TAG, Or(s, this.clonePosition())) : (this.bumpSpace(), this.bumpIf(">") ? { val: { type: er.tag, value: r, children: o, location: Or(n, this.clonePosition()) }, err: null } : this.error($n.INVALID_TAG, Or(a, this.clonePosition()))) } return this.error($n.UNCLOSED_TAG, Or(n, this.clonePosition())) } return this.error($n.INVALID_TAG, Or(n, this.clonePosition())) }, e.prototype.parseTagName = function () { var e = this.offset(); for (this.bump(); !this.isEOF() && ti(this.char());)this.bump(); return this.message.slice(e, this.offset()) }, e.prototype.parseLiteral = function (e, t) { for (var n = this.clonePosition(), r = ""; ;) { var i = this.tryParseQuote(t); if (i) r += i; else { var o = this.tryParseUnquoted(e, t); if (o) r += o; else { var a = this.tryParseLeftAngleBracket(); if (!a) break; r += a } } } var s = Or(n, this.clonePosition()); return { val: { type: er.literal, value: r, location: s }, err: null } }, e.prototype.tryParseLeftAngleBracket = function () { return this.isEOF() || 60 !== this.char() || !this.ignoreTag && (ei(e = this.peek() || 0) || 47 === e) ? null : (this.bump(), "<"); var e }, e.prototype.tryParseQuote = function (e) { if (this.isEOF() || 39 !== this.char()) return null; switch (this.peek()) { case 39: return this.bump(), this.bump(), "'"; case 123: case 60: case 62: case 125: break; case 35: if ("plural" === e || "selectordinal" === e) break; return null; default: return null }this.bump(); var t = [this.char()]; for (this.bump(); !this.isEOF();) { var n = this.char(); if (39 === n) { if (39 !== this.peek()) { this.bump(); break } t.push(39), this.bump() } else t.push(n); this.bump() } return Gr.apply(void 0, t) }, e.prototype.tryParseUnquoted = function (e, t) { if (this.isEOF()) return null; var n = this.char(); return 60 === n || 123 === n || 35 === n && ("plural" === t || "selectordinal" === t) || 125 === n && e > 0 ? null : (this.bump(), Gr(n)) }, e.prototype.parseArgument = function (e, t) { var n = this.clonePosition(); if (this.bump(), this.bumpSpace(), this.isEOF()) return this.error($n.EXPECT_ARGUMENT_CLOSING_BRACE, Or(n, this.clonePosition())); if (125 === this.char()) return this.bump(), this.error($n.EMPTY_ARGUMENT, Or(n, this.clonePosition())); var r = this.parseIdentifierIfPossible().value; if (!r) return this.error($n.MALFORMED_ARGUMENT, Or(n, this.clonePosition())); if (this.bumpSpace(), this.isEOF()) return this.error($n.EXPECT_ARGUMENT_CLOSING_BRACE, Or(n, this.clonePosition())); switch (this.char()) { case 125: return this.bump(), { val: { type: er.argument, value: r, location: Or(n, this.clonePosition()) }, err: null }; case 44: return this.bump(), this.bumpSpace(), this.isEOF() ? this.error($n.EXPECT_ARGUMENT_CLOSING_BRACE, Or(n, this.clonePosition())) : this.parseArgumentOptions(e, t, r, n); default: return this.error($n.MALFORMED_ARGUMENT, Or(n, this.clonePosition())) } }, e.prototype.parseIdentifierIfPossible = function () { var e = this.clonePosition(), t = this.offset(), n = Wr(this.message, t), r = t + n.length; return this.bumpTo(r), { value: n, location: Or(e, this.clonePosition()) } }, e.prototype.parseArgumentOptions = function (e, t, n, r) { var i, o = this.clonePosition(), a = this.parseIdentifierIfPossible().value, s = this.clonePosition(); switch (a) { case "": return this.error($n.EXPECT_ARGUMENT_TYPE, Or(o, s)); case "number": case "date": case "time": this.bumpSpace(); var l = null; if (this.bumpIf(",")) { this.bumpSpace(); var c = this.clonePosition(); if ((v = this.parseSimpleArgStyleIfPossible()).err) return v; if (0 === (h = Qr(v.val)).length) return this.error($n.EXPECT_ARGUMENT_STYLE, Or(this.clonePosition(), this.clonePosition())); l = { style: h, styleLocation: Or(c, this.clonePosition()) } } if ((y = this.tryParseArgumentClose(r)).err) return y; var u = Or(r, this.clonePosition()); if (l && Yr(null == l ? void 0 : l.style, "::", 0)) { var d = _r(l.style.slice(2)); if ("number" === a) return (v = this.parseNumberSkeletonFromString(d, l.styleLocation)).err ? v : { val: { type: er.number, value: n, location: u, style: v.val }, err: null }; if (0 === d.length) return this.error($n.EXPECT_DATE_TIME_SKELETON, u); var p = d; this.locale && (p = function (e, t) { for (var n = "", r = 0; r < e.length; r++) { var i = e.charAt(r); if ("j" === i) { for (var o = 0; r + 1 < e.length && e.charAt(r + 1) === i;)o++, r++; var a = 1 + (1 & o), s = o < 2 ? 1 : 3 + (o >> 1), l = Br(t); for ("H" != l && "k" != l || (s = 0); s-- > 0;)n += "a"; for (; a-- > 0;)n = l + n } else n += "J" === i ? "H" : i } return n }(d, this.locale)); var h = { type: tr.dateTime, pattern: p, location: l.styleLocation, parsedOptions: this.shouldParseSkeletons ? br(p) : {} }; return { val: { type: "date" === a ? er.date : er.time, value: n, location: u, style: h }, err: null } } return { val: { type: "number" === a ? er.number : "date" === a ? er.date : er.time, value: n, location: u, style: null !== (i = null == l ? void 0 : l.style) && void 0 !== i ? i : null }, err: null }; case "plural": case "selectordinal": case "select": var f = this.clonePosition(); if (this.bumpSpace(), !this.bumpIf(",")) return this.error($n.EXPECT_SELECT_ARGUMENT_OPTIONS, Or(f, Qn({}, f))); this.bumpSpace(); var m = this.parseIdentifierIfPossible(), g = 0; if ("select" !== a && "offset" === m.value) { if (!this.bumpIf(":")) return this.error($n.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, Or(this.clonePosition(), this.clonePosition())); var v; if (this.bumpSpace(), (v = this.tryParseDecimalInteger($n.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, $n.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE)).err) return v; this.bumpSpace(), m = this.parseIdentifierIfPossible(), g = v.val } var y, b = this.tryParsePluralOrSelectOptions(e, a, t, m); if (b.err) return b; if ((y = this.tryParseArgumentClose(r)).err) return y; var w = Or(r, this.clonePosition()); return "select" === a ? { val: { type: er.select, value: n, options: Zr(b.val), location: w }, err: null } : { val: { type: er.plural, value: n, options: Zr(b.val), offset: g, pluralType: "plural" === a ? "cardinal" : "ordinal", location: w }, err: null }; default: return this.error($n.INVALID_ARGUMENT_TYPE, Or(o, s)) } }, e.prototype.tryParseArgumentClose = function (e) { return this.isEOF() || 125 !== this.char() ? this.error($n.EXPECT_ARGUMENT_CLOSING_BRACE, Or(e, this.clonePosition())) : (this.bump(), { val: !0, err: null }) }, e.prototype.parseSimpleArgStyleIfPossible = function () { for (var e = 0, t = this.clonePosition(); !this.isEOF();)switch (this.char()) { case 39: this.bump(); var n = this.clonePosition(); if (!this.bumpUntil("'")) return this.error($n.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, Or(n, this.clonePosition())); this.bump(); break; case 123: e += 1, this.bump(); break; case 125: if (!(e > 0)) return { val: this.message.slice(t.offset, this.offset()), err: null }; e -= 1; break; default: this.bump() }return { val: this.message.slice(t.offset, this.offset()), err: null } }, e.prototype.parseNumberSkeletonFromString = function (e, t) { var n = []; try { n = function (e) { if (0 === e.length) throw new Error("Number skeleton cannot be empty"); for (var t = e.split(wr).filter((function (e) { return e.length > 0 })), n = [], r = 0, i = t; r < i.length; r++) { var o = i[r].split("/"); if (0 === o.length) throw new Error("Invalid number skeleton"); for (var a = o[0], s = o.slice(1), l = 0, c = s; l < c.length; l++)if (0 === c[l].length) throw new Error("Invalid number skeleton"); n.push({ stem: a, options: s }) } return n }(e) } catch (e) { return this.error($n.INVALID_NUMBER_SKELETON, t) } return { val: { type: tr.number, tokens: n, location: t, parsedOptions: this.shouldParseSkeletons ? Mr(n) : {} }, err: null } }, e.prototype.tryParsePluralOrSelectOptions = function (e, t, n, r) { for (var i, o = !1, a = [], s = new Set, l = r.value, c = r.location; ;) { if (0 === l.length) { var u = this.clonePosition(); if ("select" === t || !this.bumpIf("=")) break; var d = this.tryParseDecimalInteger($n.EXPECT_PLURAL_ARGUMENT_SELECTOR, $n.INVALID_PLURAL_ARGUMENT_SELECTOR); if (d.err) return d; c = Or(u, this.clonePosition()), l = this.message.slice(u.offset, this.offset()) } if (s.has(l)) return this.error("select" === t ? $n.DUPLICATE_SELECT_ARGUMENT_SELECTOR : $n.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, c); "other" === l && (o = !0), this.bumpSpace(); var p = this.clonePosition(); if (!this.bumpIf("{")) return this.error("select" === t ? $n.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : $n.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, Or(this.clonePosition(), this.clonePosition())); var h = this.parseMessage(e + 1, t, n); if (h.err) return h; var f = this.tryParseArgumentClose(p); if (f.err) return f; a.push([l, { value: h.val, location: Or(p, this.clonePosition()) }]), s.add(l), this.bumpSpace(), l = (i = this.parseIdentifierIfPossible()).value, c = i.location } return 0 === a.length ? this.error("select" === t ? $n.EXPECT_SELECT_ARGUMENT_SELECTOR : $n.EXPECT_PLURAL_ARGUMENT_SELECTOR, Or(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !o ? this.error($n.MISSING_OTHER_CLAUSE, Or(this.clonePosition(), this.clonePosition())) : { val: a, err: null } }, e.prototype.tryParseDecimalInteger = function (e, t) { var n = 1, r = this.clonePosition(); this.bumpIf("+") || this.bumpIf("-") && (n = -1); for (var i = !1, o = 0; !this.isEOF();) { var a = this.char(); if (!(a >= 48 && a <= 57)) break; i = !0, o = 10 * o + (a - 48), this.bump() } var s = Or(r, this.clonePosition()); return i ? Vr(o *= n) ? { val: o, err: null } : this.error(t, s) : this.error(e, s) }, e.prototype.offset = function () { return this.position.offset }, e.prototype.isEOF = function () { return this.offset() === this.message.length }, e.prototype.clonePosition = function () { return { offset: this.position.offset, line: this.position.line, column: this.position.column } }, e.prototype.char = function () { var e = this.position.offset; if (e >= this.message.length) throw Error("out of bound"); var t = Xr(this.message, e); if (void 0 === t) throw Error("Offset ".concat(e, " is at invalid UTF-16 code unit boundary")); return t }, e.prototype.error = function (e, t) { return { val: null, err: { kind: e, message: this.message, location: t } } }, e.prototype.bump = function () { if (!this.isEOF()) { var e = this.char(); 10 === e ? (this.position.line += 1, this.position.column = 1, this.position.offset += 1) : (this.position.column += 1, this.position.offset += e < 65536 ? 1 : 2) } }, e.prototype.bumpIf = function (e) { if (Yr(this.message, e, this.offset())) { for (var t = 0; t < e.length; t++)this.bump(); return !0 } return !1 }, e.prototype.bumpUntil = function (e) { var t = this.offset(), n = this.message.indexOf(e, t); return n >= 0 ? (this.bumpTo(n), !0) : (this.bumpTo(this.message.length), !1) }, e.prototype.bumpTo = function (e) { if (this.offset() > e) throw Error("targetOffset ".concat(e, " must be greater than or equal to the current offset ").concat(this.offset())); for (e = Math.min(e, this.message.length); ;) { var t = this.offset(); if (t === e) break; if (t > e) throw Error("targetOffset ".concat(e, " is at invalid UTF-16 code unit boundary")); if (this.bump(), this.isEOF()) break } }, e.prototype.bumpSpace = function () { for (; !this.isEOF() && ni(this.char());)this.bump() }, e.prototype.peek = function () { if (this.isEOF()) return null; var e = this.char(), t = this.offset(), n = this.message.charCodeAt(t + (e >= 65536 ? 2 : 1)); return null != n ? n : null }, e }(); function ei(e) { return e >= 97 && e <= 122 || e >= 65 && e <= 90 } function ti(e) { return 45 === e || 46 === e || e >= 48 && e <= 57 || 95 === e || e >= 97 && e <= 122 || e >= 65 && e <= 90 || 183 == e || e >= 192 && e <= 214 || e >= 216 && e <= 246 || e >= 248 && e <= 893 || e >= 895 && e <= 8191 || e >= 8204 && e <= 8205 || e >= 8255 && e <= 8256 || e >= 8304 && e <= 8591 || e >= 11264 && e <= 12271 || e >= 12289 && e <= 55295 || e >= 63744 && e <= 64975 || e >= 65008 && e <= 65533 || e >= 65536 && e <= 983039 } function ni(e) { return e >= 9 && e <= 13 || 32 === e || 133 === e || e >= 8206 && e <= 8207 || 8232 === e || 8233 === e } function ri(e) { return e >= 33 && e <= 35 || 36 === e || e >= 37 && e <= 39 || 40 === e || 41 === e || 42 === e || 43 === e || 44 === e || 45 === e || e >= 46 && e <= 47 || e >= 58 && e <= 59 || e >= 60 && e <= 62 || e >= 63 && e <= 64 || 91 === e || 92 === e || 93 === e || 94 === e || 96 === e || 123 === e || 124 === e || 125 === e || 126 === e || 161 === e || e >= 162 && e <= 165 || 166 === e || 167 === e || 169 === e || 171 === e || 172 === e || 174 === e || 176 === e || 177 === e || 182 === e || 187 === e || 191 === e || 215 === e || 247 === e || e >= 8208 && e <= 8213 || e >= 8214 && e <= 8215 || 8216 === e || 8217 === e || 8218 === e || e >= 8219 && e <= 8220 || 8221 === e || 8222 === e || 8223 === e || e >= 8224 && e <= 8231 || e >= 8240 && e <= 8248 || 8249 === e || 8250 === e || e >= 8251 && e <= 8254 || e >= 8257 && e <= 8259 || 8260 === e || 8261 === e || 8262 === e || e >= 8263 && e <= 8273 || 8274 === e || 8275 === e || e >= 8277 && e <= 8286 || e >= 8592 && e <= 8596 || e >= 8597 && e <= 8601 || e >= 8602 && e <= 8603 || e >= 8604 && e <= 8607 || 8608 === e || e >= 8609 && e <= 8610 || 8611 === e || e >= 8612 && e <= 8613 || 8614 === e || e >= 8615 && e <= 8621 || 8622 === e || e >= 8623 && e <= 8653 || e >= 8654 && e <= 8655 || e >= 8656 && e <= 8657 || 8658 === e || 8659 === e || 8660 === e || e >= 8661 && e <= 8691 || e >= 8692 && e <= 8959 || e >= 8960 && e <= 8967 || 8968 === e || 8969 === e || 8970 === e || 8971 === e || e >= 8972 && e <= 8991 || e >= 8992 && e <= 8993 || e >= 8994 && e <= 9e3 || 9001 === e || 9002 === e || e >= 9003 && e <= 9083 || 9084 === e || e >= 9085 && e <= 9114 || e >= 9115 && e <= 9139 || e >= 9140 && e <= 9179 || e >= 9180 && e <= 9185 || e >= 9186 && e <= 9254 || e >= 9255 && e <= 9279 || e >= 9280 && e <= 9290 || e >= 9291 && e <= 9311 || e >= 9472 && e <= 9654 || 9655 === e || e >= 9656 && e <= 9664 || 9665 === e || e >= 9666 && e <= 9719 || e >= 9720 && e <= 9727 || e >= 9728 && e <= 9838 || 9839 === e || e >= 9840 && e <= 10087 || 10088 === e || 10089 === e || 10090 === e || 10091 === e || 10092 === e || 10093 === e || 10094 === e || 10095 === e || 10096 === e || 10097 === e || 10098 === e || 10099 === e || 10100 === e || 10101 === e || e >= 10132 && e <= 10175 || e >= 10176 && e <= 10180 || 10181 === e || 10182 === e || e >= 10183 && e <= 10213 || 10214 === e || 10215 === e || 10216 === e || 10217 === e || 10218 === e || 10219 === e || 10220 === e || 10221 === e || 10222 === e || 10223 === e || e >= 10224 && e <= 10239 || e >= 10240 && e <= 10495 || e >= 10496 && e <= 10626 || 10627 === e || 10628 === e || 10629 === e || 10630 === e || 10631 === e || 10632 === e || 10633 === e || 10634 === e || 10635 === e || 10636 === e || 10637 === e || 10638 === e || 10639 === e || 10640 === e || 10641 === e || 10642 === e || 10643 === e || 10644 === e || 10645 === e || 10646 === e || 10647 === e || 10648 === e || e >= 10649 && e <= 10711 || 10712 === e || 10713 === e || 10714 === e || 10715 === e || e >= 10716 && e <= 10747 || 10748 === e || 10749 === e || e >= 10750 && e <= 11007 || e >= 11008 && e <= 11055 || e >= 11056 && e <= 11076 || e >= 11077 && e <= 11078 || e >= 11079 && e <= 11084 || e >= 11085 && e <= 11123 || e >= 11124 && e <= 11125 || e >= 11126 && e <= 11157 || 11158 === e || e >= 11159 && e <= 11263 || e >= 11776 && e <= 11777 || 11778 === e || 11779 === e || 11780 === e || 11781 === e || e >= 11782 && e <= 11784 || 11785 === e || 11786 === e || 11787 === e || 11788 === e || 11789 === e || e >= 11790 && e <= 11798 || 11799 === e || e >= 11800 && e <= 11801 || 11802 === e || 11803 === e || 11804 === e || 11805 === e || e >= 11806 && e <= 11807 || 11808 === e || 11809 === e || 11810 === e || 11811 === e || 11812 === e || 11813 === e || 11814 === e || 11815 === e || 11816 === e || 11817 === e || e >= 11818 && e <= 11822 || 11823 === e || e >= 11824 && e <= 11833 || e >= 11834 && e <= 11835 || e >= 11836 && e <= 11839 || 11840 === e || 11841 === e || 11842 === e || e >= 11843 && e <= 11855 || e >= 11856 && e <= 11857 || 11858 === e || e >= 11859 && e <= 11903 || e >= 12289 && e <= 12291 || 12296 === e || 12297 === e || 12298 === e || 12299 === e || 12300 === e || 12301 === e || 12302 === e || 12303 === e || 12304 === e || 12305 === e || e >= 12306 && e <= 12307 || 12308 === e || 12309 === e || 12310 === e || 12311 === e || 12312 === e || 12313 === e || 12314 === e || 12315 === e || 12316 === e || 12317 === e || e >= 12318 && e <= 12319 || 12320 === e || 12336 === e || 64830 === e || 64831 === e || e >= 65093 && e <= 65094 } function ii(e) { e.forEach((function (e) { if (delete e.location, dr(e) || pr(e)) for (var t in e.options) delete e.options[t].location, ii(e.options[t].value); else lr(e) && mr(e.style) || (cr(e) || ur(e)) && gr(e.style) ? delete e.style.location : fr(e) && ii(e.children) })) } function oi(e, t) { void 0 === t && (t = {}), t = Qn({ shouldParseSkeletons: !0, requiresOtherClause: !0 }, t); var n = new $r(e, t).parse(); if (n.err) { var r = SyntaxError($n[n.err.kind]); throw r.location = n.err.location, r.originalMessage = n.err.message, r } return (null == t ? void 0 : t.captureLocation) || ii(n.val), n.val } function ai(e, t) { var n = t && t.cache ? t.cache : fi, r = t && t.serializer ? t.serializer : di; return (t && t.strategy ? t.strategy : ui)(e, { cache: n, serializer: r }) } function si(e, t, n, r) { var i, o = null == (i = r) || "number" == typeof i || "boolean" == typeof i ? r : n(r), a = t.get(o); return void 0 === a && (a = e.call(this, r), t.set(o, a)), a } function li(e, t, n) { var r = Array.prototype.slice.call(arguments, 3), i = n(r), o = t.get(i); return void 0 === o && (o = e.apply(this, r), t.set(i, o)), o } function ci(e, t, n, r, i) { return n.bind(t, e, r, i) } function ui(e, t) { return ci(e, this, 1 === e.length ? si : li, t.cache.create(), t.serializer) } var di = function () { return JSON.stringify(arguments) }; function pi() { this.cache = Object.create(null) } pi.prototype.get = function (e) { return this.cache[e] }, pi.prototype.set = function (e, t) { this.cache[e] = t }; var hi, fi = { create: function () { return new pi } }, mi = { variadic: function (e, t) { return ci(e, this, li, t.cache.create(), t.serializer) }, monadic: function (e, t) { return ci(e, this, si, t.cache.create(), t.serializer) } }; !function (e) { e.MISSING_VALUE = "MISSING_VALUE", e.INVALID_VALUE = "INVALID_VALUE", e.MISSING_INTL_API = "MISSING_INTL_API" }(hi || (hi = {})); var gi, vi = function (e) { function t(t, n, r) { var i = e.call(this, t) || this; return i.code = n, i.originalMessage = r, i } return _n(t, e), t.prototype.toString = function () { return "[formatjs Error: ".concat(this.code, "] ").concat(this.message) }, t }(Error), yi = function (e) { function t(t, n, r, i) { return e.call(this, 'Invalid values for "'.concat(t, '": "').concat(n, '". Options are "').concat(Object.keys(r).join('", "'), '"'), hi.INVALID_VALUE, i) || this } return _n(t, e), t }(vi), bi = function (e) { function t(t, n, r) { return e.call(this, 'Value for "'.concat(t, '" must be of type ').concat(n), hi.INVALID_VALUE, r) || this } return _n(t, e), t }(vi), wi = function (e) { function t(t, n) { return e.call(this, 'The intl string context variable "'.concat(t, '" was not provided to the string "').concat(n, '"'), hi.MISSING_VALUE, n) || this } return _n(t, e), t }(vi); function Ei(e) { return "function" == typeof e } function Ci(e, t, n, r, i, o, a) { if (1 === e.length && ar(e[0])) return [{ type: gi.literal, value: e[0].value }]; for (var s = [], l = 0, c = e; l < c.length; l++) { var u = c[l]; if (ar(u)) s.push({ type: gi.literal, value: u.value }); else if (hr(u)) "number" == typeof o && s.push({ type: gi.literal, value: n.getNumberFormat(t).format(o) }); else { var d = u.value; if (!i || !(d in i)) throw new wi(d, a); var p = i[d]; if (sr(u)) p && "string" != typeof p && "number" != typeof p || (p = "string" == typeof p || "number" == typeof p ? String(p) : ""), s.push({ type: "string" == typeof p ? gi.literal : gi.object, value: p }); else if (cr(u)) { var h = "string" == typeof u.style ? r.date[u.style] : gr(u.style) ? u.style.parsedOptions : void 0; s.push({ type: gi.literal, value: n.getDateTimeFormat(t, h).format(p) }) } else if (ur(u)) h = "string" == typeof u.style ? r.time[u.style] : gr(u.style) ? u.style.parsedOptions : r.time.medium, s.push({ type: gi.literal, value: n.getDateTimeFormat(t, h).format(p) }); else if (lr(u)) (h = "string" == typeof u.style ? r.number[u.style] : mr(u.style) ? u.style.parsedOptions : void 0) && h.scale && (p *= h.scale || 1), s.push({ type: gi.literal, value: n.getNumberFormat(t, h).format(p) }); else { if (fr(u)) { var f = u.children, m = u.value, g = i[m]; if (!Ei(g)) throw new bi(m, "function", a); var v = g(Ci(f, t, n, r, i, o).map((function (e) { return e.value }))); Array.isArray(v) || (v = [v]), s.push.apply(s, v.map((function (e) { return { type: "string" == typeof e ? gi.literal : gi.object, value: e } }))) } if (dr(u)) { if (!(y = u.options[p] || u.options.other)) throw new yi(u.value, p, Object.keys(u.options), a); s.push.apply(s, Ci(y.value, t, n, r, i)) } else if (pr(u)) { var y; if (!(y = u.options["=".concat(p)])) { if (!Intl.PluralRules) throw new vi('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', hi.MISSING_INTL_API, a); var b = n.getPluralRules(t, { type: u.pluralType }).select(p - (u.offset || 0)); y = u.options[b] || u.options.other } if (!y) throw new yi(u.value, p, Object.keys(u.options), a); s.push.apply(s, Ci(y.value, t, n, r, i, p - (u.offset || 0))) } } } } return (w = s).length < 2 ? w : w.reduce((function (e, t) { var n = e[e.length - 1]; return n && n.type === gi.literal && t.type === gi.literal ? n.value += t.value : e.push(t), e }), []); var w } function Si(e) { return { create: function () { return { get: function (t) { return e[t] }, set: function (t, n) { e[t] = n } } } } } !function (e) { e[e.literal = 0] = "literal", e[e.object = 1] = "object" }(gi || (gi = {})); var ki, xi = function () { function e(t, n, r, i) { void 0 === n && (n = e.defaultLocale); var o, a, s, l = this; if (this.formatterCache = { number: {}, dateTime: {}, pluralRules: {} }, this.format = function (e) { var t = l.formatToParts(e); if (1 === t.length) return t[0].value; var n = t.reduce((function (e, t) { return e.length && t.type === gi.literal && "string" == typeof e[e.length - 1] ? e[e.length - 1] += t.value : e.push(t.value), e }), []); return n.length <= 1 ? n[0] || "" : n }, this.formatToParts = function (e) { return Ci(l.ast, l.locales, l.formatters, l.formats, e, void 0, l.message) }, this.resolvedOptions = function () { var e; return { locale: (null === (e = l.resolvedLocale) || void 0 === e ? void 0 : e.toString()) || Intl.NumberFormat.supportedLocalesOf(l.locales)[0] } }, this.getAst = function () { return l.ast }, this.locales = n, this.resolvedLocale = e.resolveLocale(n), "string" == typeof t) { if (this.message = t, !e.__parse) throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`"); var c = i || {}, u = (c.formatters, qn(c, ["formatters"])); this.ast = e.__parse(t, Qn(Qn({}, u), { locale: this.resolvedLocale })) } else this.ast = t; if (!Array.isArray(this.ast)) throw new TypeError("A message must be provided as a String or AST."); this.formats = (a = e.formats, (s = r) ? Object.keys(a).reduce((function (e, t) { return e[t] = (n = a[t], (r = s[t]) ? Qn(Qn(Qn({}, n || {}), r || {}), Object.keys(n).reduce((function (e, t) { return e[t] = Qn(Qn({}, n[t]), r[t] || {}), e }), {})) : n), e; var n, r }), Qn({}, a)) : a), this.formatters = i && i.formatters || (void 0 === (o = this.formatterCache) && (o = { number: {}, dateTime: {}, pluralRules: {} }), { getNumberFormat: ai((function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return new ((e = Intl.NumberFormat).bind.apply(e, Jn([void 0], t, !1))) }), { cache: Si(o.number), strategy: mi.variadic }), getDateTimeFormat: ai((function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return new ((e = Intl.DateTimeFormat).bind.apply(e, Jn([void 0], t, !1))) }), { cache: Si(o.dateTime), strategy: mi.variadic }), getPluralRules: ai((function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return new ((e = Intl.PluralRules).bind.apply(e, Jn([void 0], t, !1))) }), { cache: Si(o.pluralRules), strategy: mi.variadic }) }) } return Object.defineProperty(e, "defaultLocale", { get: function () { return e.memoizedDefaultLocale || (e.memoizedDefaultLocale = (new Intl.NumberFormat).resolvedOptions().locale), e.memoizedDefaultLocale }, enumerable: !1, configurable: !0 }), e.memoizedDefaultLocale = null, e.resolveLocale = function (e) { if (void 0 !== Intl.Locale) { var t = Intl.NumberFormat.supportedLocalesOf(e); return t.length > 0 ? new Intl.Locale(t[0]) : new Intl.Locale("string" == typeof e ? e : e[0]) } }, e.__parse = oi, e.formats = { number: { integer: { maximumFractionDigits: 0 }, currency: { style: "currency" }, percent: { style: "percent" } }, date: { short: { month: "numeric", day: "numeric", year: "2-digit" }, medium: { month: "short", day: "numeric", year: "numeric" }, long: { month: "long", day: "numeric", year: "numeric" }, full: { weekday: "long", month: "long", day: "numeric", year: "numeric" } }, time: { short: { hour: "numeric", minute: "numeric" }, medium: { hour: "numeric", minute: "numeric", second: "numeric" }, long: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" }, full: { hour: "numeric", minute: "numeric", second: "numeric", timeZoneName: "short" } } }, e }(); !function (e) { e.FORMAT_ERROR = "FORMAT_ERROR", e.UNSUPPORTED_FORMATTER = "UNSUPPORTED_FORMATTER", e.INVALID_CONFIG = "INVALID_CONFIG", e.MISSING_DATA = "MISSING_DATA", e.MISSING_TRANSLATION = "MISSING_TRANSLATION" }(ki || (ki = {})); var Ai = function (e) { function t(n, r, i) { var o = this, a = i ? i instanceof Error ? i : new Error(String(i)) : void 0; return (o = e.call(this, "[@formatjs/intl Error ".concat(n, "] ").concat(r, "\n").concat(a ? "\n".concat(a.message, "\n").concat(a.stack) : "")) || this).code = n, "function" == typeof Error.captureStackTrace && Error.captureStackTrace(o, t), o } return _n(t, e), t }(Error), Ii = function (e) { function t(t, n) { return e.call(this, ki.UNSUPPORTED_FORMATTER, t, n) || this } return _n(t, e), t }(Ai), Pi = function (e) { function t(t, n) { return e.call(this, ki.INVALID_CONFIG, t, n) || this } return _n(t, e), t }(Ai), Mi = function (e) { function t(t, n) { return e.call(this, ki.MISSING_DATA, t, n) || this } return _n(t, e), t }(Ai), Ti = function (e) { function t(t, n, r) { var i = e.call(this, ki.FORMAT_ERROR, "".concat(t, "\nLocale: ").concat(n, "\n"), r) || this; return i.locale = n, i } return _n(t, e), t }(Ai), Ri = function (e) { function t(t, n, r, i) { var o = e.call(this, "".concat(t, "\nMessageID: ").concat(null == r ? void 0 : r.id, "\nDefault Message: ").concat(null == r ? void 0 : r.defaultMessage, "\nDescription: ").concat(null == r ? void 0 : r.description, "\n"), n, i) || this; return o.descriptor = r, o.locale = n, o } return _n(t, e), t }(Ti), Bi = function (e) { function t(t, n) { var r = e.call(this, ki.MISSING_TRANSLATION, 'Missing message: "'.concat(t.id, '" for locale "').concat(n, '", using ').concat(t.defaultMessage ? "default message (".concat("string" == typeof t.defaultMessage ? t.defaultMessage : t.defaultMessage.map((function (e) { var t; return null !== (t = e.value) && void 0 !== t ? t : JSON.stringify(e) })).join(), ")") : "id", " as fallback.")) || this; return r.descriptor = t, r } return _n(t, e), t }(Ai); function Di(e, t, n) { return void 0 === n && (n = {}), t.reduce((function (t, r) { return r in e ? t[r] = e[r] : r in n && (t[r] = n[r]), t }), {}) } var Li = { formats: {}, messages: {}, timeZone: void 0, defaultLocale: "en", defaultFormats: {}, fallbackOnEmptyString: !0, onError: function (e) { }, onWarn: function (e) { } }; function Oi(e) { return { create: function () { return { get: function (t) { return e[t] }, set: function (t, n) { e[t] = n } } } } } function Fi(e, t, n, r) { var i, o = e && e[t]; if (o && (i = o[n]), i) return i; r(new Ii("No ".concat(t, " format named: ").concat(n))) } function zi(e) { or(e, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.") } var Hi = Qn(Qn({}, Li), { textComponent: A.Fragment }); function Ni(e, t) { if (e === t) return !0; if (!e || !t) return !1; var n = Object.keys(e), r = Object.keys(t), i = n.length; if (r.length !== i) return !1; for (var o = 0; o < i; o++) { var a = n[o]; if (e[a] !== t[a] || !Object.prototype.hasOwnProperty.call(t, a)) return !1 } return !0 } function ji(e, t) { return Object.keys(e).reduce((function (n, r) { return n[r] = Qn({ timeZone: t }, e[r]), n }), {}) } function Ui(e, t) { return Object.keys(Qn(Qn({}, e), t)).reduce((function (n, r) { return n[r] = Qn(Qn({}, e[r] || {}), t[r] || {}), n }), {}) } function Vi(e, t) { if (!t) return e; var n = xi.formats; return Qn(Qn(Qn({}, n), e), { date: Ui(ji(n.date, t), ji(e.date || {}, t)), time: Ui(ji(n.time, t), ji(e.time || {}, t)) }) } var Ki = function (e, t, n, r, i) { var o = e.locale, a = e.formats, s = e.messages, l = e.defaultLocale, c = e.defaultFormats, u = e.fallbackOnEmptyString, d = e.onError, p = e.timeZone, h = e.defaultRichTextElements; void 0 === n && (n = { id: "" }); var f = n.id, m = n.defaultMessage; or(!!f, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue"); var g = String(f), v = s && Object.prototype.hasOwnProperty.call(s, g) && s[g]; if (Array.isArray(v) && 1 === v.length && v[0].type === er.literal) return v[0].value; if (!r && v && "string" == typeof v && !h) return v.replace(/'\{(.*?)\}'/gi, "{$1}"); if (r = Qn(Qn({}, h), r || {}), a = Vi(a, p), c = Vi(c, p), !v) { if (!1 === u && "" === v) return v; if ((!m || o && o.toLowerCase() !== l.toLowerCase()) && d(new Bi(n, o)), m) try { return t.getMessageFormat(m, l, c, i).format(r) } catch (e) { return d(new Ri('Error formatting default message for: "'.concat(g, '", rendering default message verbatim'), o, n, e)), "string" == typeof m ? m : g } return g } try { return t.getMessageFormat(v, o, a, Qn({ formatters: t }, i || {})).format(r) } catch (e) { d(new Ri('Error formatting message: "'.concat(g, '", using ').concat(m ? "default message" : "id", " as fallback."), o, n, e)) } if (m) try { return t.getMessageFormat(m, l, c, i).format(r) } catch (e) { d(new Ri('Error formatting the default message for: "'.concat(g, '", rendering message verbatim'), o, n, e)) } return "string" == typeof v ? v : "string" == typeof m ? m : g }, Wi = ["style", "currency", "currencyDisplay", "unit", "unitDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "currencyDisplay", "currencySign", "notation", "signDisplay", "unit", "unitDisplay", "numberingSystem"]; function Yi(e, t, n) { var r = e.locale, i = e.formats, o = e.onError; void 0 === n && (n = {}); var a = n.format, s = a && Fi(i, "number", a, o) || {}; return t(r, Di(n, Wi, s)) } function Gi(e, t, n, r) { void 0 === r && (r = {}); try { return Yi(e, t, r).format(n) } catch (t) { e.onError(new Ti("Error formatting number.", e.locale, t)) } return String(n) } function Zi(e, t, n, r) { void 0 === r && (r = {}); try { return Yi(e, t, r).formatToParts(n) } catch (t) { e.onError(new Ti("Error formatting number.", e.locale, t)) } return [] } var Xi = ["numeric", "style"]; function _i(e, t, n, r, i) { void 0 === i && (i = {}), r || (r = "second"), Intl.RelativeTimeFormat || e.onError(new vi('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', hi.MISSING_INTL_API)); try { return function (e, t, n) { var r = e.locale, i = e.formats, o = e.onError; void 0 === n && (n = {}); var a = n.format, s = !!a && Fi(i, "relative", a, o) || {}; return t(r, Di(n, Xi, s)) }(e, t, i).format(n, r) } catch (t) { e.onError(new Ti("Error formatting relative time.", e.locale, t)) } return String(n) } var Qi = ["formatMatcher", "timeZone", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hourCycle", "dateStyle", "timeStyle", "calendar", "numberingSystem", "fractionalSecondDigits"]; function qi(e, t, n, r) { var i = e.locale, o = e.formats, a = e.onError, s = e.timeZone; void 0 === r && (r = {}); var l = r.format, c = Qn(Qn({}, s && { timeZone: s }), l && Fi(o, t, l, a)), u = Di(r, Qi, c); return "time" !== t || u.hour || u.minute || u.second || u.timeStyle || u.dateStyle || (u = Qn(Qn({}, u), { hour: "numeric", minute: "numeric" })), n(i, u) } function Ji(e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var i = n[0], o = n[1], a = void 0 === o ? {} : o, s = "string" == typeof i ? new Date(i || 0) : i; try { return qi(e, "date", t, a).format(s) } catch (t) { e.onError(new Ti("Error formatting date.", e.locale, t)) } return String(s) } function $i(e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var i = n[0], o = n[1], a = void 0 === o ? {} : o, s = "string" == typeof i ? new Date(i || 0) : i; try { return qi(e, "time", t, a).format(s) } catch (t) { e.onError(new Ti("Error formatting time.", e.locale, t)) } return String(s) } function eo(e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var i = n[0], o = n[1], a = n[2], s = void 0 === a ? {} : a, l = e.timeZone, c = e.locale, u = e.onError, d = Di(s, Qi, l ? { timeZone: l } : {}); try { return t(c, d).formatRange(i, o) } catch (t) { u(new Ti("Error formatting date time range.", e.locale, t)) } return String(i) } function to(e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var i = n[0], o = n[1], a = void 0 === o ? {} : o, s = "string" == typeof i ? new Date(i || 0) : i; try { return qi(e, "date", t, a).formatToParts(s) } catch (t) { e.onError(new Ti("Error formatting date.", e.locale, t)) } return [] } function no(e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; var i = n[0], o = n[1], a = void 0 === o ? {} : o, s = "string" == typeof i ? new Date(i || 0) : i; try { return qi(e, "time", t, a).formatToParts(s) } catch (t) { e.onError(new Ti("Error formatting time.", e.locale, t)) } return [] } var ro = ["type"]; function io(e, t, n, r) { var i = e.locale, o = e.onError; void 0 === r && (r = {}), Intl.PluralRules || o(new vi('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', hi.MISSING_INTL_API)); var a = Di(r, ro); try { return t(i, a).select(n) } catch (e) { o(new Ti("Error formatting plural.", i, e)) } return "other" } var oo = ["type", "style"], ao = Date.now(); function so(e, t, n, r) { void 0 === r && (r = {}); var i = lo(e, t, n, r).reduce((function (e, t) { var n = t.value; return "string" != typeof n ? e.push(n) : "string" == typeof e[e.length - 1] ? e[e.length - 1] += n : e.push(n), e }), []); return 1 === i.length ? i[0] : 0 === i.length ? "" : i } function lo(e, t, n, r) { var i = e.locale, o = e.onError; void 0 === r && (r = {}), Intl.ListFormat || o(new vi('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', hi.MISSING_INTL_API)); var a = Di(r, oo); try { var s = {}, l = n.map((function (e, t) { if ("object" == typeof e) { var n = function (e) { return "".concat(ao, "_").concat(e, "_").concat(ao) }(t); return s[n] = e, n } return String(e) })); return t(i, a).formatToParts(l).map((function (e) { return "literal" === e.type ? e : Qn(Qn({}, e), { value: s[e.value] || e.value }) })) } catch (e) { o(new Ti("Error formatting list.", i, e)) } return n } var co = ["style", "type", "fallback", "languageDisplay"]; function uo(e, t, n, r) { var i = e.locale, o = e.onError; Intl.DisplayNames || o(new vi('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', hi.MISSING_INTL_API)); var a = Di(r, co); try { return t(i, a).of(n) } catch (e) { o(new Ti("Error formatting display name.", i, e)) } } function po(e, t) { var n = function (e) { void 0 === e && (e = { dateTime: {}, number: {}, message: {}, relativeTime: {}, pluralRules: {}, list: {}, displayNames: {} }); var t = Intl.RelativeTimeFormat, n = Intl.ListFormat, r = Intl.DisplayNames, i = ai((function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return new ((e = Intl.DateTimeFormat).bind.apply(e, Jn([void 0], t, !1))) }), { cache: Oi(e.dateTime), strategy: mi.variadic }), o = ai((function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return new ((e = Intl.NumberFormat).bind.apply(e, Jn([void 0], t, !1))) }), { cache: Oi(e.number), strategy: mi.variadic }), a = ai((function () { for (var e, t = [], n = 0; n < arguments.length; n++)t[n] = arguments[n]; return new ((e = Intl.PluralRules).bind.apply(e, Jn([void 0], t, !1))) }), { cache: Oi(e.pluralRules), strategy: mi.variadic }); return { getDateTimeFormat: i, getNumberFormat: o, getMessageFormat: ai((function (e, t, n, r) { return new xi(e, t, n, Qn({ formatters: { getNumberFormat: o, getDateTimeFormat: i, getPluralRules: a } }, r || {})) }), { cache: Oi(e.message), strategy: mi.variadic }), getRelativeTimeFormat: ai((function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; return new (t.bind.apply(t, Jn([void 0], e, !1))) }), { cache: Oi(e.relativeTime), strategy: mi.variadic }), getPluralRules: a, getListFormat: ai((function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return new (n.bind.apply(n, Jn([void 0], e, !1))) }), { cache: Oi(e.list), strategy: mi.variadic }), getDisplayNames: ai((function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return new (r.bind.apply(r, Jn([void 0], e, !1))) }), { cache: Oi(e.displayNames), strategy: mi.variadic }) } }(t), r = Qn(Qn({}, Li), e), i = r.locale, o = r.defaultLocale, a = r.onError; return i ? !Intl.NumberFormat.supportedLocalesOf(i).length && a ? a(new Mi('Missing locale data for locale: "'.concat(i, '" in Intl.NumberFormat. Using default locale: "').concat(o, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details'))) : !Intl.DateTimeFormat.supportedLocalesOf(i).length && a && a(new Mi('Missing locale data for locale: "'.concat(i, '" in Intl.DateTimeFormat. Using default locale: "').concat(o, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details'))) : (a && a(new Pi('"locale" was not configured, using "'.concat(o, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details'))), r.locale = r.defaultLocale || "en"), function (e) { var t; e.onWarn && e.defaultRichTextElements && "string" == typeof ((t = e.messages || {}) ? t[Object.keys(t)[0]] : void 0) && e.onWarn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution') }(r), Qn(Qn({}, r), { formatters: n, formatNumber: Gi.bind(null, r, n.getNumberFormat), formatNumberToParts: Zi.bind(null, r, n.getNumberFormat), formatRelativeTime: _i.bind(null, r, n.getRelativeTimeFormat), formatDate: Ji.bind(null, r, n.getDateTimeFormat), formatDateToParts: to.bind(null, r, n.getDateTimeFormat), formatTime: $i.bind(null, r, n.getDateTimeFormat), formatDateTimeRange: eo.bind(null, r, n.getDateTimeFormat), formatTimeToParts: no.bind(null, r, n.getDateTimeFormat), formatPlural: io.bind(null, r, n.getPluralRules), formatMessage: Ki.bind(null, r, n), $t: Ki.bind(null, r, n), formatList: so.bind(null, r, n.getListFormat), formatListToParts: lo.bind(null, r, n.getListFormat), formatDisplayName: uo.bind(null, r, n.getDisplayNames) }) } function ho(e) { return { locale: e.locale, timeZone: e.timeZone, fallbackOnEmptyString: e.fallbackOnEmptyString, formats: e.formats, textComponent: e.textComponent, messages: e.messages, defaultLocale: e.defaultLocale, defaultFormats: e.defaultFormats, onError: e.onError, onWarn: e.onWarn, wrapRichTextChunksInFragment: e.wrapRichTextChunksInFragment, defaultRichTextElements: e.defaultRichTextElements } } function fo(e) { return e ? Object.keys(e).reduce((function (t, n) { var r, i = e[n]; return t[n] = Ei(i) ? (r = i, function (e) { return r(A.Children.toArray(e)) }) : i, t }), {}) : e } var mo = function (e, t, n, r) { for (var i = [], o = 4; o < arguments.length; o++)i[o - 4] = arguments[o]; var a = fo(r), s = Ki.apply(void 0, Jn([e, t, n, a], i, !1)); return Array.isArray(s) ? A.Children.toArray(s) : s }, go = function (e, t) { var n = e.defaultRichTextElements, r = qn(e, ["defaultRichTextElements"]), i = fo(n), o = po(Qn(Qn(Qn({}, Hi), r), { defaultRichTextElements: i }), t), a = { locale: o.locale, timeZone: o.timeZone, fallbackOnEmptyString: o.fallbackOnEmptyString, formats: o.formats, defaultLocale: o.defaultLocale, defaultFormats: o.defaultFormats, messages: o.messages, onError: o.onError, defaultRichTextElements: i }; return Qn(Qn({}, o), { formatMessage: mo.bind(null, a, o.formatters), $t: mo.bind(null, a, o.formatters) }) }, vo = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.cache = { dateTime: {}, number: {}, message: {}, relativeTime: {}, pluralRules: {}, list: {}, displayNames: {} }, t.state = { cache: t.cache, intl: go(ho(t.props), t.cache), prevConfig: ho(t.props) }, t } return _n(t, e), t.getDerivedStateFromProps = function (e, t) { var n = t.prevConfig, r = t.cache, i = ho(e); return Ni(n, i) ? null : { intl: go(i, r), prevConfig: i } }, t.prototype.render = function () { return zi(this.state.intl), A.createElement(rr, { value: this.state.intl }, this.props.children) }, t.displayName = "IntlProvider", t.defaultProps = Hi, t }(A.PureComponent); const yo = vo; function bo() { return bo = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, bo.apply(this, arguments) } function wo(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (r) { if (null == e || e(r), !1 === n || !r.defaultPrevented) return null == t ? void 0 : t(r) } } function Eo(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } var Co = n(3935); function So(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } const ko = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(Io); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(xo, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(xo, bo({}, r, { ref: t }), n) })); ko.displayName = "Slot"; const xo = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...Po(r, n.props), ref: So(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); xo.displayName = "SlotClone"; const Ao = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function Io(e) { return (0, A.isValidElement)(e) && e.type === Ao } function Po(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const Mo = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? ko : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}); function To(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (r) { if (null == e || e(r), !1 === n || !r.defaultPrevented) return null == t ? void 0 : t(r) } } function Ro(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } function Bo(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } function Do(...e) { return (0, A.useCallback)(Bo(...e), e) } const Lo = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(zo); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(Oo, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(Oo, bo({}, r, { ref: t }), n) })); Lo.displayName = "Slot"; const Oo = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...Ho(r, n.props), ref: Bo(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); Oo.displayName = "SlotClone"; const Fo = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function zo(e) { return (0, A.isValidElement)(e) && e.type === Fo } function Ho(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } function No(e) { const t = e + "CollectionProvider", [n, r] = function (e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, Ro(r, ...t)] }(t), [i, o] = n(t, { collectionRef: { current: null }, itemMap: new Map }), a = e + "CollectionSlot", s = e + "CollectionItemSlot", l = "data-radix-collection-item"; return [{ Provider: e => { const { scope: t, children: n } = e, r = A.useRef(null), o = A.useRef(new Map).current; return A.createElement(i, { scope: t, itemMap: o, collectionRef: r }, n) }, Slot: A.forwardRef(((e, t) => { const { scope: n, children: r } = e, i = Do(t, o(a, n).collectionRef); return A.createElement(Lo, { ref: i }, r) })), ItemSlot: A.forwardRef(((e, t) => { const { scope: n, children: r, ...i } = e, a = A.useRef(null), c = Do(t, a), u = o(s, n); return A.useEffect((() => (u.itemMap.set(a, { ref: a, ...i }), () => { u.itemMap.delete(a) }))), A.createElement(Lo, { [l]: "", ref: c }, r) })) }, function (t) { const n = o(e + "CollectionConsumer", t), r = A.useCallback((() => { const e = n.collectionRef.current; if (!e) return []; const t = Array.from(e.querySelectorAll(`[${l}]`)), r = Array.from(n.itemMap.values()).sort(((e, n) => t.indexOf(e.ref.current) - t.indexOf(n.ref.current))); return r }), [n.collectionRef, n.itemMap]); return r }, r] } function jo(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } function Uo(...e) { return (0, A.useCallback)(jo(...e), e) } function Vo(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } const Ko = (0, A.createContext)(void 0); function Wo(e) { const t = (0, A.useContext)(Ko); return e || t || "ltr" } const Yo = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(Xo); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(Go, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(Go, bo({}, r, { ref: t }), n) })); Yo.displayName = "Slot"; const Go = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ..._o(r, n.props), ref: jo(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); Go.displayName = "SlotClone"; const Zo = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function Xo(e) { return (0, A.isValidElement)(e) && e.type === Zo } function _o(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const Qo = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? Yo : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}); function qo(e, t) { e && (0, Co.flushSync)((() => e.dispatchEvent(t))) } function Jo(e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) } const $o = "dismissableLayer.update"; let ea; const ta = (0, A.createContext)({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), na = (0, A.forwardRef)(((e, t) => { const { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: i, onFocusOutside: o, onInteractOutside: a, onDismiss: s, ...l } = e, c = (0, A.useContext)(ta), [u, d] = (0, A.useState)(null), [, p] = (0, A.useState)({}), h = Uo(t, (e => d(e))), f = Array.from(c.layers), [m] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), g = f.indexOf(m), v = u ? f.indexOf(u) : -1, y = c.layersWithOutsidePointerEventsDisabled.size > 0, b = v >= g, w = function (e) { const t = Jo(e), n = (0, A.useRef)(!1), r = (0, A.useRef)((() => { })); return (0, A.useEffect)((() => { const e = e => { if (e.target && !n.current) { const i = { originalEvent: e }; function o() { ia("dismissableLayer.pointerDownOutside", t, i, { discrete: !0 }) } "touch" === e.pointerType ? (document.removeEventListener("click", r.current), r.current = o, document.addEventListener("click", r.current, { once: !0 })) : o() } n.current = !1 }, i = window.setTimeout((() => { document.addEventListener("pointerdown", e) }), 0); return () => { window.clearTimeout(i), document.removeEventListener("pointerdown", e), document.removeEventListener("click", r.current) } }), [t]), { onPointerDownCapture: () => n.current = !0 } }((e => { const t = e.target, n = [...c.branches].some((e => e.contains(t))); b && !n && (null == i || i(e), null == a || a(e), e.defaultPrevented || null == s || s()) })), E = function (e) { const t = Jo(e), n = (0, A.useRef)(!1); return (0, A.useEffect)((() => { const e = e => { e.target && !n.current && ia("dismissableLayer.focusOutside", t, { originalEvent: e }, { discrete: !1 }) }; return document.addEventListener("focusin", e), () => document.removeEventListener("focusin", e) }), [t]), { onFocusCapture: () => n.current = !0, onBlurCapture: () => n.current = !1 } }((e => { const t = e.target;[...c.branches].some((e => e.contains(t))) || (null == o || o(e), null == a || a(e), e.defaultPrevented || null == s || s()) })); return function (e) { const t = Jo(e); (0, A.useEffect)((() => { const e = e => { "Escape" === e.key && t(e) }; return document.addEventListener("keydown", e), () => document.removeEventListener("keydown", e) }), [t]) }((e => { v === c.layers.size - 1 && (null == r || r(e), !e.defaultPrevented && s && (e.preventDefault(), s())) })), (0, A.useEffect)((() => { if (u) return n && (0 === c.layersWithOutsidePointerEventsDisabled.size && (ea = document.body.style.pointerEvents, document.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), ra(), () => { n && 1 === c.layersWithOutsidePointerEventsDisabled.size && (document.body.style.pointerEvents = ea) } }), [u, n, c]), (0, A.useEffect)((() => () => { u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), ra()) }), [u, c]), (0, A.useEffect)((() => { const e = () => p({}); return document.addEventListener($o, e), () => document.removeEventListener($o, e) }), []), (0, A.createElement)(Qo.div, bo({}, l, { ref: h, style: { pointerEvents: y ? b ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: To(e.onFocusCapture, E.onFocusCapture), onBlurCapture: To(e.onBlurCapture, E.onBlurCapture), onPointerDownCapture: To(e.onPointerDownCapture, w.onPointerDownCapture) })) })); function ra() { const e = new CustomEvent($o); document.dispatchEvent(e) } function ia(e, t, n, { discrete: r }) { const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && i.addEventListener(e, t, { once: !0 }), r ? qo(i, o) : i.dispatchEvent(o) } let oa = 0; function aa() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e } const sa = "focusScope.autoFocusOnMount", la = "focusScope.autoFocusOnUnmount", ca = { bubbles: !1, cancelable: !0 }, ua = (0, A.forwardRef)(((e, t) => { const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...a } = e, [s, l] = (0, A.useState)(null), c = Jo(i), u = Jo(o), d = (0, A.useRef)(null), p = Uo(t, (e => l(e))), h = (0, A.useRef)({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; (0, A.useEffect)((() => { if (r) { function e(e) { if (h.paused || !s) return; const t = e.target; s.contains(t) ? d.current = t : fa(d.current, { select: !0 }) } function t(e) { !h.paused && s && (s.contains(e.relatedTarget) || fa(d.current, { select: !0 })) } return document.addEventListener("focusin", e), document.addEventListener("focusout", t), () => { document.removeEventListener("focusin", e), document.removeEventListener("focusout", t) } } }), [r, s, h.paused]), (0, A.useEffect)((() => { if (s) { ma.add(h); const e = document.activeElement; if (!s.contains(e)) { const t = new CustomEvent(sa, ca); s.addEventListener(sa, c), s.dispatchEvent(t), t.defaultPrevented || (function (e, { select: t = !1 } = {}) { const n = document.activeElement; for (const r of e) if (fa(r, { select: t }), document.activeElement !== n) return }(da(s).filter((e => "A" !== e.tagName)), { select: !0 }), document.activeElement === e && fa(s)) } return () => { s.removeEventListener(sa, c), setTimeout((() => { const t = new CustomEvent(la, ca); s.addEventListener(la, u), s.dispatchEvent(t), t.defaultPrevented || fa(null != e ? e : document.body, { select: !0 }), s.removeEventListener(la, u), ma.remove(h) }), 0) } } }), [s, c, u, h]); const f = (0, A.useCallback)((e => { if (!n && !r) return; if (h.paused) return; const t = "Tab" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey, i = document.activeElement; if (t && i) { const t = e.currentTarget, [r, o] = function (e) { const t = da(e); return [pa(t, e), pa(t.reverse(), e)] }(t); r && o ? e.shiftKey || i !== o ? e.shiftKey && i === r && (e.preventDefault(), n && fa(o, { select: !0 })) : (e.preventDefault(), n && fa(r, { select: !0 })) : i === t && e.preventDefault() } }), [n, r, h.paused]); return (0, A.createElement)(Qo.div, bo({ tabIndex: -1 }, a, { ref: p, onKeyDown: f })) })); function da(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: e => { const t = "INPUT" === e.tagName && "hidden" === e.type; return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function pa(e, t) { for (const n of e) if (!ha(n, { upTo: t })) return n } function ha(e, { upTo: t }) { if ("hidden" === getComputedStyle(e).visibility) return !0; for (; e;) { if (void 0 !== t && e === t) return !1; if ("none" === getComputedStyle(e).display) return !0; e = e.parentElement } return !1 } function fa(e, { select: t = !1 } = {}) { if (e && e.focus) { const n = document.activeElement; e.focus({ preventScroll: !0 }), e !== n && function (e) { return e instanceof HTMLInputElement && "select" in e }(e) && t && e.select() } } const ma = function () { let e = []; return { add(t) { const n = e[0]; t !== n && (null == n || n.pause()), e = ga(e, t), e.unshift(t) }, remove(t) { var n; e = ga(e, t), null === (n = e[0]) || void 0 === n || n.resume() } } }(); function ga(e, t) { const n = [...e], r = n.indexOf(t); return -1 !== r && n.splice(r, 1), n } const va = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? A.useLayoutEffect : () => { }, ya = I["useId".toString()] || (() => { }); let ba = 0; function wa(e) { const [t, n] = A.useState(ya()); return va((() => { e || n((e => null != e ? e : String(ba++))) }), [e]), e || (t ? `radix-${t}` : "") } function Ea(e) { return e.split("-")[0] } function Ca(e) { return e.split("-")[1] } function Sa(e) { return ["top", "bottom"].includes(Ea(e)) ? "x" : "y" } function ka(e) { return "y" === e ? "height" : "width" } function xa(e, t, n) { let { reference: r, floating: i } = e; const o = r.x + r.width / 2 - i.width / 2, a = r.y + r.height / 2 - i.height / 2, s = Sa(t), l = ka(s), c = r[l] / 2 - i[l] / 2, u = "x" === s; let d; switch (Ea(t)) { case "top": d = { x: o, y: r.y - i.height }; break; case "bottom": d = { x: o, y: r.y + r.height }; break; case "right": d = { x: r.x + r.width, y: a }; break; case "left": d = { x: r.x - i.width, y: a }; break; default: d = { x: r.x, y: r.y } }switch (Ca(t)) { case "start": d[s] -= c * (n && u ? -1 : 1); break; case "end": d[s] += c * (n && u ? -1 : 1) }return d } function Aa(e) { return "number" != typeof e ? function (e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } }(e) : { top: e, right: e, bottom: e, left: e } } function Ia(e) { return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height } } async function Pa(e, t) { var n; void 0 === t && (t = {}); const { x: r, y: i, platform: o, rects: a, elements: s, strategy: l } = e, { boundary: c = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: p = !1, padding: h = 0 } = t, f = Aa(h), m = s[p ? "floating" === d ? "reference" : "floating" : d], g = Ia(await o.getClippingRect({ element: null == (n = await (null == o.isElement ? void 0 : o.isElement(m))) || n ? m : m.contextElement || await (null == o.getDocumentElement ? void 0 : o.getDocumentElement(s.floating)), boundary: c, rootBoundary: u, strategy: l })), v = Ia(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: "floating" === d ? { ...a.floating, x: r, y: i } : a.reference, offsetParent: await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(s.floating)), strategy: l }) : a[d]); return { top: g.top - v.top + f.top, bottom: v.bottom - g.bottom + f.bottom, left: g.left - v.left + f.left, right: v.right - g.right + f.right } } const Ma = Math.min, Ta = Math.max; function Ra(e, t, n) { return Ta(e, Ma(t, n)) } const Ba = e => ({ name: "arrow", options: e, async fn(t) { const { element: n, padding: r = 0 } = null != e ? e : {}, { x: i, y: o, placement: a, rects: s, platform: l } = t; if (null == n) return {}; const c = Aa(r), u = { x: i, y: o }, d = Sa(a), p = Ca(a), h = ka(d), f = await l.getDimensions(n), m = "y" === d ? "top" : "left", g = "y" === d ? "bottom" : "right", v = s.reference[h] + s.reference[d] - u[d] - s.floating[h], y = u[d] - s.reference[d], b = await (null == l.getOffsetParent ? void 0 : l.getOffsetParent(n)); let w = b ? "y" === d ? b.clientHeight || 0 : b.clientWidth || 0 : 0; 0 === w && (w = s.floating[h]); const E = v / 2 - y / 2, C = c[m], S = w - f[h] - c[g], k = w / 2 - f[h] / 2 + E, x = Ra(C, k, S), A = ("start" === p ? c[m] : c[g]) > 0 && k !== x && s.reference[h] <= s.floating[h]; return { [d]: u[d] - (A ? k < C ? C - k : S - k : 0), data: { [d]: x, centerOffset: k - x } } } }), Da = { left: "right", right: "left", bottom: "top", top: "bottom" }; function La(e) { return e.replace(/left|right|bottom|top/g, (e => Da[e])) } function Oa(e, t, n) { void 0 === n && (n = !1); const r = Ca(e), i = Sa(e), o = ka(i); let a = "x" === i ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top"; return t.reference[o] > t.floating[o] && (a = La(a)), { main: a, cross: La(a) } } const Fa = { start: "end", end: "start" }; function za(e) { return e.replace(/start|end/g, (e => Fa[e])) } const Ha = ["top", "right", "bottom", "left"], Na = (Ha.reduce(((e, t) => e.concat(t, t + "-start", t + "-end")), []), function (e) { return void 0 === e && (e = {}), { name: "flip", options: e, async fn(t) { var n; const { placement: r, middlewareData: i, rects: o, initialPlacement: a, platform: s, elements: l } = t, { mainAxis: c = !0, crossAxis: u = !0, fallbackPlacements: d, fallbackStrategy: p = "bestFit", flipAlignment: h = !0, ...f } = e, m = Ea(r), g = d || (m !== a && h ? function (e) { const t = La(e); return [za(e), t, za(t)] }(a) : [La(a)]), v = [a, ...g], y = await Pa(t, f), b = []; let w = (null == (n = i.flip) ? void 0 : n.overflows) || []; if (c && b.push(y[m]), u) { const { main: e, cross: t } = Oa(r, o, await (null == s.isRTL ? void 0 : s.isRTL(l.floating))); b.push(y[e], y[t]) } if (w = [...w, { placement: r, overflows: b }], !b.every((e => e <= 0))) { var E, C; const e = (null != (E = null == (C = i.flip) ? void 0 : C.index) ? E : 0) + 1, t = v[e]; if (t) return { data: { index: e, overflows: w }, reset: { placement: t } }; let n = "bottom"; switch (p) { case "bestFit": { var S; const e = null == (S = w.map((e => [e, e.overflows.filter((e => e > 0)).reduce(((e, t) => e + t), 0)])).sort(((e, t) => e[1] - t[1]))[0]) ? void 0 : S[0].placement; e && (n = e); break } case "initialPlacement": n = a }if (r !== n) return { reset: { placement: n } } } return {} } } }); function ja(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function Ua(e) { return Ha.some((t => e[t] >= 0)) } const Va = function (e) { let { strategy: t = "referenceHidden", ...n } = void 0 === e ? {} : e; return { name: "hide", async fn(e) { const { rects: r } = e; switch (t) { case "referenceHidden": { const t = ja(await Pa(e, { ...n, elementContext: "reference" }), r.reference); return { data: { referenceHiddenOffsets: t, referenceHidden: Ua(t) } } } case "escaped": { const t = ja(await Pa(e, { ...n, altBoundary: !0 }), r.floating); return { data: { escapedOffsets: t, escaped: Ua(t) } } } default: return {} } } } }, Ka = function (e) { return void 0 === e && (e = 0), { name: "offset", options: e, async fn(t) { const { x: n, y: r } = t, i = await async function (e, t) { const { placement: n, platform: r, elements: i } = e, o = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)), a = Ea(n), s = Ca(n), l = "x" === Sa(n), c = ["left", "top"].includes(a) ? -1 : 1, u = o && l ? -1 : 1, d = "function" == typeof t ? t(e) : t; let { mainAxis: p, crossAxis: h, alignmentAxis: f } = "number" == typeof d ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d }; return s && "number" == typeof f && (h = "end" === s ? -1 * f : f), l ? { x: h * u, y: p * c } : { x: p * c, y: h * u } }(t, e); return { x: n + i.x, y: r + i.y, data: i } } } }; function Wa(e) { return "x" === e ? "y" : "x" } const Ya = function (e) { return void 0 === e && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: i } = t, { mainAxis: o = !0, crossAxis: a = !1, limiter: s = { fn: e => { let { x: t, y: n } = e; return { x: t, y: n } } }, ...l } = e, c = { x: n, y: r }, u = await Pa(t, l), d = Sa(Ea(i)), p = Wa(d); let h = c[d], f = c[p]; if (o) { const e = "y" === d ? "bottom" : "right"; h = Ra(h + u["y" === d ? "top" : "left"], h, h - u[e]) } if (a) { const e = "y" === p ? "bottom" : "right"; f = Ra(f + u["y" === p ? "top" : "left"], f, f - u[e]) } const m = s.fn({ ...t, [d]: h, [p]: f }); return { ...m, data: { x: m.x - n, y: m.y - r } } } } }, Ga = function (e) { return void 0 === e && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: i, rects: o, middlewareData: a } = t, { offset: s = 0, mainAxis: l = !0, crossAxis: c = !0 } = e, u = { x: n, y: r }, d = Sa(i), p = Wa(d); let h = u[d], f = u[p]; const m = "function" == typeof s ? s({ ...o, placement: i }) : s, g = "number" == typeof m ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m }; if (l) { const e = "y" === d ? "height" : "width", t = o.reference[d] - o.floating[e] + g.mainAxis, n = o.reference[d] + o.reference[e] - g.mainAxis; h < t ? h = t : h > n && (h = n) } if (c) { var v, y, b, w; const e = "y" === d ? "width" : "height", t = ["top", "left"].includes(Ea(i)), n = o.reference[p] - o.floating[e] + (t && null != (v = null == (y = a.offset) ? void 0 : y[p]) ? v : 0) + (t ? 0 : g.crossAxis), r = o.reference[p] + o.reference[e] + (t ? 0 : null != (b = null == (w = a.offset) ? void 0 : w[p]) ? b : 0) - (t ? g.crossAxis : 0); f < n ? f = n : f > r && (f = r) } return { [d]: h, [p]: f } } } }; function Za(e) { return e && e.document && e.location && e.alert && e.setInterval } function Xa(e) { if (null == e) return window; if (!Za(e)) { const t = e.ownerDocument; return t && t.defaultView || window } return e } function _a(e) { return Xa(e).getComputedStyle(e) } function Qa(e) { return Za(e) ? "" : e ? (e.nodeName || "").toLowerCase() : "" } function qa() { const e = navigator.userAgentData; return null != e && e.brands ? e.brands.map((e => e.brand + "/" + e.version)).join(" ") : navigator.userAgent } function Ja(e) { return e instanceof Xa(e).HTMLElement } function $a(e) { return e instanceof Xa(e).Element } function es(e) { return "undefined" != typeof ShadowRoot && (e instanceof Xa(e).ShadowRoot || e instanceof ShadowRoot) } function ts(e) { const { overflow: t, overflowX: n, overflowY: r } = _a(e); return /auto|scroll|overlay|hidden/.test(t + r + n) } function ns(e) { return ["table", "td", "th"].includes(Qa(e)) } function rs(e) { const t = /firefox/i.test(qa()), n = _a(e); return "none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || ["transform", "perspective"].includes(n.willChange) || t && "filter" === n.willChange || t && !!n.filter && "none" !== n.filter } function is() { return !/^((?!chrome|android).)*safari/i.test(qa()) } const os = Math.min, as = Math.max, ss = Math.round; function ls(e, t, n) { var r, i, o, a; void 0 === t && (t = !1), void 0 === n && (n = !1); const s = e.getBoundingClientRect(); let l = 1, c = 1; t && Ja(e) && (l = e.offsetWidth > 0 && ss(s.width) / e.offsetWidth || 1, c = e.offsetHeight > 0 && ss(s.height) / e.offsetHeight || 1); const u = $a(e) ? Xa(e) : window, d = !is() && n, p = (s.left + (d && null != (r = null == (i = u.visualViewport) ? void 0 : i.offsetLeft) ? r : 0)) / l, h = (s.top + (d && null != (o = null == (a = u.visualViewport) ? void 0 : a.offsetTop) ? o : 0)) / c, f = s.width / l, m = s.height / c; return { width: f, height: m, top: h, right: p + f, bottom: h + m, left: p, x: p, y: h } } function cs(e) { return (t = e, (t instanceof Xa(t).Node ? e.ownerDocument : e.document) || window.document).documentElement; var t } function us(e) { return $a(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function ds(e) { return ls(cs(e)).left + us(e).scrollLeft } function ps(e, t, n) { const r = Ja(t), i = cs(t), o = ls(e, r && function (e) { const t = ls(e); return ss(t.width) !== e.offsetWidth || ss(t.height) !== e.offsetHeight }(t), "fixed" === n); let a = { scrollLeft: 0, scrollTop: 0 }; const s = { x: 0, y: 0 }; if (r || !r && "fixed" !== n) if (("body" !== Qa(t) || ts(i)) && (a = us(t)), Ja(t)) { const e = ls(t, !0); s.x = e.x + t.clientLeft, s.y = e.y + t.clientTop } else i && (s.x = ds(i)); return { x: o.left + a.scrollLeft - s.x, y: o.top + a.scrollTop - s.y, width: o.width, height: o.height } } function hs(e) { return "html" === Qa(e) ? e : e.assignedSlot || e.parentNode || (es(e) ? e.host : null) || cs(e) } function fs(e) { return Ja(e) && "fixed" !== getComputedStyle(e).position ? e.offsetParent : null } function ms(e) { const t = Xa(e); let n = fs(e); for (; n && ns(n) && "static" === getComputedStyle(n).position;)n = fs(n); return n && ("html" === Qa(n) || "body" === Qa(n) && "static" === getComputedStyle(n).position && !rs(n)) ? t : n || function (e) { let t = hs(e); for (es(t) && (t = t.host); Ja(t) && !["html", "body"].includes(Qa(t));) { if (rs(t)) return t; t = t.parentNode } return null }(e) || t } function gs(e) { if (Ja(e)) return { width: e.offsetWidth, height: e.offsetHeight }; const t = ls(e); return { width: t.width, height: t.height } } function vs(e) { const t = hs(e); return ["html", "body", "#document"].includes(Qa(t)) ? e.ownerDocument.body : Ja(t) && ts(t) ? t : vs(t) } function ys(e, t) { var n; void 0 === t && (t = []); const r = vs(e), i = r === (null == (n = e.ownerDocument) ? void 0 : n.body), o = Xa(r), a = i ? [o].concat(o.visualViewport || [], ts(r) ? r : []) : r, s = t.concat(a); return i ? s : s.concat(ys(a)) } function bs(e, t, n) { return "viewport" === t ? Ia(function (e, t) { const n = Xa(e), r = cs(e), i = n.visualViewport; let o = r.clientWidth, a = r.clientHeight, s = 0, l = 0; if (i) { o = i.width, a = i.height; const e = is(); (e || !e && "fixed" === t) && (s = i.offsetLeft, l = i.offsetTop) } return { width: o, height: a, x: s, y: l } }(e, n)) : $a(t) ? function (e, t) { const n = ls(e, !1, "fixed" === t), r = n.top + e.clientTop, i = n.left + e.clientLeft; return { top: r, left: i, x: i, y: r, right: i + e.clientWidth, bottom: r + e.clientHeight, width: e.clientWidth, height: e.clientHeight } }(t, n) : Ia(function (e) { var t; const n = cs(e), r = us(e), i = null == (t = e.ownerDocument) ? void 0 : t.body, o = as(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = as(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0); let s = -r.scrollLeft + ds(e); const l = -r.scrollTop; return "rtl" === _a(i || n).direction && (s += as(n.clientWidth, i ? i.clientWidth : 0) - o), { width: o, height: a, x: s, y: l } }(cs(e))) } function ws(e) { const t = ys(e), n = ["absolute", "fixed"].includes(_a(e).position) && Ja(e) ? ms(e) : e; return $a(n) ? t.filter((e => $a(e) && function (e, t) { const n = null == t.getRootNode ? void 0 : t.getRootNode(); if (e.contains(t)) return !0; if (n && es(n)) { let n = t; do { if (n && e === n) return !0; n = n.parentNode || n.host } while (n) } return !1 }(e, n) && "body" !== Qa(e))) : [] } const Es = { getClippingRect: function (e) { let { element: t, boundary: n, rootBoundary: r, strategy: i } = e; const o = [..."clippingAncestors" === n ? ws(t) : [].concat(n), r], a = o[0], s = o.reduce(((e, n) => { const r = bs(t, n, i); return e.top = as(r.top, e.top), e.right = os(r.right, e.right), e.bottom = os(r.bottom, e.bottom), e.left = as(r.left, e.left), e }), bs(t, a, i)); return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top } }, convertOffsetParentRelativeRectToViewportRelativeRect: function (e) { let { rect: t, offsetParent: n, strategy: r } = e; const i = Ja(n), o = cs(n); if (n === o) return t; let a = { scrollLeft: 0, scrollTop: 0 }; const s = { x: 0, y: 0 }; if ((i || !i && "fixed" !== r) && (("body" !== Qa(n) || ts(o)) && (a = us(n)), Ja(n))) { const e = ls(n, !0); s.x = e.x + n.clientLeft, s.y = e.y + n.clientTop } return { ...t, x: t.x - a.scrollLeft + s.x, y: t.y - a.scrollTop + s.y } }, isElement: $a, getDimensions: gs, getOffsetParent: ms, getDocumentElement: cs, getElementRects: e => { let { reference: t, floating: n, strategy: r } = e; return { reference: ps(t, ms(n), r), floating: { ...gs(n), x: 0, y: 0 } } }, getClientRects: e => Array.from(e.getClientRects()), isRTL: e => "rtl" === _a(e).direction }; function Cs(e, t, n, r) { void 0 === r && (r = {}); const { ancestorScroll: i = !0, ancestorResize: o = !0, elementResize: a = !0, animationFrame: s = !1 } = r, l = i && !s, c = o && !s, u = l || c ? [...$a(e) ? ys(e) : [], ...ys(t)] : []; u.forEach((e => { l && e.addEventListener("scroll", n, { passive: !0 }), c && e.addEventListener("resize", n) })); let d, p = null; if (a) { let r = !0; p = new ResizeObserver((() => { r || n(), r = !1 })), $a(e) && !s && p.observe(e), p.observe(t) } let h = s ? ls(e) : null; return s && function t() { const r = ls(e); !h || r.x === h.x && r.y === h.y && r.width === h.width && r.height === h.height || n(), h = r, d = requestAnimationFrame(t) }(), n(), () => { var e; u.forEach((e => { l && e.removeEventListener("scroll", n), c && e.removeEventListener("resize", n) })), null == (e = p) || e.disconnect(), p = null, s && cancelAnimationFrame(d) } } var Ss = "undefined" != typeof document ? A.useLayoutEffect : A.useEffect; function ks(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if ("function" == typeof e && e.toString() === t.toString()) return !0; let n, r, i; if (e && t && "object" == typeof e) { if (Array.isArray(e)) { if (n = e.length, n != t.length) return !1; for (r = n; 0 != r--;)if (!ks(e[r], t[r])) return !1; return !0 } if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length) return !1; for (r = n; 0 != r--;)if (!Object.prototype.hasOwnProperty.call(t, i[r])) return !1; for (r = n; 0 != r--;) { const n = i[r]; if (!("_owner" === n && e.$$typeof || ks(e[n], t[n]))) return !1 } return !0 } return e != e && t != t } function xs(e) { let { middleware: t, placement: n = "bottom", strategy: r = "absolute", whileElementsMounted: i } = void 0 === e ? {} : e; const o = A.useRef(null), a = A.useRef(null), s = function (e) { const t = A.useRef(e); return Ss((() => { t.current = e })), t }(i), l = A.useRef(null), [c, u] = A.useState({ x: null, y: null, strategy: r, placement: n, middlewareData: {} }), [d, p] = A.useState(t); ks(null == d ? void 0 : d.map((e => { let { options: t } = e; return t })), null == t ? void 0 : t.map((e => { let { options: t } = e; return t }))) || p(t); const h = A.useCallback((() => { o.current && a.current && ((e, t, n) => (async (e, t, n) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: o = [], platform: a } = n, s = await (null == a.isRTL ? void 0 : a.isRTL(t)); let l = await a.getElementRects({ reference: e, floating: t, strategy: i }), { x: c, y: u } = xa(l, r, s), d = r, p = {}, h = 0; for (let n = 0; n < o.length; n++) { const { name: f, fn: m } = o[n], { x: g, y: v, data: y, reset: b } = await m({ x: c, y: u, initialPlacement: r, placement: d, strategy: i, middlewareData: p, rects: l, platform: a, elements: { reference: e, floating: t } }); c = null != g ? g : c, u = null != v ? v : u, p = { ...p, [f]: { ...p[f], ...y } }, b && h <= 50 && (h++, "object" == typeof b && (b.placement && (d = b.placement), b.rects && (l = !0 === b.rects ? await a.getElementRects({ reference: e, floating: t, strategy: i }) : b.rects), ({ x: c, y: u } = xa(l, d, s))), n = -1) } return { x: c, y: u, placement: d, strategy: i, middlewareData: p } })(e, t, { platform: Es, ...n }))(o.current, a.current, { middleware: d, placement: n, strategy: r }).then((e => { f.current && Co.flushSync((() => { u(e) })) })) }), [d, n, r]); Ss((() => { f.current && h() }), [h]); const f = A.useRef(!1); Ss((() => (f.current = !0, () => { f.current = !1 })), []); const m = A.useCallback((() => { if ("function" == typeof l.current && (l.current(), l.current = null), o.current && a.current) if (s.current) { const e = s.current(o.current, a.current, h); l.current = e } else h() }), [h, s]), g = A.useCallback((e => { o.current = e, m() }), [m]), v = A.useCallback((e => { a.current = e, m() }), [m]), y = A.useMemo((() => ({ reference: o, floating: a })), []); return A.useMemo((() => ({ ...c, update: h, refs: y, reference: g, floating: v })), [c, h, y, g, v]) } const As = e => { const { element: t, padding: n } = e; return { name: "arrow", options: e, fn(e) { return r = t, Object.prototype.hasOwnProperty.call(r, "current") ? null != t.current ? Ba({ element: t.current, padding: n }).fn(e) : {} : t ? Ba({ element: t, padding: n }).fn(e) : {}; var r } } }; function Is(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } const Ps = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(Rs); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(Ms, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(Ms, bo({}, r, { ref: t }), n) })); Ps.displayName = "Slot"; const Ms = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...Bs(r, n.props), ref: Is(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); Ms.displayName = "SlotClone"; const Ts = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function Rs(e) { return (0, A.isValidElement)(e) && e.type === Ts } function Bs(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const Ds = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? Ps : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}), Ls = (0, A.forwardRef)(((e, t) => { const { children: n, width: r = 10, height: i = 5, ...o } = e; return (0, A.createElement)(Ds.svg, bo({}, o, { ref: t, width: r, height: i, viewBox: "0 0 30 10", preserveAspectRatio: "none" }), e.asChild ? n : (0, A.createElement)("polygon", { points: "0,0 30,0 15,10" })) })); function Os(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } function Fs(...e) { return (0, A.useCallback)(Os(...e), e) } function zs(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } const Hs = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(Us); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(Ns, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(Ns, bo({}, r, { ref: t }), n) })); Hs.displayName = "Slot"; const Ns = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...Vs(r, n.props), ref: Os(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); Ns.displayName = "SlotClone"; const js = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function Us(e) { return (0, A.isValidElement)(e) && e.type === js } function Vs(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const Ks = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? Hs : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}), Ws = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? A.useLayoutEffect : () => { }, Ys = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? A.useLayoutEffect : () => { }, Gs = "Popper", [Zs, Xs] = function (e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, zs(r, ...t)] }(Gs), [_s, Qs] = Zs(Gs), qs = (0, A.forwardRef)(((e, t) => { const { __scopePopper: n, virtualRef: r, ...i } = e, o = Qs("PopperAnchor", n), a = (0, A.useRef)(null), s = Fs(t, a); return (0, A.useEffect)((() => { o.onAnchorChange((null == r ? void 0 : r.current) || a.current) })), r ? null : (0, A.createElement)(Ks.div, bo({}, i, { ref: s })) })), Js = "PopperContent", [$s, el] = Zs(Js), [tl, nl] = Zs(Js, { hasParent: !1, positionUpdateFns: new Set }), rl = (0, A.forwardRef)(((e, t) => { var n, r, i, o, a, s, l, c; const { __scopePopper: u, side: d = "bottom", sideOffset: p = 0, align: h = "center", alignOffset: f = 0, arrowPadding: m = 0, collisionBoundary: g = [], collisionPadding: v = 0, sticky: y = "partial", hideWhenDetached: b = !1, avoidCollisions: w = !0, ...E } = e, C = Qs(Js, u), [S, k] = (0, A.useState)(null), x = Fs(t, (e => k(e))), [I, P] = (0, A.useState)(null), M = function (e) { const [t, n] = (0, A.useState)(void 0); return Ys((() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const t = new ResizeObserver((t => { if (!Array.isArray(t)) return; if (!t.length) return; const r = t[0]; let i, o; if ("borderBoxSize" in r) { const e = r.borderBoxSize, t = Array.isArray(e) ? e[0] : e; i = t.inlineSize, o = t.blockSize } else i = e.offsetWidth, o = e.offsetHeight; n({ width: i, height: o }) })); return t.observe(e, { box: "border-box" }), () => t.unobserve(e) } n(void 0) }), [e]), t }(I), T = null !== (n = null == M ? void 0 : M.width) && void 0 !== n ? n : 0, R = null !== (r = null == M ? void 0 : M.height) && void 0 !== r ? r : 0, B = d + ("center" !== h ? "-" + h : ""), D = "number" == typeof v ? v : { top: 0, right: 0, bottom: 0, left: 0, ...v }, L = Array.isArray(g) ? g : [g], O = L.length > 0, F = { padding: D, boundary: L.filter(al), altBoundary: O }, { reference: z, floating: H, strategy: N, x: j, y: U, placement: V, middlewareData: K, update: W } = xs({ strategy: "fixed", placement: B, whileElementsMounted: Cs, middleware: [Ka({ mainAxis: p + R, alignmentAxis: f }), w ? Ya({ mainAxis: !0, crossAxis: !1, limiter: "partial" === y ? Ga() : void 0, ...F }) : void 0, I ? As({ element: I, padding: m }) : void 0, w ? Na({ ...F }) : void 0, sl({ arrowWidth: T, arrowHeight: R }), b ? Va({ strategy: "referenceHidden" }) : void 0].filter(ol) }); Ws((() => { z(C.anchor) }), [z, C.anchor]); const Y = null !== j && null !== U, [G, Z] = ll(V), X = null === (i = K.arrow) || void 0 === i ? void 0 : i.x, _ = null === (o = K.arrow) || void 0 === o ? void 0 : o.y, Q = 0 !== (null === (a = K.arrow) || void 0 === a ? void 0 : a.centerOffset), [q, J] = (0, A.useState)(); Ws((() => { S && J(window.getComputedStyle(S).zIndex) }), [S]); const { hasParent: $, positionUpdateFns: ee } = nl(Js, u), te = !$; (0, A.useLayoutEffect)((() => { if (!te) return ee.add(W), () => { ee.delete(W) } }), [te, ee, W]), (0, A.useLayoutEffect)((() => { te && Y && Array.from(ee).reverse().forEach((e => requestAnimationFrame(e))) }), [te, Y, ee]); const ne = { "data-side": G, "data-align": Z, ...E, ref: x, style: { ...E.style, animation: Y ? void 0 : "none", opacity: null !== (s = K.hide) && void 0 !== s && s.referenceHidden ? 0 : void 0 } }; return (0, A.createElement)("div", { ref: H, "data-radix-popper-content-wrapper": "", style: { position: N, left: 0, top: 0, transform: Y ? `translate3d(${Math.round(j)}px, ${Math.round(U)}px, 0)` : "translate3d(0, -200%, 0)", minWidth: "max-content", zIndex: q, "--radix-popper-transform-origin": [null === (l = K.transformOrigin) || void 0 === l ? void 0 : l.x, null === (c = K.transformOrigin) || void 0 === c ? void 0 : c.y].join(" ") } }, (0, A.createElement)($s, { scope: u, placedSide: G, onArrowChange: P, arrowX: X, arrowY: _, shouldHideArrow: Q }, te ? (0, A.createElement)(tl, { scope: u, hasParent: !0, positionUpdateFns: ee }, (0, A.createElement)(Ks.div, ne)) : (0, A.createElement)(Ks.div, ne))) })), il = { top: "bottom", right: "left", bottom: "top", left: "right" }; function ol(e) { return void 0 !== e } function al(e) { return null !== e } const sl = e => ({ name: "transformOrigin", options: e, fn(t) { var n, r, i, o, a; const { placement: s, rects: l, middlewareData: c } = t, u = 0 !== (null === (n = c.arrow) || void 0 === n ? void 0 : n.centerOffset), d = u ? 0 : e.arrowWidth, p = u ? 0 : e.arrowHeight, [h, f] = ll(s), m = { start: "0%", center: "50%", end: "100%" }[f], g = (null !== (r = null === (i = c.arrow) || void 0 === i ? void 0 : i.x) && void 0 !== r ? r : 0) + d / 2, v = (null !== (o = null === (a = c.arrow) || void 0 === a ? void 0 : a.y) && void 0 !== o ? o : 0) + p / 2; let y = "", b = ""; return "bottom" === h ? (y = u ? m : `${g}px`, b = -p + "px") : "top" === h ? (y = u ? m : `${g}px`, b = `${l.floating.height + p}px`) : "right" === h ? (y = -p + "px", b = u ? m : `${v}px`) : "left" === h && (y = `${l.floating.width + p}px`, b = u ? m : `${v}px`), { data: { x: y, y: b } } } }); function ll(e) { const [t, n = "center"] = e.split("-"); return [t, n] } const cl = e => { const { __scopePopper: t, children: n } = e, [r, i] = (0, A.useState)(null); return (0, A.createElement)(_s, { scope: t, anchor: r, onAnchorChange: i }, n) }, ul = qs, dl = rl, pl = (0, A.forwardRef)((function (e, t) { const { __scopePopper: n, ...r } = e, i = el("PopperArrow", n), o = il[i.placedSide]; return (0, A.createElement)("span", { ref: i.onArrowChange, style: { position: "absolute", left: i.arrowX, top: i.arrowY, [o]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[i.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[i.placedSide], visibility: i.shouldHideArrow ? "hidden" : void 0 } }, (0, A.createElement)(Ls, bo({}, r, { ref: t, style: { ...r.style, display: "block" } }))) })), hl = (0, A.forwardRef)(((e, t) => { var n; const { container: r = (null === globalThis || void 0 === globalThis || null === (n = globalThis.document) || void 0 === n ? void 0 : n.body), ...i } = e; return r ? Co.createPortal((0, A.createElement)(Qo.div, bo({}, i, { ref: t })), r) : null })), fl = e => { const { present: t, children: n } = e, r = function (e) { const [t, n] = (0, A.useState)(), r = (0, A.useRef)({}), i = (0, A.useRef)(e), o = (0, A.useRef)("none"), a = e ? "mounted" : "unmounted", [s, l] = function (e, t) { return (0, A.useReducer)(((e, n) => { const r = t[e][n]; return null != r ? r : e }), e) }(a, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return (0, A.useEffect)((() => { const e = ml(r.current); o.current = "mounted" === s ? e : "none" }), [s]), va((() => { const t = r.current, n = i.current; if (n !== e) { const r = o.current, a = ml(t); e ? l("MOUNT") : "none" === a || "none" === (null == t ? void 0 : t.display) ? l("UNMOUNT") : l(n && r !== a ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e } }), [e, l]), va((() => { if (t) { const e = e => { const n = ml(r.current).includes(e.animationName); e.target === t && n && (0, Co.flushSync)((() => l("ANIMATION_END"))) }, n = e => { e.target === t && (o.current = ml(r.current)) }; return t.addEventListener("animationstart", n), t.addEventListener("animationcancel", e), t.addEventListener("animationend", e), () => { t.removeEventListener("animationstart", n), t.removeEventListener("animationcancel", e), t.removeEventListener("animationend", e) } } l("ANIMATION_END") }), [t, l]), { isPresent: ["mounted", "unmountSuspended"].includes(s), ref: (0, A.useCallback)((e => { e && (r.current = getComputedStyle(e)), n(e) }), []) } }(t), i = "function" == typeof n ? n({ present: r.isPresent }) : A.Children.only(n), o = Uo(r.ref, i.ref); return "function" == typeof n || r.isPresent ? (0, A.cloneElement)(i, { ref: o }) : null }; function ml(e) { return (null == e ? void 0 : e.animationName) || "none" } function gl(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (r) { if (null == e || e(r), !1 === n || !r.defaultPrevented) return null == t ? void 0 : t(r) } } function vl(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } function yl(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } fl.displayName = "Presence"; const bl = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? A.useLayoutEffect : () => { }, wl = I["useId".toString()] || (() => { }); let El = 0; const Cl = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(xl); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(Sl, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(Sl, bo({}, r, { ref: t }), n) })); Cl.displayName = "Slot"; const Sl = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...Al(r, n.props), ref: vl(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); Sl.displayName = "SlotClone"; const kl = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function xl(e) { return (0, A.isValidElement)(e) && e.type === kl } function Al(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const Il = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? Cl : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}); function Pl({ prop: e, defaultProp: t, onChange: n = (() => { }) }) { const [r, i] = function ({ defaultProp: e, onChange: t }) { const n = (0, A.useState)(e), [r] = n, i = (0, A.useRef)(r), o = Jo(t); return (0, A.useEffect)((() => { i.current !== r && (o(r), i.current = r) }), [r, i, o]), n }({ defaultProp: t, onChange: n }), o = void 0 !== e, a = o ? e : r, s = Jo(n); return [a, (0, A.useCallback)((t => { if (o) { const n = "function" == typeof t ? t(e) : t; n !== e && s(n) } else i(t) }), [o, e, i, s])] } const Ml = "rovingFocusGroup.onEntryFocus", Tl = { bubbles: !1, cancelable: !0 }, Rl = "RovingFocusGroup", [Bl, Dl, Ll] = No(Rl), [Ol, Fl] = function (e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, yl(r, ...t)] }(Rl, [Ll]), [zl, Hl] = Ol(Rl), Nl = (0, A.forwardRef)(((e, t) => (0, A.createElement)(Bl.Provider, { scope: e.__scopeRovingFocusGroup }, (0, A.createElement)(Bl.Slot, { scope: e.__scopeRovingFocusGroup }, (0, A.createElement)(jl, bo({}, e, { ref: t })))))), jl = (0, A.forwardRef)(((e, t) => { const { __scopeRovingFocusGroup: n, orientation: r, loop: i = !1, dir: o, currentTabStopId: a, defaultCurrentTabStopId: s, onCurrentTabStopIdChange: l, onEntryFocus: c, ...u } = e, d = (0, A.useRef)(null), p = function (...e) { return (0, A.useCallback)(vl(...e), e) }(t, d), h = Wo(o), [f = null, m] = Pl({ prop: a, defaultProp: s, onChange: l }), [g, v] = (0, A.useState)(!1), y = Jo(c), b = Dl(n), w = (0, A.useRef)(!1); return (0, A.useEffect)((() => { const e = d.current; if (e) return e.addEventListener(Ml, y), () => e.removeEventListener(Ml, y) }), [y]), (0, A.createElement)(zl, { scope: n, orientation: r, dir: h, loop: i, currentTabStopId: f, onItemFocus: (0, A.useCallback)((e => m(e)), [m]), onItemShiftTab: (0, A.useCallback)((() => v(!0)), []) }, (0, A.createElement)(Il.div, bo({ tabIndex: g ? -1 : 0, "data-orientation": r }, u, { ref: p, style: { outline: "none", ...e.style }, onMouseDown: gl(e.onMouseDown, (() => { w.current = !0 })), onFocus: gl(e.onFocus, (e => { const t = !w.current; if (e.target === e.currentTarget && t && !g) { const t = new CustomEvent(Ml, Tl); if (e.currentTarget.dispatchEvent(t), !t.defaultPrevented) { const e = b().filter((e => e.focusable)); Kl([e.find((e => e.active)), e.find((e => e.id === f)), ...e].filter(Boolean).map((e => e.ref.current))) } } w.current = !1 })), onBlur: gl(e.onBlur, (() => v(!1))) }))) })), Ul = (0, A.forwardRef)(((e, t) => { const { __scopeRovingFocusGroup: n, focusable: r = !0, active: i = !1, ...o } = e, a = function (e) { const [t, n] = A.useState(wl()); return bl((() => { n((e => null != e ? e : String(El++))) }), [e]), t ? `radix-${t}` : "" }(), s = Hl("RovingFocusGroupItem", n), l = s.currentTabStopId === a, c = Dl(n); return (0, A.createElement)(Bl.ItemSlot, { scope: n, id: a, focusable: r, active: i }, (0, A.createElement)(Il.span, bo({ tabIndex: l ? 0 : -1, "data-orientation": s.orientation }, o, { ref: t, onMouseDown: gl(e.onMouseDown, (e => { r ? s.onItemFocus(a) : e.preventDefault() })), onFocus: gl(e.onFocus, (() => s.onItemFocus(a))), onKeyDown: gl(e.onKeyDown, (e => { if ("Tab" === e.key && e.shiftKey) return void s.onItemShiftTab(); if (e.target !== e.currentTarget) return; const t = function (e, t, n) { const r = function (e, t) { return "rtl" !== t ? e : "ArrowLeft" === e ? "ArrowRight" : "ArrowRight" === e ? "ArrowLeft" : e }(e.key, n); return "vertical" === t && ["ArrowLeft", "ArrowRight"].includes(r) || "horizontal" === t && ["ArrowUp", "ArrowDown"].includes(r) ? void 0 : Vl[r] }(e, s.orientation, s.dir); if (void 0 !== t) { e.preventDefault(); let i = c().filter((e => e.focusable)).map((e => e.ref.current)); if ("last" === t) i.reverse(); else if ("prev" === t || "next" === t) { "prev" === t && i.reverse(); const o = i.indexOf(e.currentTarget); i = s.loop ? (r = o + 1, (n = i).map(((e, t) => n[(r + t) % n.length]))) : i.slice(o + 1) } setTimeout((() => Kl(i))) } var n, r })) }))) })), Vl = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }; function Kl(e) { const t = document.activeElement; for (const n of e) { if (n === t) return; if (n.focus(), document.activeElement !== t) return } } const Wl = Nl, Yl = Ul; var Gl = new WeakMap, Zl = new WeakMap, Xl = {}, _l = 0, Ql = function (e) { return e && (e.host || Ql(e.parentNode)) }, ql = function (e, t, n) { void 0 === n && (n = "data-aria-hidden"); var r = Array.from(Array.isArray(e) ? e : [e]), i = t || function (e) { return "undefined" == typeof document ? null : (Array.isArray(e) ? e[0] : e).ownerDocument.body }(e); return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), function (e, t, n, r) { var i = function (e, t) { return t.map((function (t) { if (e.contains(t)) return t; var n = Ql(t); return n && e.contains(n) ? n : (console.error("aria-hidden", t, "in not contained inside", e, ". Doing nothing"), null) })).filter((function (e) { return Boolean(e) })) }(t, Array.isArray(e) ? e : [e]); Xl[n] || (Xl[n] = new WeakMap); var o = Xl[n], a = [], s = new Set, l = new Set(i), c = function (e) { e && !s.has(e) && (s.add(e), c(e.parentNode)) }; i.forEach(c); var u = function (e) { e && !l.has(e) && Array.prototype.forEach.call(e.children, (function (e) { if (s.has(e)) u(e); else { var t = e.getAttribute(r), i = null !== t && "false" !== t, l = (Gl.get(e) || 0) + 1, c = (o.get(e) || 0) + 1; Gl.set(e, l), o.set(e, c), a.push(e), 1 === l && i && Zl.set(e, !0), 1 === c && e.setAttribute(n, "true"), i || e.setAttribute(r, "true") } })) }; return u(t), s.clear(), _l++, function () { a.forEach((function (e) { var t = Gl.get(e) - 1, i = o.get(e) - 1; Gl.set(e, t), o.set(e, i), t || (Zl.has(e) || e.removeAttribute(r), Zl.delete(e)), i || e.removeAttribute(n) })), --_l || (Gl = new WeakMap, Gl = new WeakMap, Zl = new WeakMap, Xl = {}) } }(r, i, n, "aria-hidden")) : function () { return null } }, Jl = "right-scroll-bar-position", $l = "width-before-scroll-bar"; function ec(e, t) { return n = t || null, r = function (t) { return e.forEach((function (e) { return function (e, t) { return "function" == typeof e ? e(t) : e && (e.current = t), e }(e, t) })) }, (i = (0, A.useState)((function () { return { value: n, callback: r, facade: { get current() { return i.value }, set current(e) { var t = i.value; t !== e && (i.value = e, i.callback(e, t)) } } } }))[0]).callback = r, i.facade; var n, r, i } function tc(e) { return e } function nc(e) { void 0 === e && (e = {}); var t = function (e, t) { void 0 === t && (t = tc); var n = [], r = !1, i = { read: function () { if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return n.length ? n[n.length - 1] : e }, useMedium: function (e) { var i = t(e, r); return n.push(i), function () { n = n.filter((function (e) { return e !== i })) } }, assignSyncMedium: function (e) { for (r = !0; n.length;) { var t = n; n = [], t.forEach(e) } n = { push: function (t) { return e(t) }, filter: function () { return n } } }, assignMedium: function (e) { r = !0; var t = []; if (n.length) { var i = n; n = [], i.forEach(e), t = n } var o = function () { var n = t; t = [], n.forEach(e) }, a = function () { return Promise.resolve().then(o) }; a(), n = { push: function (e) { t.push(e), a() }, filter: function (e) { return t = t.filter(e), n } } } }; return i }(null); return t.options = Qn({ async: !0, ssr: !1 }, e), t } var rc = nc(), ic = function () { }, oc = A.forwardRef((function (e, t) { var n = A.useRef(null), r = A.useState({ onScrollCapture: ic, onWheelCapture: ic, onTouchMoveCapture: ic }), i = r[0], o = r[1], a = e.forwardProps, s = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, d = e.shards, p = e.sideCar, h = e.noIsolation, f = e.inert, m = e.allowPinchZoom, g = e.as, v = void 0 === g ? "div" : g, y = qn(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), b = p, w = ec([n, t]), E = Qn(Qn({}, y), i); return A.createElement(A.Fragment, null, u && A.createElement(b, { sideCar: rc, removeScrollBar: c, shards: d, noIsolation: h, inert: f, setCallbacks: o, allowPinchZoom: !!m, lockRef: n }), a ? A.cloneElement(A.Children.only(s), Qn(Qn({}, E), { ref: w })) : A.createElement(v, Qn({}, E, { className: l, ref: w }), s)) })); oc.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }, oc.classNames = { fullWidth: $l, zeroRight: Jl }; var ac = function (e) { var t = e.sideCar, n = qn(e, ["sideCar"]); if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var r = t.read(); if (!r) throw new Error("Sidecar medium not found"); return A.createElement(r, Qn({}, n)) }; function sc(e, t) { return e.useMedium(t), ac } ac.isSideCarExport = !0; var lc = function () { var e = 0, t = null; return { add: function (r) { var i, o; 0 == e && (t = function () { if (!document) return null; var e = document.createElement("style"); e.type = "text/css"; var t = n.nc; return t && e.setAttribute("nonce", t), e }()) && (o = r, (i = t).styleSheet ? i.styleSheet.cssText = o : i.appendChild(document.createTextNode(o)), function (e) { (document.head || document.getElementsByTagName("head")[0]).appendChild(e) }(t)), e++ }, remove: function () { ! --e && t && (t.parentNode && t.parentNode.removeChild(t), t = null) } } }, cc = function () { var e, t = (e = lc(), function (t, n) { A.useEffect((function () { return e.add(t), function () { e.remove() } }), [t && n]) }); return function (e) { var n = e.styles, r = e.dynamic; return t(n, r), null } }, uc = { left: 0, top: 0, right: 0, gap: 0 }, dc = function (e) { return parseInt(e || "", 10) || 0 }, pc = cc(), hc = function (e, t, n, r) { var i = e.left, o = e.top, a = e.right, s = e.gap; return void 0 === n && (n = "margin"), "\n  .".concat("with-scroll-bars-hidden", " {\n   overflow: hidden ").concat(r, ";\n   padding-right: ").concat(s, "px ").concat(r, ";\n  }\n  body {\n    overflow: hidden ").concat(r, ";\n    overscroll-behavior: contain;\n    ").concat([t && "position: relative ".concat(r, ";"), "margin" === n && "\n    padding-left: ".concat(i, "px;\n    padding-top: ").concat(o, "px;\n    padding-right: ").concat(a, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(s, "px ").concat(r, ";\n    "), "padding" === n && "padding-right: ".concat(s, "px ").concat(r, ";")].filter(Boolean).join(""), "\n  }\n  \n  .").concat(Jl, " {\n    right: ").concat(s, "px ").concat(r, ";\n  }\n  \n  .").concat($l, " {\n    margin-right: ").concat(s, "px ").concat(r, ";\n  }\n  \n  .").concat(Jl, " .").concat(Jl, " {\n    right: 0 ").concat(r, ";\n  }\n  \n  .").concat($l, " .").concat($l, " {\n    margin-right: 0 ").concat(r, ";\n  }\n  \n  body {\n    ").concat("--removed-body-scroll-bar-size", ": ").concat(s, "px;\n  }\n") }, fc = function (e) { var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = void 0 === r ? "margin" : r, o = A.useMemo((function () { return function (e) { if (void 0 === e && (e = "margin"), "undefined" == typeof window) return uc; var t = function (e) { var t = window.getComputedStyle(document.body), n = t["padding" === e ? "paddingLeft" : "marginLeft"], r = t["padding" === e ? "paddingTop" : "marginTop"], i = t["padding" === e ? "paddingRight" : "marginRight"]; return [dc(n), dc(r), dc(i)] }(e), n = document.documentElement.clientWidth, r = window.innerWidth; return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) } }(i) }), [i]); return A.createElement(pc, { styles: hc(o, !t, i, n ? "" : "!important") }) }, mc = !1; if ("undefined" != typeof window) try { var gc = Object.defineProperty({}, "passive", { get: function () { return mc = !0, !0 } }); window.addEventListener("test", gc, gc), window.removeEventListener("test", gc, gc) } catch (e) { mc = !1 } var vc = !!mc && { passive: !1 }, yc = function (e, t) { var n = t; do { if ("undefined" != typeof ShadowRoot && n instanceof ShadowRoot && (n = n.host), bc(e, n)) { var r = wc(e, n); if (r[1] > r[2]) return !0 } n = n.parentNode } while (n && n !== document.body); return !1 }, bc = function (e, t) { return "v" === e ? function (e) { var t = window.getComputedStyle(e); return "hidden" !== t.overflowY && !(t.overflowY === t.overflowX && "visible" === t.overflowY) }(t) : function (e) { var t = window.getComputedStyle(e); return "hidden" !== t.overflowX && !(t.overflowY === t.overflowX && "visible" === t.overflowX) }(t) }, wc = function (e, t) { return "v" === e ? function (e) { return [e.scrollTop, e.scrollHeight, e.clientHeight] }(t) : function (e) { return [e.scrollLeft, e.scrollWidth, e.clientWidth] }(t) }, Ec = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, Cc = function (e) { return [e.deltaX, e.deltaY] }, Sc = function (e) { return e && "current" in e ? e.current : e }, kc = function (e) { return "\n  .block-interactivity-".concat(e, " {pointer-events: none;}\n  .allow-interactivity-").concat(e, " {pointer-events: all;}\n") }, xc = 0, Ac = []; const Ic = sc(rc, (function (e) { var t = A.useRef([]), n = A.useRef([0, 0]), r = A.useRef(), i = A.useState(xc++)[0], o = A.useState((function () { return cc() }))[0], a = A.useRef(e); A.useEffect((function () { a.current = e }), [e]), A.useEffect((function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(i)); var t = Jn([e.lockRef.current], (e.shards || []).map(Sc), !0).filter(Boolean); return t.forEach((function (e) { return e.classList.add("allow-interactivity-".concat(i)) })), function () { document.body.classList.remove("block-interactivity-".concat(i)), t.forEach((function (e) { return e.classList.remove("allow-interactivity-".concat(i)) })) } } }), [e.inert, e.lockRef.current, e.shards]); var s = A.useCallback((function (e, t) { if ("touches" in e && 2 === e.touches.length) return !a.current.allowPinchZoom; var i, o = Ec(e), s = n.current, l = "deltaX" in e ? e.deltaX : s[0] - o[0], c = "deltaY" in e ? e.deltaY : s[1] - o[1], u = e.target, d = Math.abs(l) > Math.abs(c) ? "h" : "v"; if ("touches" in e && "h" === d && "range" === u.type) return !1; var p = yc(d, u); if (!p) return !0; if (p ? i = d : (i = "v" === d ? "h" : "v", p = yc(d, u)), !p) return !1; if (!r.current && "changedTouches" in e && (l || c) && (r.current = i), !i) return !0; var h = r.current || i; return function (e, t, n, r, i) { var o = function (e, t) { return "h" === e && "rtl" === t ? -1 : 1 }(e, window.getComputedStyle(t).direction), a = o * r, s = n.target, l = t.contains(s), c = !1, u = a > 0, d = 0, p = 0; do { var h = wc(e, s), f = h[0], m = h[1] - h[2] - o * f; (f || m) && bc(e, s) && (d += m, p += f), s = s.parentNode } while (!l && s !== document.body || l && (t.contains(s) || t === s)); return (u && (0 === d || !1) || !u && (0 === p || !1)) && (c = !0), c }(h, t, e, "h" === h ? l : c) }), []), l = A.useCallback((function (e) { var n = e; if (Ac.length && Ac[Ac.length - 1] === o) { var r = "deltaY" in n ? Cc(n) : Ec(n), i = t.current.filter((function (e) { return e.name === n.type && e.target === n.target && function (e, t) { return e[0] === t[0] && e[1] === t[1] }(e.delta, r) }))[0]; if (i && i.should) n.preventDefault(); else if (!i) { var l = (a.current.shards || []).map(Sc).filter(Boolean).filter((function (e) { return e.contains(n.target) })); (l.length > 0 ? s(n, l[0]) : !a.current.noIsolation) && n.preventDefault() } } }), []), c = A.useCallback((function (e, n, r, i) { var o = { name: e, delta: n, target: r, should: i }; t.current.push(o), setTimeout((function () { t.current = t.current.filter((function (e) { return e !== o })) }), 1) }), []), u = A.useCallback((function (e) { n.current = Ec(e), r.current = void 0 }), []), d = A.useCallback((function (t) { c(t.type, Cc(t), t.target, s(t, e.lockRef.current)) }), []), p = A.useCallback((function (t) { c(t.type, Ec(t), t.target, s(t, e.lockRef.current)) }), []); A.useEffect((function () { return Ac.push(o), e.setCallbacks({ onScrollCapture: d, onWheelCapture: d, onTouchMoveCapture: p }), document.addEventListener("wheel", l, vc), document.addEventListener("touchmove", l, vc), document.addEventListener("touchstart", u, vc), function () { Ac = Ac.filter((function (e) { return e !== o })), document.removeEventListener("wheel", l, vc), document.removeEventListener("touchmove", l, vc), document.removeEventListener("touchstart", u, vc) } }), []); var h = e.removeScrollBar, f = e.inert; return A.createElement(A.Fragment, null, f ? A.createElement(o, { styles: kc(i) }) : null, h ? A.createElement(fc, { gapMode: "margin" }) : null) })); var Pc = A.forwardRef((function (e, t) { return A.createElement(oc, Qn({}, e, { ref: t, sideCar: Ic })) })); Pc.classNames = oc.classNames; const Mc = Pc, Tc = ["Enter", " "], Rc = ["ArrowUp", "PageDown", "End"], Bc = ["ArrowDown", "PageUp", "Home", ...Rc], Dc = { ltr: [...Tc, "ArrowRight"], rtl: [...Tc, "ArrowLeft"] }, Lc = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] }, Oc = "Menu", [Fc, zc, Hc] = No(Oc), [Nc, jc] = function (e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, Vo(r, ...t)] }(Oc, [Hc, Xs, Fl]), Uc = Xs(), Vc = Fl(), [Kc, Wc] = Nc(Oc), [Yc, Gc] = Nc(Oc), Zc = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, ...r } = e, i = Uc(n); return (0, A.createElement)(ul, bo({}, i, r, { ref: t })) })), Xc = "MenuPortal", [_c, Qc] = Nc(Xc, { forceMount: void 0 }), qc = "MenuContent", [Jc, $c] = Nc(qc), eu = (0, A.forwardRef)(((e, t) => { const n = Qc(qc, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Wc(qc, e.__scopeMenu), a = Gc(qc, e.__scopeMenu); return (0, A.createElement)(Fc.Provider, { scope: e.__scopeMenu }, (0, A.createElement)(fl, { present: r || o.open }, (0, A.createElement)(Fc.Slot, { scope: e.__scopeMenu }, a.modal ? (0, A.createElement)(tu, bo({}, i, { ref: t })) : (0, A.createElement)(nu, bo({}, i, { ref: t }))))) })), tu = (0, A.forwardRef)(((e, t) => { const n = Wc(qc, e.__scopeMenu), r = (0, A.useRef)(null), i = Uo(t, r); return (0, A.useEffect)((() => { const e = r.current; if (e) return ql(e) }), []), (0, A.createElement)(ru, bo({}, e, { ref: i, trapFocus: n.open, disableOutsidePointerEvents: n.open, disableOutsideScroll: !0, onFocusOutside: To(e.onFocusOutside, (e => e.preventDefault()), { checkForDefaultPrevented: !1 }), onDismiss: () => n.onOpenChange(!1) })) })), nu = (0, A.forwardRef)(((e, t) => { const n = Wc(qc, e.__scopeMenu); return (0, A.createElement)(ru, bo({}, e, { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, disableOutsideScroll: !1, onDismiss: () => n.onOpenChange(!1) })) })), ru = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, loop: r = !1, trapFocus: i, onOpenAutoFocus: o, onCloseAutoFocus: a, disableOutsidePointerEvents: s, onEscapeKeyDown: l, onPointerDownOutside: c, onFocusOutside: u, onInteractOutside: d, onDismiss: p, disableOutsideScroll: h, ...f } = e, m = Wc(qc, n), g = Gc(qc, n), v = Uc(n), y = Vc(n), b = zc(n), [w, E] = (0, A.useState)(null), C = (0, A.useRef)(null), S = Uo(t, C, m.onContentChange), k = (0, A.useRef)(0), x = (0, A.useRef)(""), I = (0, A.useRef)(0), P = (0, A.useRef)(null), M = (0, A.useRef)("right"), T = (0, A.useRef)(0), R = h ? Mc : A.Fragment, B = h ? { as: Yo, allowPinchZoom: !0 } : void 0; (0, A.useEffect)((() => () => window.clearTimeout(k.current)), []), (0, A.useEffect)((() => { var e, t; const n = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", null !== (e = n[0]) && void 0 !== e ? e : aa()), document.body.insertAdjacentElement("beforeend", null !== (t = n[1]) && void 0 !== t ? t : aa()), oa++, () => { 1 === oa && document.querySelectorAll("[data-radix-focus-guard]").forEach((e => e.remove())), oa-- } }), []); const D = (0, A.useCallback)((e => { var t, n; return M.current === (null === (t = P.current) || void 0 === t ? void 0 : t.side) && function (e, t) { if (!t) return !1; return function (e, t) { const { x: n, y: r } = e; let i = !1; for (let e = 0, o = t.length - 1; e < t.length; o = e++) { const a = t[e].x, s = t[e].y, l = t[o].x, c = t[o].y; s > r != c > r && n < (l - a) * (r - s) / (c - s) + a && (i = !i) } return i }({ x: e.clientX, y: e.clientY }, t) }(e, null === (n = P.current) || void 0 === n ? void 0 : n.area) }), []); return (0, A.createElement)(Jc, { scope: n, searchRef: x, onItemEnter: (0, A.useCallback)((e => { D(e) && e.preventDefault() }), [D]), onItemLeave: (0, A.useCallback)((e => { var t; D(e) || (null === (t = C.current) || void 0 === t || t.focus(), E(null)) }), [D]), onTriggerLeave: (0, A.useCallback)((e => { D(e) && e.preventDefault() }), [D]), pointerGraceTimerRef: I, onPointerGraceIntentChange: (0, A.useCallback)((e => { P.current = e }), []) }, (0, A.createElement)(R, B, (0, A.createElement)(ua, { asChild: !0, trapped: i, onMountAutoFocus: To(o, (e => { var t; e.preventDefault(), null === (t = C.current) || void 0 === t || t.focus() })), onUnmountAutoFocus: a }, (0, A.createElement)(na, { asChild: !0, disableOutsidePointerEvents: s, onEscapeKeyDown: l, onPointerDownOutside: c, onFocusOutside: u, onInteractOutside: d, onDismiss: p }, (0, A.createElement)(Wl, bo({ asChild: !0 }, y, { dir: g.dir, orientation: "vertical", loop: r, currentTabStopId: w, onCurrentTabStopIdChange: E, onEntryFocus: e => { g.isUsingKeyboardRef.current || e.preventDefault() } }), (0, A.createElement)(dl, bo({ role: "menu", "aria-orientation": "vertical", "data-state": ku(m.open), dir: g.dir }, v, f, { ref: S, style: { outline: "none", ...f.style }, onKeyDown: To(f.onKeyDown, (e => { const t = e.target.closest('[role="menu"]') === e.currentTarget, n = e.ctrlKey || e.altKey || e.metaKey, r = 1 === e.key.length; t && ("Tab" === e.key && e.preventDefault(), !n && r && (e => { var t, n; const r = x.current + e, i = b().filter((e => !e.disabled)), o = document.activeElement, a = null === (t = i.find((e => e.ref.current === o))) || void 0 === t ? void 0 : t.textValue, s = function (e, t, n) { const r = t.length > 1 && Array.from(t).every((e => e === t[0])) ? t[0] : t, i = n ? e.indexOf(n) : -1; let o = (a = e, s = Math.max(i, 0), a.map(((e, t) => a[(s + t) % a.length]))); var a, s; 1 === r.length && (o = o.filter((e => e !== n))); const l = o.find((e => e.toLowerCase().startsWith(r.toLowerCase()))); return l !== n ? l : void 0 }(i.map((e => e.textValue)), r, a), l = null === (n = i.find((e => e.textValue === s))) || void 0 === n ? void 0 : n.ref.current; !function e(t) { x.current = t, window.clearTimeout(k.current), "" !== t && (k.current = window.setTimeout((() => e("")), 1e3)) }(r), l && setTimeout((() => l.focus())) })(e.key)); const i = C.current; if (e.target !== i) return; if (!Bc.includes(e.key)) return; e.preventDefault(); const o = b().filter((e => !e.disabled)).map((e => e.ref.current)); Rc.includes(e.key) && o.reverse(), function (e) { const t = document.activeElement; for (const n of e) { if (n === t) return; if (n.focus(), document.activeElement !== t) return } }(o) })), onBlur: To(e.onBlur, (e => { e.currentTarget.contains(e.target) || (window.clearTimeout(k.current), x.current = "") })), onPointerMove: To(e.onPointerMove, Au((e => { const t = e.target, n = T.current !== e.clientX; if (e.currentTarget.contains(t) && n) { const t = e.clientX > T.current ? "right" : "left"; M.current = t, T.current = e.clientX } }))) }))))))) })), iu = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, ...r } = e; return (0, A.createElement)(Qo.div, bo({ role: "group" }, r, { ref: t })) })), ou = "MenuItem", au = "menu.itemSelect", su = (0, A.forwardRef)(((e, t) => { const { disabled: n = !1, onSelect: r, ...i } = e, o = (0, A.useRef)(null), a = Gc(ou, e.__scopeMenu), s = $c(ou, e.__scopeMenu), l = Uo(t, o), c = (0, A.useRef)(!1); return (0, A.createElement)(lu, bo({}, i, { ref: l, disabled: n, onClick: To(e.onClick, (() => { const e = o.current; if (!n && e) { const t = new CustomEvent(au, { bubbles: !0, cancelable: !0 }); e.addEventListener(au, (e => null == r ? void 0 : r(e)), { once: !0 }), qo(e, t), t.defaultPrevented ? c.current = !1 : a.onClose() } })), onPointerDown: t => { var n; null === (n = e.onPointerDown) || void 0 === n || n.call(e, t), c.current = !0 }, onPointerUp: To(e.onPointerUp, (e => { var t; c.current || null === (t = e.currentTarget) || void 0 === t || t.click() })), onKeyDown: To(e.onKeyDown, (e => { const t = "" !== s.searchRef.current; n || t && " " === e.key || Tc.includes(e.key) && (e.currentTarget.click(), e.preventDefault()) })) })) })), lu = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, disabled: r = !1, textValue: i, ...o } = e, a = $c(ou, n), s = Vc(n), l = (0, A.useRef)(null), c = Uo(t, l), [u, d] = (0, A.useState)(!1), [p, h] = (0, A.useState)(""); return (0, A.useEffect)((() => { const e = l.current; var t; e && h((null !== (t = e.textContent) && void 0 !== t ? t : "").trim()) }), [o.children]), (0, A.createElement)(Fc.ItemSlot, { scope: n, disabled: r, textValue: null != i ? i : p }, (0, A.createElement)(Yl, bo({ asChild: !0 }, s, { focusable: !r }), (0, A.createElement)(Qo.div, bo({ role: "menuitem", "data-highlighted": u ? "" : void 0, "aria-disabled": r || void 0, "data-disabled": r ? "" : void 0 }, o, { ref: c, onPointerMove: To(e.onPointerMove, Au((e => { r ? a.onItemLeave(e) : (a.onItemEnter(e), e.defaultPrevented || e.currentTarget.focus()) }))), onPointerLeave: To(e.onPointerLeave, Au((e => a.onItemLeave(e)))), onFocus: To(e.onFocus, (() => d(!0))), onBlur: To(e.onBlur, (() => d(!1))) })))) })), cu = (0, A.forwardRef)(((e, t) => { const { checked: n = !1, onCheckedChange: r, ...i } = e; return (0, A.createElement)(mu, { scope: e.__scopeMenu, checked: n }, (0, A.createElement)(su, bo({ role: "menuitemcheckbox", "aria-checked": n }, i, { ref: t, "data-state": xu(n), onSelect: To(i.onSelect, (() => null == r ? void 0 : r(!n)), { checkForDefaultPrevented: !1 }) }))) })), [uu, du] = Nc("MenuRadioGroup", { value: void 0, onValueChange: () => { } }), pu = (0, A.forwardRef)(((e, t) => { const { value: n, onValueChange: r, ...i } = e, o = Jo(r); return (0, A.createElement)(uu, { scope: e.__scopeMenu, value: n, onValueChange: o }, (0, A.createElement)(iu, bo({}, i, { ref: t }))) })), hu = (0, A.forwardRef)(((e, t) => { const { value: n, ...r } = e, i = du("MenuRadioItem", e.__scopeMenu), o = n === i.value; return (0, A.createElement)(mu, { scope: e.__scopeMenu, checked: o }, (0, A.createElement)(su, bo({ role: "menuitemradio", "aria-checked": o }, r, { ref: t, "data-state": xu(o), onSelect: To(r.onSelect, (() => { var e; return null === (e = i.onValueChange) || void 0 === e ? void 0 : e.call(i, n) }), { checkForDefaultPrevented: !1 }) }))) })), fu = "MenuItemIndicator", [mu, gu] = Nc(fu, { checked: !1 }), vu = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, forceMount: r, ...i } = e, o = gu(fu, n); return (0, A.createElement)(fl, { present: r || o.checked }, (0, A.createElement)(Qo.span, bo({}, i, { ref: t, "data-state": xu(o.checked) }))) })), yu = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, ...r } = e; return (0, A.createElement)(Qo.div, bo({ role: "separator", "aria-orientation": "horizontal" }, r, { ref: t })) })), bu = (0, A.forwardRef)(((e, t) => { const { __scopeMenu: n, ...r } = e, i = Uc(n); return (0, A.createElement)(pl, bo({}, i, r, { ref: t })) })), wu = "MenuSub", [Eu, Cu] = Nc(wu), Su = "MenuSubTrigger"; function ku(e) { return e ? "open" : "closed" } function xu(e) { return e ? "checked" : "unchecked" } function Au(e) { return t => "mouse" === t.pointerType ? e(t) : void 0 } const Iu = e => { const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: o, modal: a = !0 } = e, s = Uc(t), [l, c] = (0, A.useState)(null), u = (0, A.useRef)(!1), d = Jo(o), p = Wo(i); return (0, A.useEffect)((() => { const e = () => { u.current = !0, document.addEventListener("pointerdown", t, { capture: !0, once: !0 }), document.addEventListener("pointermove", t, { capture: !0, once: !0 }) }, t = () => u.current = !1; return document.addEventListener("keydown", e, { capture: !0 }), () => { document.removeEventListener("keydown", e, { capture: !0 }), document.removeEventListener("pointerdown", t, { capture: !0 }), document.removeEventListener("pointermove", t, { capture: !0 }) } }), []), (0, A.createElement)(cl, s, (0, A.createElement)(Kc, { scope: t, open: n, onOpenChange: d, content: l, onContentChange: c }, (0, A.createElement)(Yc, { scope: t, onClose: (0, A.useCallback)((() => d(!1)), [d]), isUsingKeyboardRef: u, dir: p, modal: a }, r))) }, Pu = Zc, Mu = e => { const { __scopeMenu: t, forceMount: n, children: r, container: i } = e, o = Wc(Xc, t); return (0, A.createElement)(_c, { scope: t, forceMount: n }, (0, A.createElement)(fl, { present: n || o.open }, (0, A.createElement)(hl, { asChild: !0, container: i }, r))) }, Tu = eu, Ru = su, Bu = cu, Du = pu, Lu = hu, Ou = vu, Fu = yu, zu = bu, Hu = e => { const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: i } = e, o = Wc(wu, t), a = Uc(t), [s, l] = (0, A.useState)(null), [c, u] = (0, A.useState)(null), d = Jo(i); return (0, A.useEffect)((() => (!1 === o.open && d(!1), () => d(!1))), [o.open, d]), (0, A.createElement)(cl, a, (0, A.createElement)(Kc, { scope: t, open: r, onOpenChange: d, content: c, onContentChange: u }, (0, A.createElement)(Eu, { scope: t, contentId: wa(), triggerId: wa(), trigger: s, onTriggerChange: l }, n))) }, Nu = (0, A.forwardRef)(((e, t) => { const n = Wc(Su, e.__scopeMenu), r = Gc(Su, e.__scopeMenu), i = Cu(Su, e.__scopeMenu), o = $c(Su, e.__scopeMenu), a = (0, A.useRef)(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: l } = o, c = { __scopeMenu: e.__scopeMenu }, u = (0, A.useCallback)((() => { a.current && window.clearTimeout(a.current), a.current = null }), []); return (0, A.useEffect)((() => u), [u]), (0, A.useEffect)((() => { const e = s.current; return () => { window.clearTimeout(e), l(null) } }), [s, l]), (0, A.createElement)(Zc, bo({ asChild: !0 }, c), (0, A.createElement)(lu, bo({ id: i.triggerId, "aria-haspopup": "menu", "aria-expanded": n.open, "aria-controls": i.contentId, "data-state": ku(n.open) }, e, { ref: jo(t, i.onTriggerChange), onClick: t => { var r; null === (r = e.onClick) || void 0 === r || r.call(e, t), e.disabled || t.defaultPrevented || (t.currentTarget.focus(), n.open || n.onOpenChange(!0)) }, onPointerMove: To(e.onPointerMove, Au((t => { o.onItemEnter(t), t.defaultPrevented || e.disabled || n.open || a.current || (o.onPointerGraceIntentChange(null), a.current = window.setTimeout((() => { n.onOpenChange(!0), u() }), 100)) }))), onPointerLeave: To(e.onPointerLeave, Au((e => { var t; u(); const r = null === (t = n.content) || void 0 === t ? void 0 : t.getBoundingClientRect(); if (r) { var i; const t = null === (i = n.content) || void 0 === i ? void 0 : i.dataset.side, a = "right" === t, l = a ? -5 : 5, c = r[a ? "left" : "right"], u = r[a ? "right" : "left"]; o.onPointerGraceIntentChange({ area: [{ x: e.clientX + l, y: e.clientY }, { x: c, y: r.top }, { x: u, y: r.top }, { x: u, y: r.bottom }, { x: c, y: r.bottom }], side: t }), window.clearTimeout(s.current), s.current = window.setTimeout((() => o.onPointerGraceIntentChange(null)), 300) } else { if (o.onTriggerLeave(e), e.defaultPrevented) return; o.onPointerGraceIntentChange(null) } }))), onKeyDown: To(e.onKeyDown, (t => { const i = "" !== o.searchRef.current; var a; e.disabled || i && " " === t.key || Dc[r.dir].includes(t.key) && (n.onOpenChange(!0), null === (a = n.content) || void 0 === a || a.focus(), t.preventDefault()) })) }))) })), ju = (0, A.forwardRef)(((e, t) => { const n = Qc(qc, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, o = Wc(qc, e.__scopeMenu), a = Gc(qc, e.__scopeMenu), s = Cu("MenuSubContent", e.__scopeMenu), l = (0, A.useRef)(null), c = Uo(t, l); return (0, A.createElement)(Fc.Provider, { scope: e.__scopeMenu }, (0, A.createElement)(fl, { present: r || o.open }, (0, A.createElement)(Fc.Slot, { scope: e.__scopeMenu }, (0, A.createElement)(ru, bo({ id: s.contentId, "aria-labelledby": s.triggerId }, i, { ref: c, align: "start", side: "rtl" === a.dir ? "left" : "right", disableOutsidePointerEvents: !1, disableOutsideScroll: !1, trapFocus: !1, onOpenAutoFocus: e => { var t; a.isUsingKeyboardRef.current && (null === (t = l.current) || void 0 === t || t.focus()), e.preventDefault() }, onCloseAutoFocus: e => e.preventDefault(), onFocusOutside: To(e.onFocusOutside, (e => { e.target !== s.trigger && o.onOpenChange(!1) })), onEscapeKeyDown: To(e.onEscapeKeyDown, a.onClose), onKeyDown: To(e.onKeyDown, (e => { const t = e.currentTarget.contains(e.target), n = Lc[a.dir].includes(e.key); var r; t && n && (o.onOpenChange(!1), null === (r = s.trigger) || void 0 === r || r.focus(), e.preventDefault()) })) }))))) })), Uu = "ContextMenu", [Vu, Ku] = function (e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, Eo(r, ...t)] }(Uu, [jc]), Wu = jc(), [Yu, Gu] = Vu(Uu), Zu = (0, A.forwardRef)(((e, t) => { const { __scopeContextMenu: n, ...r } = e, i = Gu("ContextMenuTrigger", n), o = Wu(n), a = (0, A.useRef)({ x: 0, y: 0 }), s = (0, A.useRef)({ getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...a.current }) }), l = (0, A.useRef)(0), c = (0, A.useCallback)((() => window.clearTimeout(l.current)), []), u = e => { a.current = { x: e.clientX, y: e.clientY }, i.onOpenChange(!0) }; return (0, A.useEffect)((() => c), [c]), (0, A.createElement)(A.Fragment, null, (0, A.createElement)(Pu, bo({}, o, { virtualRef: s })), (0, A.createElement)(Mo.span, bo({ "data-state": i.open ? "open" : "closed" }, r, { ref: t, style: { WebkitTouchCallout: "none", ...e.style }, onContextMenu: wo(e.onContextMenu, (e => { c(), u(e), e.preventDefault() })), onPointerDown: wo(e.onPointerDown, qu((e => { c(), l.current = window.setTimeout((() => u(e)), 700) }))), onPointerMove: wo(e.onPointerMove, qu(c)), onPointerCancel: wo(e.onPointerCancel, qu(c)), onPointerUp: wo(e.onPointerUp, qu(c)) }))) })), Xu = (0, A.forwardRef)(((e, t) => { const { __scopeContextMenu: n, ...r } = e, i = Gu("ContextMenuContent", n), o = Wu(n), a = (0, A.useRef)(!1); return (0, A.createElement)(Tu, bo({}, o, r, { ref: t, side: "right", sideOffset: 2, align: "start", onCloseAutoFocus: t => { var n; null === (n = e.onCloseAutoFocus) || void 0 === n || n.call(e, t), !t.defaultPrevented && a.current && t.preventDefault(), a.current = !1 }, onInteractOutside: t => { var n; null === (n = e.onInteractOutside) || void 0 === n || n.call(e, t), t.defaultPrevented || i.modal || (a.current = !0) }, style: { ...e.style, "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)" } })) })), _u = (0, A.forwardRef)(((e, t) => { const { __scopeContextMenu: n, ...r } = e, i = Wu(n); return (0, A.createElement)(Ru, bo({}, i, r, { ref: t })) })), Qu = (0, A.forwardRef)(((e, t) => { const { __scopeContextMenu: n, ...r } = e, i = Wu(n); return (0, A.createElement)(zu, bo({}, i, r, { ref: t })) })); function qu(e) { return t => "mouse" !== t.pointerType ? e(t) : void 0 } const Ju = e => { const { __scopeContextMenu: t, children: n, onOpenChange: r, dir: i, modal: o = !0 } = e, [a, s] = (0, A.useState)(!1), l = Wu(t), c = Jo(r), u = (0, A.useCallback)((e => { s(e), c(e) }), [c]); return (0, A.createElement)(Yu, { scope: t, open: a, onOpenChange: u, modal: o }, (0, A.createElement)(Iu, bo({}, l, { dir: i, open: a, onOpenChange: u, modal: o }), n)) }, $u = Zu, ed = e => { const { __scopeContextMenu: t, ...n } = e, r = Wu(t); return (0, A.createElement)(Mu, bo({}, r, n)) }, td = Xu, nd = e => { const { __scopeContextMenu: t, children: n, onOpenChange: r, open: i, defaultOpen: o } = e, a = Wu(t), [s, l] = Pl({ prop: i, defaultProp: o, onChange: r }); return (0, A.createElement)(Hu, bo({}, a, { open: s, onOpenChange: l }), n) }, rd = (0, A.forwardRef)(((e, t) => { const { __scopeContextMenu: n, ...r } = e, i = Wu(n); return (0, A.createElement)(Nu, bo({}, i, r, { ref: t })) })), id = (0, A.forwardRef)(((e, t) => { const { __scopeContextMenu: n, ...r } = e, i = Wu(n); return (0, A.createElement)(ju, bo({}, i, r, { ref: t, style: { ...e.style, "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)" } })) })); function od(e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i } var ad = ["color"], sd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, ad); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M9 3C9 2.44772 8.55229 2 8 2H7C6.44772 2 6 2.44772 6 3L6 14H1.5C1.22386 14 1 14.2239 1 14.5C1 14.7761 1.22386 15 1.5 15L6 15H9H13.5C13.7761 15 14 14.7761 14 14.5C14 14.2239 13.7761 14 13.5 14H9V3Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), ld = ["color"], cd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, ld); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1.99988 6C1.44759 6 0.999877 6.44772 0.999877 7L0.999877 8C0.999877 8.55228 1.44759 9 1.99988 9L6.99988 9L6.99988 13.5C6.99988 13.7761 7.22374 14 7.49988 14C7.77602 14 7.99988 13.7761 7.99988 13.5L7.99988 9L12.9999 9C13.5522 9 13.9999 8.55228 13.9999 8L13.9999 7C13.9999 6.44772 13.5522 6 12.9999 6L7.99988 6L7.99988 1.5C7.99988 1.22386 7.77602 1 7.49988 1C7.22373 1 6.99988 1.22386 6.99988 1.5L6.99988 6L1.99988 6Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), ud = ["color"], dd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, ud); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M6.99988 1C6.44759 1 5.99988 1.44772 5.99988 2V7H1.49988C1.22374 7 0.999878 7.22386 0.999878 7.5C0.999878 7.77614 1.22374 8 1.49988 8H5.99988V13C5.99988 13.5523 6.44759 14 6.99988 14H7.99988C8.55216 14 8.99988 13.5523 8.99988 13V8H13.4999C13.776 8 13.9999 7.77614 13.9999 7.5C13.9999 7.22386 13.776 7 13.4999 7H8.99988V2C8.99988 1.44772 8.55216 1 7.99988 1L6.99988 1Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), pd = ["color"], hd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, pd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M0.499995 0.999995C0.223855 0.999995 -5.58458e-07 1.22385 -5.46388e-07 1.49999L-2.18554e-08 13.4999C-9.78492e-09 13.776 0.223855 13.9999 0.499995 13.9999C0.776136 13.9999 0.999991 13.776 0.999991 13.4999L0.999991 8.99993L12 8.99993C12.5523 8.99993 13 8.55222 13 7.99993L13 6.99994C13 6.44766 12.5523 5.99995 12 5.99995L0.999991 5.99995L0.999991 1.49999C0.999991 1.22385 0.776135 0.999995 0.499995 0.999995Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), fd = ["color"], md = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, fd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M14.4999 1C14.2237 1 13.9999 1.22386 13.9999 1.5L13.9999 6L2.99988 6C2.44759 6 1.99988 6.44772 1.99988 7L1.99988 8C1.99988 8.55228 2.44759 9 2.99988 9L13.9999 9L13.9999 13.5C13.9999 13.7761 14.2237 14 14.4999 14C14.776 14 14.9999 13.7761 14.9999 13.5L14.9999 9L14.9999 6L14.9999 1.5C14.9999 1.22386 14.776 1 14.4999 1Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), gd = ["color"], vd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, gd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1.5 0C1.22386 0 1 0.223858 1 0.5C1 0.776142 1.22386 1 1.5 1H6V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V1H13.5C13.7761 1 14 0.776142 14 0.5C14 0.223858 13.7761 0 13.5 0H9H6H1.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), yd = ["color"], bd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, yd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M8.8914 2.1937C9.1158 2.35464 9.16725 2.66701 9.00631 2.89141L2.47388 12H13.5C13.7761 12 14 12.2239 14 12.5C14 12.7762 13.7761 13 13.5 13H1.5C1.31254 13 1.14082 12.8952 1.0552 12.7284C0.969578 12.5616 0.984438 12.361 1.09369 12.2086L8.19369 2.30862C8.35462 2.08422 8.667 2.03277 8.8914 2.1937ZM11.1 6.50001C11.1 6.22387 11.3238 6.00001 11.6 6.00001C11.8761 6.00001 12.1 6.22387 12.1 6.50001C12.1 6.77615 11.8761 7.00001 11.6 7.00001C11.3238 7.00001 11.1 6.77615 11.1 6.50001ZM10.4 4.00001C10.1239 4.00001 9.90003 4.22387 9.90003 4.50001C9.90003 4.77615 10.1239 5.00001 10.4 5.00001C10.6762 5.00001 10.9 4.77615 10.9 4.50001C10.9 4.22387 10.6762 4.00001 10.4 4.00001ZM12.1 8.50001C12.1 8.22387 12.3238 8.00001 12.6 8.00001C12.8761 8.00001 13.1 8.22387 13.1 8.50001C13.1 8.77615 12.8761 9.00001 12.6 9.00001C12.3238 9.00001 12.1 8.77615 12.1 8.50001ZM13.4 10C13.1239 10 12.9 10.2239 12.9 10.5C12.9 10.7761 13.1239 11 13.4 11C13.6762 11 13.9 10.7761 13.9 10.5C13.9 10.2239 13.6762 10 13.4 10Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), wd = ["color"], Ed = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, wd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.5 2C7.77614 2 8 2.22386 8 2.5L8 11.2929L11.1464 8.14645C11.3417 7.95118 11.6583 7.95118 11.8536 8.14645C12.0488 8.34171 12.0488 8.65829 11.8536 8.85355L7.85355 12.8536C7.75979 12.9473 7.63261 13 7.5 13C7.36739 13 7.24021 12.9473 7.14645 12.8536L3.14645 8.85355C2.95118 8.65829 2.95118 8.34171 3.14645 8.14645C3.34171 7.95118 3.65829 7.95118 3.85355 8.14645L7 11.2929L7 2.5C7 2.22386 7.22386 2 7.5 2Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Cd = ["color"], Sd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Cd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L10.2929 4L6 4C5.72386 4 5.5 3.77614 5.5 3.5C5.5 3.22386 5.72386 3 6 3L11.5 3C11.6326 3 11.7598 3.05268 11.8536 3.14645C11.9473 3.24022 12 3.36739 12 3.5L12 9.00001C12 9.27615 11.7761 9.50001 11.5 9.50001C11.2239 9.50001 11 9.27615 11 9.00001V4.70711L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), kd = ["color"], xd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, kd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.14645 2.14645C7.34171 1.95118 7.65829 1.95118 7.85355 2.14645L11.8536 6.14645C12.0488 6.34171 12.0488 6.65829 11.8536 6.85355C11.6583 7.04882 11.3417 7.04882 11.1464 6.85355L8 3.70711L8 12.5C8 12.7761 7.77614 13 7.5 13C7.22386 13 7 12.7761 7 12.5L7 3.70711L3.85355 6.85355C3.65829 7.04882 3.34171 7.04882 3.14645 6.85355C2.95118 6.65829 2.95118 6.34171 3.14645 6.14645L7.14645 2.14645Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Ad = ["color"], Id = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Ad); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M2.5 2H12.5C12.7761 2 13 2.22386 13 2.5V12.5C13 12.7761 12.7761 13 12.5 13H2.5C2.22386 13 2 12.7761 2 12.5V2.5C2 2.22386 2.22386 2 2.5 2ZM1 2.5C1 1.67157 1.67157 1 2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5ZM7.5 4C7.77614 4 8 3.77614 8 3.5C8 3.22386 7.77614 3 7.5 3C7.22386 3 7 3.22386 7 3.5C7 3.77614 7.22386 4 7.5 4ZM8 5.5C8 5.77614 7.77614 6 7.5 6C7.22386 6 7 5.77614 7 5.5C7 5.22386 7.22386 5 7.5 5C7.77614 5 8 5.22386 8 5.5ZM7.5 8C7.77614 8 8 7.77614 8 7.5C8 7.22386 7.77614 7 7.5 7C7.22386 7 7 7.22386 7 7.5C7 7.77614 7.22386 8 7.5 8ZM10 7.5C10 7.77614 9.77614 8 9.5 8C9.22386 8 9 7.77614 9 7.5C9 7.22386 9.22386 7 9.5 7C9.77614 7 10 7.22386 10 7.5ZM11.5 8C11.7761 8 12 7.77614 12 7.5C12 7.22386 11.7761 7 11.5 7C11.2239 7 11 7.22386 11 7.5C11 7.77614 11.2239 8 11.5 8Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Pd = ["color"], Md = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Pd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M12.5 2H2.5C2.22386 2 2 2.22386 2 2.5V12.5C2 12.7761 2.22386 13 2.5 13H12.5C12.7761 13 13 12.7761 13 12.5V2.5C13 2.22386 12.7761 2 12.5 2ZM2.5 1C1.67157 1 1 1.67157 1 2.5V12.5C1 13.3284 1.67157 14 2.5 14H12.5C13.3284 14 14 13.3284 14 12.5V2.5C14 1.67157 13.3284 1 12.5 1H2.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Td = ["color"], Rd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Td); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Bd = ["color"], Dd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Bd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Ld = ["color"], Od = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Ld); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M0.877075 7.49991C0.877075 3.84222 3.84222 0.877075 7.49991 0.877075C11.1576 0.877075 14.1227 3.84222 14.1227 7.49991C14.1227 11.1576 11.1576 14.1227 7.49991 14.1227C3.84222 14.1227 0.877075 11.1576 0.877075 7.49991ZM7.49991 1.82708C4.36689 1.82708 1.82708 4.36689 1.82708 7.49991C1.82708 10.6329 4.36689 13.1727 7.49991 13.1727C10.6329 13.1727 13.1727 10.6329 13.1727 7.49991C13.1727 4.36689 10.6329 1.82708 7.49991 1.82708Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Fd = ["color"], zd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Fd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M5 2V1H10V2H5ZM4.75 0C4.33579 0 4 0.335786 4 0.75V1H3.5C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V2.5C13 1.67157 12.3284 1 11.5 1H11V0.75C11 0.335786 10.6642 0 10.25 0H4.75ZM11 2V2.25C11 2.66421 10.6642 3 10.25 3H4.75C4.33579 3 4 2.66421 4 2.25V2H3.5C3.22386 2 3 2.22386 3 2.5V12.5C3 12.7761 3.22386 13 3.5 13H11.5C11.7761 13 12 12.7761 12 12.5V2.5C12 2.22386 11.7761 2 11.5 2H11Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Hd = ["color"], Nd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Hd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1 9.50006C1 10.3285 1.67157 11.0001 2.5 11.0001H4L4 10.0001H2.5C2.22386 10.0001 2 9.7762 2 9.50006L2 2.50006C2 2.22392 2.22386 2.00006 2.5 2.00006L9.5 2.00006C9.77614 2.00006 10 2.22392 10 2.50006V4.00002H5.5C4.67158 4.00002 4 4.67159 4 5.50002V12.5C4 13.3284 4.67158 14 5.5 14H12.5C13.3284 14 14 13.3284 14 12.5V5.50002C14 4.67159 13.3284 4.00002 12.5 4.00002H11V2.50006C11 1.67163 10.3284 1.00006 9.5 1.00006H2.5C1.67157 1.00006 1 1.67163 1 2.50006V9.50006ZM5 5.50002C5 5.22388 5.22386 5.00002 5.5 5.00002H12.5C12.7761 5.00002 13 5.22388 13 5.50002V12.5C13 12.7762 12.7761 13 12.5 13H5.5C5.22386 13 5 12.7762 5 12.5V5.50002Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), jd = ["color"], Ud = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, jd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Vd = ["color"], Kd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Vd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M3.29227 0.048984C3.47033 -0.032338 3.67946 -0.00228214 3.8274 0.125891L12.8587 7.95026C13.0134 8.08432 13.0708 8.29916 13.0035 8.49251C12.9362 8.68586 12.7578 8.81866 12.5533 8.82768L9.21887 8.97474L11.1504 13.2187C11.2648 13.47 11.1538 13.7664 10.9026 13.8808L8.75024 14.8613C8.499 14.9758 8.20255 14.8649 8.08802 14.6137L6.15339 10.3703L3.86279 12.7855C3.72196 12.934 3.50487 12.9817 3.31479 12.9059C3.1247 12.8301 3 12.6461 3 12.4414V0.503792C3 0.308048 3.11422 0.130306 3.29227 0.048984ZM4 1.59852V11.1877L5.93799 9.14425C6.05238 9.02363 6.21924 8.96776 6.38319 8.99516C6.54715 9.02256 6.68677 9.12965 6.75573 9.2809L8.79056 13.7441L10.0332 13.178L8.00195 8.71497C7.93313 8.56376 7.94391 8.38824 8.03072 8.24659C8.11753 8.10494 8.26903 8.01566 8.435 8.00834L11.2549 7.88397L4 1.59852Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Wd = ["color"], Yd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Wd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z", fill: r })) })), Gd = ["color"], Zd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Gd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Xd = ["color"], _d = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Xd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M3 2C2.44772 2 2 2.44772 2 3V12C2 12.5523 2.44772 13 3 13H12C12.5523 13 13 12.5523 13 12V8.5C13 8.22386 12.7761 8 12.5 8C12.2239 8 12 8.22386 12 8.5V12H3V3L6.5 3C6.77614 3 7 2.77614 7 2.5C7 2.22386 6.77614 2 6.5 2H3ZM12.8536 2.14645C12.9015 2.19439 12.9377 2.24964 12.9621 2.30861C12.9861 2.36669 12.9996 2.4303 13 2.497L13 2.5V2.50049V5.5C13 5.77614 12.7761 6 12.5 6C12.2239 6 12 5.77614 12 5.5V3.70711L6.85355 8.85355C6.65829 9.04882 6.34171 9.04882 6.14645 8.85355C5.95118 8.65829 5.95118 8.34171 6.14645 8.14645L11.2929 3H9.5C9.22386 3 9 2.77614 9 2.5C9 2.22386 9.22386 2 9.5 2H12.4999H12.5C12.5678 2 12.6324 2.01349 12.6914 2.03794C12.7504 2.06234 12.8056 2.09851 12.8536 2.14645Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Qd = ["color"], qd = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Qd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.49933 0.25C3.49635 0.25 0.25 3.49593 0.25 7.50024C0.25 10.703 2.32715 13.4206 5.2081 14.3797C5.57084 14.446 5.70302 14.2222 5.70302 14.0299C5.70302 13.8576 5.69679 13.4019 5.69323 12.797C3.67661 13.235 3.25112 11.825 3.25112 11.825C2.92132 10.9874 2.44599 10.7644 2.44599 10.7644C1.78773 10.3149 2.49584 10.3238 2.49584 10.3238C3.22353 10.375 3.60629 11.0711 3.60629 11.0711C4.25298 12.1788 5.30335 11.8588 5.71638 11.6732C5.78225 11.205 5.96962 10.8854 6.17658 10.7043C4.56675 10.5209 2.87415 9.89918 2.87415 7.12104C2.87415 6.32925 3.15677 5.68257 3.62053 5.17563C3.54576 4.99226 3.29697 4.25521 3.69174 3.25691C3.69174 3.25691 4.30015 3.06196 5.68522 3.99973C6.26337 3.83906 6.8838 3.75895 7.50022 3.75583C8.1162 3.75895 8.73619 3.83906 9.31523 3.99973C10.6994 3.06196 11.3069 3.25691 11.3069 3.25691C11.7026 4.25521 11.4538 4.99226 11.3795 5.17563C11.8441 5.68257 12.1245 6.32925 12.1245 7.12104C12.1245 9.9063 10.4292 10.5192 8.81452 10.6985C9.07444 10.9224 9.30633 11.3648 9.30633 12.0413C9.30633 13.0102 9.29742 13.7922 9.29742 14.0299C9.29742 14.2239 9.42828 14.4496 9.79591 14.3788C12.6746 13.4179 14.75 10.7025 14.75 7.50024C14.75 3.49593 11.5036 0.25 7.49933 0.25Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Jd = ["color"], $d = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Jd); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1.44995 0.949951C1.31734 0.949951 1.19016 1.00263 1.0964 1.0964C1.00263 1.19017 0.949951 1.31735 0.949951 1.44995L0.949966 3.44995C0.949969 3.7261 1.17383 3.94995 1.44997 3.94995C1.72611 3.94995 1.94997 3.72609 1.94997 3.44995L1.94995 1.94995H3.44997C3.72611 1.94995 3.94997 1.72609 3.94997 1.44995C3.94997 1.17381 3.72611 0.949951 3.44997 0.949951H1.44995ZM5.94995 0.949951C5.67381 0.949951 5.44995 1.17381 5.44995 1.44995C5.44995 1.72609 5.67381 1.94995 5.94995 1.94995H8.94995C9.22609 1.94995 9.44995 1.72609 9.44995 1.44995C9.44995 1.17381 9.22609 0.949951 8.94995 0.949951H5.94995ZM5.44995 13.45C5.44995 13.1738 5.67381 12.95 5.94995 12.95H8.94995C9.22609 12.95 9.44995 13.1738 9.44995 13.45C9.44995 13.7261 9.22609 13.95 8.94995 13.95H5.94995C5.67381 13.95 5.44995 13.7261 5.44995 13.45ZM1.94995 5.94995C1.94995 5.67381 1.72609 5.44995 1.44995 5.44995C1.17381 5.44995 0.949951 5.67381 0.949951 5.94995V8.94995C0.949951 9.22609 1.17381 9.44995 1.44995 9.44995C1.72609 9.44995 1.94995 9.22609 1.94995 8.94995V5.94995ZM13.45 5.44995C13.7261 5.44995 13.95 5.67381 13.95 5.94995V8.94995C13.95 9.22609 13.7261 9.44995 13.45 9.44995C13.1738 9.44995 12.95 9.22609 12.95 8.94995V5.94995C12.95 5.67381 13.1738 5.44995 13.45 5.44995ZM11.45 0.949951C11.1738 0.949951 10.95 1.17381 10.95 1.44995C10.95 1.72609 11.1738 1.94995 11.45 1.94995H12.9499V3.44995C12.9499 3.72609 13.1738 3.94995 13.4499 3.94995C13.7261 3.94995 13.9499 3.72609 13.9499 3.44995V1.44995C13.9499 1.17381 13.7252 0.949951 13.449 0.949951H11.45ZM1.44995 10.95C1.72609 10.95 1.94995 11.1738 1.94995 11.45V12.95H3.44997C3.72611 12.95 3.94997 13.1738 3.94997 13.45C3.94997 13.7261 3.72611 13.95 3.44997 13.95H1.44995C1.17381 13.95 0.949951 13.7261 0.949951 13.45V11.45C0.949951 11.1738 1.17381 10.95 1.44995 10.95ZM13.95 11.45C13.95 11.1738 13.7261 10.95 13.45 10.95C13.1738 10.9499 12.95 11.1738 12.95 11.4499L12.9491 12.95H11.45C11.1738 12.95 10.95 13.1738 10.95 13.45C10.95 13.7261 11.1738 13.95 11.45 13.95H13.4499C13.7261 13.95 13.9499 13.7261 13.9499 13.45L13.95 11.45Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), ep = ["color"], tp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, ep); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1.5 3C1.22386 3 1 3.22386 1 3.5C1 3.77614 1.22386 4 1.5 4H13.5C13.7761 4 14 3.77614 14 3.5C14 3.22386 13.7761 3 13.5 3H1.5ZM1 7.5C1 7.22386 1.22386 7 1.5 7H13.5C13.7761 7 14 7.22386 14 7.5C14 7.77614 13.7761 8 13.5 8H1.5C1.22386 8 1 7.77614 1 7.5ZM1 11.5C1 11.2239 1.22386 11 1.5 11H13.5C13.7761 11 14 11.2239 14 11.5C14 11.7761 13.7761 12 13.5 12H1.5C1.22386 12 1 11.7761 1 11.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), np = ["color"], rp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, np); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1.35248 4.90532C1.35248 2.94498 2.936 1.35248 4.89346 1.35248C6.25769 1.35248 6.86058 1.92336 7.50002 2.93545C8.13946 1.92336 8.74235 1.35248 10.1066 1.35248C12.064 1.35248 13.6476 2.94498 13.6476 4.90532C13.6476 6.74041 12.6013 8.50508 11.4008 9.96927C10.2636 11.3562 8.92194 12.5508 8.00601 13.3664C7.94645 13.4194 7.88869 13.4709 7.83291 13.5206C7.64324 13.6899 7.3568 13.6899 7.16713 13.5206C7.11135 13.4709 7.05359 13.4194 6.99403 13.3664C6.0781 12.5508 4.73641 11.3562 3.59926 9.96927C2.39872 8.50508 1.35248 6.74041 1.35248 4.90532Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), ip = ["color"], op = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, ip); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), ap = ["color"], sp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, ap); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), lp = ["color"], cp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, lp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.4986 0C6.3257 0 5.36107 0.38943 4.73753 1.19361C4.23745 1.83856 4 2.68242 4 3.63325H5C5 2.84313 5.19691 2.23312 5.5278 1.80636C5.91615 1.30552 6.55152 1 7.4986 1C8.35683 1 8.96336 1.26502 9.35846 1.68623C9.75793 2.11211 10 2.76044 10 3.63601V6H3C2.44772 6 2 6.44772 2 7V13C2 13.5523 2.44772 14 3 14H12C12.5523 14 13 13.5523 13 13V7C13 6.44771 12.5523 6 12 6H11V3.63601C11 2.58135 10.7065 1.66167 10.0878 1.0021C9.46477 0.337871 8.57061 0 7.4986 0ZM3 7H12V13H3V7Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), up = ["color"], dp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, up); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M5 1.5C5 1.22386 4.77614 1 4.5 1C4.22386 1 4 1.22386 4 1.5L4 7C4 7.01671 4.00082 7.03323 4.00242 7.04952C2.86009 7.28022 2 8.28967 2 9.5C2 10.7103 2.86009 11.7198 4.00242 11.9505C4.00082 11.9668 4 11.9833 4 12V13.5C4 13.7761 4.22386 14 4.5 14C4.77614 14 5 13.7761 5 13.5V12C5 11.9833 4.99918 11.9668 4.99758 11.9505C6.1399 11.7198 7 10.7103 7 9.5C7 8.28967 6.1399 7.28022 4.99758 7.04952C4.99918 7.03323 5 7.01671 5 7L5 1.5ZM11 1.5C11 1.22386 10.7761 1 10.5 1C10.2239 1 10 1.22386 10 1.5V3C10 3.01671 10.0008 3.03323 10.0024 3.04952C8.8601 3.28022 8 4.28967 8 5.5C8 6.71033 8.8601 7.71978 10.0024 7.95048C10.0008 7.96677 10 7.98329 10 8V13.5C10 13.7761 10.2239 14 10.5 14C10.7761 14 11 13.7761 11 13.5V8C11 7.98329 10.9992 7.96677 10.9976 7.95048C12.1399 7.71978 13 6.71033 13 5.5C13 4.28967 12.1399 3.28022 10.9976 3.04952C10.9992 3.03323 11 3.01671 11 3V1.5ZM4.5 8C3.67157 8 3 8.67157 3 9.5C3 10.3284 3.67157 11 4.5 11C5.32843 11 6 10.3284 6 9.5C6 8.67157 5.32843 8 4.5 8ZM9 5.5C9 4.67157 9.67157 4 10.5 4C11.3284 4 12 4.67157 12 5.5C12 6.32843 11.3284 7 10.5 7C9.67157 7 9 6.32843 9 5.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), pp = ["color"], hp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, pp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M11.8536 1.14645C11.6583 0.951184 11.3417 0.951184 11.1465 1.14645L3.71455 8.57836C3.62459 8.66832 3.55263 8.77461 3.50251 8.89155L2.04044 12.303C1.9599 12.491 2.00189 12.709 2.14646 12.8536C2.29103 12.9981 2.50905 13.0401 2.69697 12.9596L6.10847 11.4975C6.2254 11.4474 6.3317 11.3754 6.42166 11.2855L13.8536 3.85355C14.0488 3.65829 14.0488 3.34171 13.8536 3.14645L11.8536 1.14645ZM4.42166 9.28547L11.5 2.20711L12.7929 3.5L5.71455 10.5784L4.21924 11.2192L3.78081 10.7808L4.42166 9.28547Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), fp = ["color"], mp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, fp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M12.1464 1.14645C12.3417 0.951184 12.6583 0.951184 12.8535 1.14645L14.8535 3.14645C15.0488 3.34171 15.0488 3.65829 14.8535 3.85355L10.9109 7.79618C10.8349 7.87218 10.7471 7.93543 10.651 7.9835L6.72359 9.94721C6.53109 10.0435 6.29861 10.0057 6.14643 9.85355C5.99425 9.70137 5.95652 9.46889 6.05277 9.27639L8.01648 5.34897C8.06455 5.25283 8.1278 5.16507 8.2038 5.08907L12.1464 1.14645ZM12.5 2.20711L8.91091 5.79618L7.87266 7.87267L8.12731 8.12732L10.2038 7.08907L13.7929 3.5L12.5 2.20711ZM9.99998 2L8.99998 3H4.9C4.47171 3 4.18056 3.00039 3.95552 3.01877C3.73631 3.03668 3.62421 3.06915 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3.06915 3.62421 3.03669 3.73631 3.01878 3.95552C3.00039 4.18056 3 4.47171 3 4.9V11.1C3 11.5283 3.00039 11.8194 3.01878 12.0445C3.03669 12.2637 3.06915 12.3758 3.10899 12.454C3.20487 12.6422 3.35785 12.7951 3.54601 12.891C3.62421 12.9309 3.73631 12.9633 3.95552 12.9812C4.18056 12.9996 4.47171 13 4.9 13H11.1C11.5283 13 11.8194 12.9996 12.0445 12.9812C12.2637 12.9633 12.3758 12.9309 12.454 12.891C12.6422 12.7951 12.7951 12.6422 12.891 12.454C12.9309 12.3758 12.9633 12.2637 12.9812 12.0445C12.9996 11.8194 13 11.5283 13 11.1V6.99998L14 5.99998V11.1V11.1207C14 11.5231 14 11.8553 13.9779 12.1259C13.9549 12.407 13.9057 12.6653 13.782 12.908C13.5903 13.2843 13.2843 13.5903 12.908 13.782C12.6653 13.9057 12.407 13.9549 12.1259 13.9779C11.8553 14 11.5231 14 11.1207 14H11.1H4.9H4.87934C4.47686 14 4.14468 14 3.87409 13.9779C3.59304 13.9549 3.33469 13.9057 3.09202 13.782C2.7157 13.5903 2.40973 13.2843 2.21799 12.908C2.09434 12.6653 2.04506 12.407 2.0221 12.1259C1.99999 11.8553 1.99999 11.5231 2 11.1207V11.1206V11.1V4.9V4.87935V4.87932V4.87931C1.99999 4.47685 1.99999 4.14468 2.0221 3.87409C2.04506 3.59304 2.09434 3.33469 2.21799 3.09202C2.40973 2.71569 2.7157 2.40973 3.09202 2.21799C3.33469 2.09434 3.59304 2.04506 3.87409 2.0221C4.14468 1.99999 4.47685 1.99999 4.87932 2H4.87935H4.9H9.99998Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), gp = ["color"], vp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, gp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M13.5 13.95C13.7485 13.95 13.95 13.7485 13.95 13.5C13.95 13.2514 13.7485 13.05 13.5 13.05L1.49995 13.05C1.25142 13.05 1.04995 13.2514 1.04995 13.5C1.04995 13.7485 1.25142 13.95 1.49995 13.95L13.5 13.95ZM11.0681 7.5683C11.2439 7.39257 11.2439 7.10764 11.0681 6.93191C10.8924 6.75617 10.6075 6.75617 10.4317 6.93191L7.94993 9.41371L7.94993 1.49998C7.94993 1.25146 7.74846 1.04998 7.49993 1.04998C7.2514 1.04998 7.04993 1.25146 7.04993 1.49998L7.04993 9.41371L4.56813 6.93191C4.39239 6.75617 4.10746 6.75617 3.93173 6.93191C3.75599 7.10764 3.75599 7.39257 3.93173 7.5683L7.18173 10.8183C7.35746 10.994 7.64239 10.994 7.81812 10.8183L11.0681 7.5683Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), yp = ["color"], bp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, yp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1.50005 1.05005C1.25152 1.05005 1.05005 1.25152 1.05005 1.50005C1.05005 1.74858 1.25152 1.95005 1.50005 1.95005L13.5 1.95005C13.7486 1.95005 13.95 1.74858 13.95 1.50005C13.95 1.25152 13.7486 1.05005 13.5 1.05005H1.50005ZM3.93188 7.43169C3.75614 7.60743 3.75614 7.89236 3.93188 8.06809C4.10761 8.24383 4.39254 8.24383 4.56827 8.06809L7.05007 5.58629V13.5C7.05007 13.7485 7.25155 13.95 7.50007 13.95C7.7486 13.95 7.95007 13.7485 7.95007 13.5L7.95007 5.58629L10.4319 8.06809C10.6076 8.24383 10.8925 8.24383 11.0683 8.06809C11.244 7.89235 11.244 7.60743 11.0683 7.43169L7.81827 4.18169C7.64254 4.00596 7.35761 4.00596 7.18188 4.18169L3.93188 7.43169Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), wp = ["color"], Ep = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, wp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M8 2.75C8 2.47386 7.77614 2.25 7.5 2.25C7.22386 2.25 7 2.47386 7 2.75V7H2.75C2.47386 7 2.25 7.22386 2.25 7.5C2.25 7.77614 2.47386 8 2.75 8H7V12.25C7 12.5261 7.22386 12.75 7.5 12.75C7.77614 12.75 8 12.5261 8 12.25V8H12.25C12.5261 8 12.75 7.77614 12.75 7.5C12.75 7.22386 12.5261 7 12.25 7H8V2.75Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Cp = ["color"], Sp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Cp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M5.07505 4.10001C5.07505 2.91103 6.25727 1.92502 7.50005 1.92502C8.74283 1.92502 9.92505 2.91103 9.92505 4.10001C9.92505 5.19861 9.36782 5.71436 8.61854 6.37884L8.58757 6.4063C7.84481 7.06467 6.92505 7.87995 6.92505 9.5C6.92505 9.81757 7.18248 10.075 7.50005 10.075C7.81761 10.075 8.07505 9.81757 8.07505 9.5C8.07505 8.41517 8.62945 7.90623 9.38156 7.23925L9.40238 7.22079C10.1496 6.55829 11.075 5.73775 11.075 4.10001C11.075 2.12757 9.21869 0.775024 7.50005 0.775024C5.7814 0.775024 3.92505 2.12757 3.92505 4.10001C3.92505 4.41758 4.18249 4.67501 4.50005 4.67501C4.81761 4.67501 5.07505 4.41758 5.07505 4.10001ZM7.50005 13.3575C7.9833 13.3575 8.37505 12.9657 8.37505 12.4825C8.37505 11.9992 7.9833 11.6075 7.50005 11.6075C7.0168 11.6075 6.62505 11.9992 6.62505 12.4825C6.62505 12.9657 7.0168 13.3575 7.50005 13.3575Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), kp = ["color"], xp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, kp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.59664 2.93628C7.76085 3.06401 8.00012 2.94698 8.00012 2.73895V1.99998C9.98143 2 11.1848 2.3637 11.9105 3.08945C12.6363 3.81522 13 5.0186 13 6.99998C13 7.27613 13.2239 7.49998 13.5 7.49998C13.7761 7.49998 14 7.27613 14 6.99998C14 4.9438 13.6325 3.39719 12.6176 2.38234C11.6028 1.36752 10.0562 0.999999 8.00012 0.999984V0.261266C8.00012 0.0532293 7.76085 -0.0637944 7.59664 0.063928L6.00384 1.30277C5.87516 1.40286 5.87516 1.59735 6.00384 1.69744L7.59664 2.93628ZM9.5 5H2.5C2.22386 5 2 5.22386 2 5.5V12.5C2 12.7761 2.22386 13 2.5 13H9.5C9.77614 13 10 12.7761 10 12.5V5.5C10 5.22386 9.77614 5 9.5 5ZM2.5 4C1.67157 4 1 4.67157 1 5.5V12.5C1 13.3284 1.67157 14 2.5 14H9.5C10.3284 14 11 13.3284 11 12.5V5.5C11 4.67157 10.3284 4 9.5 4H2.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Ap = ["color"], Ip = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Ap); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992ZM0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992ZM1.99998 6.99994C1.99998 6.44766 2.44769 5.99995 2.99998 5.99995L5.99995 5.99995C6.55223 5.99995 6.99994 6.44766 6.99994 6.99994L6.99994 7.99993C6.99994 8.55221 6.55223 8.99992 5.99995 8.99992L2.99998 8.99992C2.4477 8.99992 1.99998 8.55221 1.99998 7.99993L1.99998 6.99994ZM8.99993 5.99995C8.44765 5.99995 7.99993 6.44766 7.99993 6.99994L7.99993 7.99993C7.99993 8.55221 8.44765 8.99992 8.99993 8.99992L11.9999 8.99992C12.5522 8.99992 12.9999 8.55221 12.9999 7.99993L12.9999 6.99994C12.9999 6.44766 12.5522 5.99995 11.9999 5.99995L8.99993 5.99995Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Pp = ["color"], Mp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Pp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM7 2C6.44772 2 6 2.44772 6 3V6C6 6.55228 6.44772 7 7 7H8C8.55228 7 9 6.55228 9 6V3C9 2.44772 8.55228 2 8 2H7ZM7 8C6.44772 8 6 8.44771 6 9V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V9C9 8.44772 8.55228 8 8 8H7ZM1.49988 14C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H1.49988Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Tp = ["color"], Rp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Tp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M1 1H1.5H13.5H14V1.5V13.5V14H13.5H1.5H1V13.5V1.5V1ZM2 2V13H13V2H2Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Bp = ["color"], Dp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Bp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M14.4999 0.999992C14.2237 0.999992 13.9999 1.22385 13.9999 1.49999L13.9999 5.99995L0.999992 5.99995L0.999992 1.49999C0.999992 1.22385 0.776136 0.999992 0.499996 0.999992C0.223856 0.999992 -9.78509e-09 1.22385 -2.18556e-08 1.49999L4.07279e-07 13.4999C3.95208e-07 13.776 0.223855 13.9999 0.499996 13.9999C0.776136 13.9999 0.999992 13.776 0.999992 13.4999L0.999992 8.99992L13.9999 8.99992L13.9999 13.4999C13.9999 13.776 14.2237 13.9999 14.4999 13.9999C14.776 13.9999 14.9999 13.776 14.9999 13.4999L14.9999 1.49999C14.9999 1.22385 14.776 0.999992 14.4999 0.999992Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Lp = ["color"], Op = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Lp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M0.999878 0.5C0.999878 0.223858 1.22374 0 1.49988 0H13.4999C13.776 0 13.9999 0.223858 13.9999 0.5C13.9999 0.776142 13.776 1 13.4999 1H6H1.49988C1.22374 1 0.999878 0.776142 0.999878 0.5ZM9 14V1L6 1V14H1.49988C1.22374 14 0.999878 14.2239 0.999878 14.5C0.999878 14.7761 1.22374 15 1.49988 15H13.4999C13.776 15 13.9999 14.7761 13.9999 14.5C13.9999 14.2239 13.776 14 13.4999 14H9Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Fp = ["color"], zp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Fp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M3.94993 2.95002L3.94993 4.49998C3.94993 4.74851 3.74845 4.94998 3.49993 4.94998C3.2514 4.94998 3.04993 4.74851 3.04993 4.49998V2.50004C3.04993 2.45246 3.05731 2.40661 3.07099 2.36357C3.12878 2.18175 3.29897 2.05002 3.49993 2.05002H11.4999C11.6553 2.05002 11.7922 2.12872 11.8731 2.24842C11.9216 2.32024 11.9499 2.40682 11.9499 2.50002L11.9499 2.50004V4.49998C11.9499 4.74851 11.7485 4.94998 11.4999 4.94998C11.2514 4.94998 11.0499 4.74851 11.0499 4.49998V2.95002H8.04993V12.05H9.25428C9.50281 12.05 9.70428 12.2515 9.70428 12.5C9.70428 12.7486 9.50281 12.95 9.25428 12.95H5.75428C5.50575 12.95 5.30428 12.7486 5.30428 12.5C5.30428 12.2515 5.50575 12.05 5.75428 12.05H6.94993V2.95002H3.94993Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Hp = ["color"], Np = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Hp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM4 7.5C4 7.22386 4.22386 7 4.5 7H10.5C10.7761 7 11 7.22386 11 7.5C11 7.77614 10.7761 8 10.5 8H4.5C4.22386 8 4 7.77614 4 7.5ZM3 10.5C3 10.2239 3.22386 10 3.5 10H11.5C11.7761 10 12 10.2239 12 10.5C12 10.7761 11.7761 11 11.5 11H3.5C3.22386 11 3 10.7761 3 10.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), jp = ["color"], Up = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, jp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M2.5 4C2.22386 4 2 4.22386 2 4.5C2 4.77614 2.22386 5 2.5 5H12.5C12.7761 5 13 4.77614 13 4.5C13 4.22386 12.7761 4 12.5 4H2.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Vp = ["color"], Kp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Vp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM2 7.5C2 7.22386 2.22386 7 2.5 7H7.5C7.77614 7 8 7.22386 8 7.5C8 7.77614 7.77614 8 7.5 8H2.5C2.22386 8 2 7.77614 2 7.5ZM2 10.5C2 10.2239 2.22386 10 2.5 10H10.5C10.7761 10 11 10.2239 11 10.5C11 10.7761 10.7761 11 10.5 11H2.5C2.22386 11 2 10.7761 2 10.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Wp = ["color"], Yp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Wp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M2 4.5C2 4.22386 2.22386 4 2.5 4H12.5C12.7761 4 13 4.22386 13 4.5C13 4.77614 12.7761 5 12.5 5H2.5C2.22386 5 2 4.77614 2 4.5ZM7 7.5C7 7.22386 7.22386 7 7.5 7H12.5C12.7761 7 13 7.22386 13 7.5C13 7.77614 12.7761 8 12.5 8H7.5C7.22386 8 7 7.77614 7 7.5ZM4 10.5C4 10.2239 4.22386 10 4.5 10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H4.5C4.22386 11 4 10.7761 4 10.5Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Gp = ["color"], Zp = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Gp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.23336 4.69629C7.23336 2.96884 8.63335 1.56857 10.36 1.56857C11.3736 1.56857 12.183 2.04804 12.7254 2.74385C13.3079 2.62467 13.8557 2.40913 14.3513 2.11508C14.1559 2.72598 13.7424 3.2396 13.2033 3.56463C13.2038 3.56568 13.2042 3.56674 13.2047 3.56779C13.7334 3.50361 14.2364 3.36302 14.7048 3.15546L14.7037 3.15715C14.3667 3.66183 13.9431 4.10736 13.4561 4.47034C13.4823 4.64672 13.4956 4.82427 13.4956 5.00079C13.4956 8.6871 10.6873 12.9746 5.52122 12.9746C3.93906 12.9746 2.46544 12.511 1.22505 11.7152C0.992632 11.5661 0.925108 11.2568 1.07423 11.0244C1.0874 11.0038 1.10183 10.9846 1.11734 10.9666C1.20582 10.8202 1.37438 10.7309 1.5554 10.7522C2.47066 10.8601 3.38568 10.7485 4.19219 10.3962C3.39226 10.0434 2.77129 9.35975 2.50204 8.51974C2.45359 8.3686 2.48835 8.20311 2.59351 8.08422C2.59716 8.0801 2.60087 8.07606 2.60464 8.0721C1.96391 7.50819 1.55973 6.68208 1.55973 5.76143V5.72759C1.55973 5.56814 1.64411 5.42059 1.78155 5.33974C1.82671 5.31317 1.87537 5.29511 1.92532 5.28558C1.70549 4.86154 1.58116 4.37984 1.58116 3.86958C1.58116 3.40165 1.58384 2.81192 1.91332 2.28081C1.98718 2.16175 2.10758 2.08915 2.2364 2.07195C2.42588 2.01237 2.64087 2.06969 2.77406 2.23302C3.86536 3.57126 5.44066 4.49583 7.23366 4.73961L7.23336 4.69629ZM5.52122 11.9746C4.73387 11.9746 3.97781 11.8435 3.27248 11.6023C4.13012 11.4538 4.95307 11.1159 5.66218 10.5602C5.81211 10.4427 5.87182 10.2435 5.81126 10.0629C5.7507 9.88234 5.583 9.75943 5.39255 9.75607C4.68968 9.74366 4.06712 9.39716 3.67793 8.86845C3.86828 8.85306 4.05428 8.82039 4.23445 8.77167C4.43603 8.71716 4.57363 8.53114 4.56674 8.32243C4.55985 8.11372 4.41029 7.93718 4.20555 7.89607C3.42694 7.73977 2.79883 7.16764 2.56169 6.42174C2.76255 6.47025 2.97102 6.4991 3.18482 6.5061C3.38563 6.51267 3.56646 6.38533 3.62795 6.19405C3.68943 6.00277 3.61666 5.79391 3.44963 5.68224C2.86523 5.29155 2.48116 4.62464 2.48116 3.86958C2.48116 3.70213 2.48352 3.55268 2.49355 3.41719C3.85115 4.79913 5.70873 5.68931 7.77588 5.79338C7.93225 5.80126 8.08328 5.73543 8.18395 5.61553C8.28463 5.49562 8.32332 5.33548 8.28851 5.18284C8.25255 5.02517 8.23336 4.86284 8.23336 4.69629C8.23336 3.52085 9.18591 2.56857 10.36 2.56857C11.5943 2.56857 12.4956 3.71208 12.4956 5.00079C12.4956 8.25709 10.0202 11.9746 5.52122 11.9746Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })), Xp = ["color"], _p = (0, A.forwardRef)((function (e, t) { var n = e.color, r = void 0 === n ? "currentColor" : n, i = od(e, Xp); return (0, A.createElement)("svg", Object.assign({ width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i, { ref: t }), (0, A.createElement)("path", { d: "M7.49998 1L6.92321 2.00307L1.17498 12L0.599976 13H1.7535H13.2464H14.4L13.825 12L8.07674 2.00307L7.49998 1ZM7.49998 3.00613L2.3285 12H12.6714L7.49998 3.00613Z", fill: r, fillRule: "evenodd", clipRule: "evenodd" })) })); function Qp() { var e = A.useContext(ir); return zi(e), e } function qp(e) { var t = Qp(), n = t.formatMessage, r = t.textComponent, i = void 0 === r ? A.Fragment : r, o = e.id, a = e.description, s = e.defaultMessage, l = e.values, c = e.children, u = e.tagName, d = void 0 === u ? i : u, p = n({ id: o, description: a, defaultMessage: s }, l, { ignoreTag: e.ignoreTag }); return "function" == typeof c ? c(Array.isArray(p) ? p : [p]) : d ? A.createElement(d, null, A.Children.toArray(p)) : A.createElement(A.Fragment, null, p) } qp.displayName = "FormattedMessage"; var Jp = A.memo(qp, (function (e, t) { var n = e.values, r = qn(e, ["values"]), i = t.values, o = qn(t, ["values"]); return Ni(i, n) && Ni(r, o) })); Jp.displayName = "MemoizedFormattedMessage"; const $p = Jp; var eh, th = "colors", nh = "sizes", rh = "space", ih = { gap: rh, gridGap: rh, columnGap: rh, gridColumnGap: rh, rowGap: rh, gridRowGap: rh, inset: rh, insetBlock: rh, insetBlockEnd: rh, insetBlockStart: rh, insetInline: rh, insetInlineEnd: rh, insetInlineStart: rh, margin: rh, marginTop: rh, marginRight: rh, marginBottom: rh, marginLeft: rh, marginBlock: rh, marginBlockEnd: rh, marginBlockStart: rh, marginInline: rh, marginInlineEnd: rh, marginInlineStart: rh, padding: rh, paddingTop: rh, paddingRight: rh, paddingBottom: rh, paddingLeft: rh, paddingBlock: rh, paddingBlockEnd: rh, paddingBlockStart: rh, paddingInline: rh, paddingInlineEnd: rh, paddingInlineStart: rh, top: rh, right: rh, bottom: rh, left: rh, scrollMargin: rh, scrollMarginTop: rh, scrollMarginRight: rh, scrollMarginBottom: rh, scrollMarginLeft: rh, scrollMarginX: rh, scrollMarginY: rh, scrollMarginBlock: rh, scrollMarginBlockEnd: rh, scrollMarginBlockStart: rh, scrollMarginInline: rh, scrollMarginInlineEnd: rh, scrollMarginInlineStart: rh, scrollPadding: rh, scrollPaddingTop: rh, scrollPaddingRight: rh, scrollPaddingBottom: rh, scrollPaddingLeft: rh, scrollPaddingX: rh, scrollPaddingY: rh, scrollPaddingBlock: rh, scrollPaddingBlockEnd: rh, scrollPaddingBlockStart: rh, scrollPaddingInline: rh, scrollPaddingInlineEnd: rh, scrollPaddingInlineStart: rh, fontSize: "fontSizes", background: th, backgroundColor: th, backgroundImage: th, borderImage: th, border: th, borderBlock: th, borderBlockEnd: th, borderBlockStart: th, borderBottom: th, borderBottomColor: th, borderColor: th, borderInline: th, borderInlineEnd: th, borderInlineStart: th, borderLeft: th, borderLeftColor: th, borderRight: th, borderRightColor: th, borderTop: th, borderTopColor: th, caretColor: th, color: th, columnRuleColor: th, fill: th, outline: th, outlineColor: th, stroke: th, textDecorationColor: th, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: nh, minBlockSize: nh, maxBlockSize: nh, inlineSize: nh, minInlineSize: nh, maxInlineSize: nh, width: nh, minWidth: nh, maxWidth: nh, height: nh, minHeight: nh, maxHeight: nh, flexBasis: nh, gridTemplateColumns: nh, gridTemplateRows: nh, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" }, oh = (e, t) => "function" == typeof t ? { "()": Function.prototype.toString.call(t) } : t, ah = () => { const e = Object.create(null); return (t, n, ...r) => { const i = (e => JSON.stringify(e, oh))(t); return i in e ? e[i] : e[i] = n(t, ...r) } }, sh = Symbol.for("sxs.internal"), lh = (e, t) => Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)), ch = e => { for (const t in e) return !0; return !1 }, { hasOwnProperty: uh } = Object.prototype, dh = e => e.includes("-") ? e : e.replace(/[A-Z]/g, (e => "-" + e.toLowerCase())), ph = /\s+(?![^()]*\))/, hh = e => t => e(..."string" == typeof t ? String(t).split(ph) : [t]), fh = { appearance: e => ({ WebkitAppearance: e, appearance: e }), backfaceVisibility: e => ({ WebkitBackfaceVisibility: e, backfaceVisibility: e }), backdropFilter: e => ({ WebkitBackdropFilter: e, backdropFilter: e }), backgroundClip: e => ({ WebkitBackgroundClip: e, backgroundClip: e }), boxDecorationBreak: e => ({ WebkitBoxDecorationBreak: e, boxDecorationBreak: e }), clipPath: e => ({ WebkitClipPath: e, clipPath: e }), content: e => ({ content: e.includes('"') || e.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e) ? e : `"${e}"` }), hyphens: e => ({ WebkitHyphens: e, hyphens: e }), maskImage: e => ({ WebkitMaskImage: e, maskImage: e }), maskSize: e => ({ WebkitMaskSize: e, maskSize: e }), tabSize: e => ({ MozTabSize: e, tabSize: e }), textSizeAdjust: e => ({ WebkitTextSizeAdjust: e, textSizeAdjust: e }), userSelect: e => ({ WebkitUserSelect: e, userSelect: e }), marginBlock: hh(((e, t) => ({ marginBlockStart: e, marginBlockEnd: t || e }))), marginInline: hh(((e, t) => ({ marginInlineStart: e, marginInlineEnd: t || e }))), maxSize: hh(((e, t) => ({ maxBlockSize: e, maxInlineSize: t || e }))), minSize: hh(((e, t) => ({ minBlockSize: e, minInlineSize: t || e }))), paddingBlock: hh(((e, t) => ({ paddingBlockStart: e, paddingBlockEnd: t || e }))), paddingInline: hh(((e, t) => ({ paddingInlineStart: e, paddingInlineEnd: t || e }))) }, mh = /([\d.]+)([^]*)/, gh = (e, t) => e.length ? e.reduce(((e, n) => (e.push(...t.map((e => e.includes("&") ? e.replace(/&/g, /[ +>|~]/.test(n) && /&.*&/.test(e) ? `:is(${n})` : n) : n + " " + e))), e)), []) : t, vh = (e, t) => e in yh && "string" == typeof t ? t.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, ((t, n, r, i) => n + ("stretch" === r ? `-moz-available${i};${dh(e)}:${n}-webkit-fill-available` : `-moz-fit-content${i};${dh(e)}:${n}fit-content`) + i)) : String(t), yh = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 }, bh = e => e ? e + "-" : "", wh = (e, t, n) => e.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, ((e, r, i, o, a) => "$" == o == !!i ? e : (r || "--" == o ? "calc(" : "") + "var(--" + ("$" === o ? bh(t) + (a.includes("$") ? "" : bh(n)) + a.replace(/\$/g, "-") : a) + ")" + (r || "--" == o ? "*" + (r || "") + (i || "1") + ")" : ""))), Eh = /\s*,\s*(?![^()]*\))/, Ch = Object.prototype.toString, Sh = (e, t, n, r, i) => { let o, a, s; const l = (e, t, n) => { let c, u; const d = e => { for (c in e) { const f = 64 === c.charCodeAt(0), m = f && Array.isArray(e[c]) ? e[c] : [e[c]]; for (u of m) { const e = /[A-Z]/.test(h = c) ? h : h.replace(/-[^]/g, (e => e[1].toUpperCase())), m = "object" == typeof u && u && u.toString === Ch && (!r.utils[e] || !t.length); if (e in r.utils && !m) { const t = r.utils[e]; if (t !== a) { a = t, d(t(u)), a = null; continue } } else if (e in fh) { const t = fh[e]; if (t !== s) { s = t, d(t(u)), s = null; continue } } if (f && (p = c.slice(1) in r.media ? "@media " + r.media[c.slice(1)] : c, c = p.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, ((e, t, n, r, i, o) => { const a = mh.test(t), s = .0625 * (a ? -1 : 1), [l, c] = a ? [r, t] : [t, r]; return "(" + ("=" === n[0] ? "" : ">" === n[0] === a ? "max-" : "min-") + l + ":" + ("=" !== n[0] && 1 === n.length ? c.replace(mh, ((e, t, r) => Number(t) + s * (">" === n ? 1 : -1) + r)) : c) + (i ? ") and (" + (">" === i[0] ? "min-" : "max-") + l + ":" + (1 === i.length ? o.replace(mh, ((e, t, n) => Number(t) + s * (">" === i ? -1 : 1) + n)) : o) : "") + ")" }))), m) { const e = f ? n.concat(c) : [...n], r = f ? [...t] : gh(t, c.split(Eh)); void 0 !== o && i(kh(...o)), o = void 0, l(u, r, e) } else void 0 === o && (o = [[], t, n]), c = f || 36 !== c.charCodeAt(0) ? c : `--${bh(r.prefix)}${c.slice(1).replace(/\$/g, "-")}`, u = m ? u : "number" == typeof u ? u && e in xh ? String(u) + "px" : String(u) : wh(vh(e, null == u ? "" : u), r.prefix, r.themeMap[e]), o[0].push(`${f ? `${c} ` : `${dh(c)}:`}${u}`) } } var p, h }; d(e), void 0 !== o && i(kh(...o)), o = void 0 }; l(e, t, n) }, kh = (e, t, n) => `${n.map((e => `${e}{`)).join("")}${t.length ? `${t.join(",")}{` : ""}${e.join(";")}${t.length ? "}" : ""}${Array(n.length ? n.length + 1 : 0).join("}")}`, xh = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 }, Ah = e => String.fromCharCode(e + (e > 25 ? 39 : 97)), Ih = e => (e => { let t, n = ""; for (t = Math.abs(e); t > 52; t = t / 52 | 0)n = Ah(t % 52) + n; return Ah(t % 52) + n })(((e, t) => { let n = t.length; for (; n;)e = 33 * e ^ t.charCodeAt(--n); return e })(5381, JSON.stringify(e)) >>> 0), Ph = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"], Mh = e => { if (e.href && !e.href.startsWith(location.origin)) return !1; try { return !!e.cssRules } catch (e) { return !1 } }, Th = e => { let t; const n = () => { const { cssRules: e } = t.sheet; return [].map.call(e, ((n, r) => { const { cssText: i } = n; let o = ""; if (i.startsWith("--sxs")) return ""; if (e[r - 1] && (o = e[r - 1].cssText).startsWith("--sxs")) { if (!n.cssRules.length) return ""; for (const e in t.rules) if (t.rules[e].group === n) return `--sxs{--sxs:${[...t.rules[e].cache].join(" ")}}${i}`; return n.cssRules.length ? `${o}${i}` : "" } return i })).join("") }, r = () => { if (t) { const { rules: e, sheet: n } = t; if (!n.deleteRule) { for (; 3 === Object(Object(n.cssRules)[0]).type;)n.cssRules.splice(0, 1); n.cssRules = [] } for (const t in e) delete e[t] } const i = Object(e).styleSheets || []; for (const e of i) if (Mh(e)) { for (let i = 0, o = e.cssRules; o[i]; ++i) { const a = Object(o[i]); if (1 !== a.type) continue; const s = Object(o[i + 1]); if (4 !== s.type) continue; ++i; const { cssText: l } = a; if (!l.startsWith("--sxs")) continue; const c = l.slice(14, -3).trim().split(/\s+/), u = Ph[c[0]]; u && (t || (t = { sheet: e, reset: r, rules: {}, toString: n }), t.rules[u] = { group: s, index: i, cache: new Set(c) }) } if (t) break } if (!t) { const i = (e, t) => ({ type: t, cssRules: [], insertRule(e, t) { this.cssRules.splice(t, 0, i(e, { import: 3, undefined: 1 }[(e.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4)) }, get cssText() { return "@media{}" === e ? `@media{${[].map.call(this.cssRules, (e => e.cssText)).join("")}}` : e } }); t = { sheet: e ? (e.head || e).appendChild(document.createElement("style")).sheet : i("", "text/css"), rules: {}, reset: r, toString: n } } const { sheet: o, rules: a } = t; for (let e = Ph.length - 1; e >= 0; --e) { const t = Ph[e]; if (!a[t]) { const n = Ph[e + 1], r = a[n] ? a[n].index : o.cssRules.length; o.insertRule("@media{}", r), o.insertRule(`--sxs{--sxs:${e}}`, r), a[t] = { group: o.cssRules[r + 1], index: r, cache: new Set([e]) } } Rh(a[t]) } }; return r(), t }, Rh = e => { const t = e.group; let n = t.cssRules.length; e.apply = e => { try { t.insertRule(e, n), ++n } catch (e) { } } }, Bh = Symbol(), Dh = ah(), Lh = (e, t) => Dh(e, (() => (...n) => { let r = { type: null, composers: new Set }; for (const t of n) if (null != t) if (t[sh]) { null == r.type && (r.type = t[sh].type); for (const e of t[sh].composers) r.composers.add(e) } else t.constructor !== Object || t.$$typeof ? null == r.type && (r.type = t) : r.composers.add(Oh(t, e)); return null == r.type && (r.type = "span"), r.composers.size || r.composers.add(["PJLV", {}, [], [], {}, []]), Fh(e, r, t) })), Oh = ({ variants: e, compoundVariants: t, defaultVariants: n, ...r }, i) => { const o = `${bh(i.prefix)}c-${Ih(r)}`, a = [], s = [], l = Object.create(null), c = []; for (const e in n) l[e] = String(n[e]); if ("object" == typeof e && e) for (const t in e) { u = l, d = t, uh.call(u, d) || (l[t] = "undefined"); const n = e[t]; for (const e in n) { const r = { [t]: String(e) }; "undefined" === String(e) && c.push(t); const i = n[e], o = [r, i, !ch(i)]; a.push(o) } } var u, d; if ("object" == typeof t && t) for (const e of t) { let { css: t, ...n } = e; t = "object" == typeof t && t || {}; for (const e in n) n[e] = String(n[e]); const r = [n, t, !ch(t)]; s.push(r) } return [o, r, a, s, l, c] }, Fh = (e, t, n) => { const [r, i, o, a] = zh(t.composers), s = "function" == typeof t.type || t.type.$$typeof ? (e => { function t() { for (let n = 0; n < t[Bh].length; n++) { const [r, i] = t[Bh][n]; e.rules[r].apply(i) } return t[Bh] = [], null } return t[Bh] = [], t.rules = {}, Ph.forEach((e => t.rules[e] = { apply: n => t[Bh].push([e, n]) })), t })(n) : null, l = (s || n).rules, c = `.${r}${i.length > 1 ? `:where(.${i.slice(1).join(".")})` : ""}`, u = u => { u = "object" == typeof u && u || Nh; const { css: d, ...p } = u, h = {}; for (const e in o) if (delete p[e], e in u) { let t = u[e]; "object" == typeof t && t ? h[e] = { "@initial": o[e], ...t } : (t = String(t), h[e] = "undefined" !== t || a.has(e) ? t : o[e]) } else h[e] = o[e]; const f = new Set([...i]); for (const [r, i, o, a] of t.composers) { n.rules.styled.cache.has(r) || (n.rules.styled.cache.add(r), Sh(i, [`.${r}`], [], e, (e => { l.styled.apply(e) }))); const t = Hh(o, h, e.media), s = Hh(a, h, e.media, !0); for (const i of t) if (void 0 !== i) for (const [t, o, a] of i) { const i = `${r}-${Ih(o)}-${t}`; f.add(i); const s = (a ? n.rules.resonevar : n.rules.onevar).cache, c = a ? l.resonevar : l.onevar; s.has(i) || (s.add(i), Sh(o, [`.${i}`], [], e, (e => { c.apply(e) }))) } for (const t of s) if (void 0 !== t) for (const [i, o] of t) { const t = `${r}-${Ih(o)}-${i}`; f.add(t), n.rules.allvar.cache.has(t) || (n.rules.allvar.cache.add(t), Sh(o, [`.${t}`], [], e, (e => { l.allvar.apply(e) }))) } } if ("object" == typeof d && d) { const t = `${r}-i${Ih(d)}-css`; f.add(t), n.rules.inline.cache.has(t) || (n.rules.inline.cache.add(t), Sh(d, [`.${t}`], [], e, (e => { l.inline.apply(e) }))) } for (const e of String(u.className || "").trim().split(/\s+/)) e && f.add(e); const m = p.className = [...f].join(" "); return { type: t.type, className: m, selector: c, props: p, toString: () => m, deferredInjector: s } }; return lh(u, { className: r, selector: c, [sh]: t, toString: () => (n.rules.styled.cache.has(r) || u(), r) }) }, zh = e => { let t = ""; const n = [], r = {}, i = []; for (const [o, , , , a, s] of e) { "" === t && (t = o), n.push(o), i.push(...s); for (const e in a) { const t = a[e]; (void 0 === r[e] || "undefined" !== t || s.includes(t)) && (r[e] = t) } } return [t, n, r, new Set(i)] }, Hh = (e, t, n, r) => { const i = []; e: for (let [o, a, s] of e) { if (s) continue; let e, l = 0, c = !1; for (e in o) { const r = o[e]; let i = t[e]; if (i !== r) { if ("object" != typeof i || !i) continue e; { let e, t, o = 0; for (const a in i) { if (r === String(i[a])) { if ("@initial" !== a) { const e = a.slice(1); (t = t || []).push(e in n ? n[e] : a.replace(/^@media ?/, "")), c = !0 } l += o, e = !0 } ++o } if (t && t.length && (a = { ["@media " + t.join(", ")]: a }), !e) continue e } } } (i[l] = i[l] || []).push([r ? "cv" : `${e}-${o[e]}`, a, c]) } return i }, Nh = {}, jh = ah(), Uh = (e, t) => jh(e, (() => (...n) => { const r = () => { for (let r of n) { r = "object" == typeof r && r || {}; let n = Ih(r); if (!t.rules.global.cache.has(n)) { if (t.rules.global.cache.add(n), "@import" in r) { let e = [].indexOf.call(t.sheet.cssRules, t.rules.themed.group) - 1; for (let n of [].concat(r["@import"])) n = n.includes('"') || n.includes("'") ? n : `"${n}"`, t.sheet.insertRule(`@import ${n};`, e++); delete r["@import"] } Sh(r, [], [], e, (e => { t.rules.global.apply(e) })) } } return "" }; return lh(r, { toString: r }) })), Vh = ah(), Kh = (e, t) => Vh(e, (() => n => { const r = `${bh(e.prefix)}k-${Ih(n)}`, i = () => { if (!t.rules.global.cache.has(r)) { t.rules.global.cache.add(r); const i = []; Sh(n, [], [], e, (e => i.push(e))); const o = `@keyframes ${r}{${i.join("")}}`; t.rules.global.apply(o) } return r }; return lh(i, { get name() { return i() }, toString: i }) })), Wh = class { constructor(e, t, n, r) { this.token = null == e ? "" : String(e), this.value = null == t ? "" : String(t), this.scale = null == n ? "" : String(n), this.prefix = null == r ? "" : String(r) } get computedValue() { return "var(" + this.variable + ")" } get variable() { return "--" + bh(this.prefix) + bh(this.scale) + this.token } toString() { return this.computedValue } }, Yh = ah(), Gh = (e, t) => Yh(e, (() => (n, r) => { r = "object" == typeof n && n || Object(r); const i = `.${n = (n = "string" == typeof n ? n : "") || `${bh(e.prefix)}t-${Ih(r)}`}`, o = {}, a = []; for (const t in r) { o[t] = {}; for (const n in r[t]) { const i = `--${bh(e.prefix)}${t}-${n}`, s = wh(String(r[t][n]), e.prefix, t); o[t][n] = new Wh(n, s, t, e.prefix), a.push(`${i}:${s}`) } } const s = () => { if (a.length && !t.rules.themed.cache.has(n)) { t.rules.themed.cache.add(n); const i = `${r === e.theme ? ":root," : ""}.${n}{${a.join(";")}}`; t.rules.themed.apply(i) } return n }; return { ...o, get className() { return s() }, selector: i, toString: s } })), Zh = ah(), Xh = ah(), _h = e => { const t = (e => { let t = !1; const n = Zh(e, (e => { t = !0; const n = "prefix" in (e = "object" == typeof e && e || {}) ? String(e.prefix) : "", r = "object" == typeof e.media && e.media || {}, i = "object" == typeof e.root ? e.root || null : globalThis.document || null, o = "object" == typeof e.theme && e.theme || {}, a = { prefix: n, media: r, theme: o, themeMap: "object" == typeof e.themeMap && e.themeMap || { ...ih }, utils: "object" == typeof e.utils && e.utils || {} }, s = Th(i), l = { css: Lh(a, s), globalCss: Uh(a, s), keyframes: Kh(a, s), createTheme: Gh(a, s), reset() { s.reset(), l.theme.toString() }, theme: {}, sheet: s, config: a, prefix: n, getCssText: s.toString, toString: s.toString }; return String(l.theme = l.createTheme(o)), l })); return t || n.reset(), n })(e); return t.styled = (({ config: e, sheet: t }) => Xh(e, (() => { const n = Lh(e, t); return (...e) => { const t = n(...e), r = t[sh].type, i = A.forwardRef(((e, n) => { const i = e && e.as || r, { props: o, deferredInjector: a } = t(e); return delete o.as, o.ref = n, a ? A.createElement(A.Fragment, null, A.createElement(i, o), A.createElement(a, null)) : A.createElement(i, o) })); return i.className = t.className, i.displayName = `Styled.${r.displayName || r.name || r}`, i.selector = t.selector, i.toString = () => t.selector, i[sh] = t[sh], i } })))(t), t }, Qh = (...e) => (eh || (eh = _h())).styled(...e); function qh(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (r) { if (null == e || e(r), !1 === n || !r.defaultPrevented) return null == t ? void 0 : t(r) } } function Jh(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } function $h(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } const ef = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(rf); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(tf, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(tf, bo({}, r, { ref: t }), n) })); ef.displayName = "Slot"; const tf = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...of(r, n.props), ref: Jh(t, n.ref) }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); tf.displayName = "SlotClone"; const nf = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function rf(e) { return (0, A.isValidElement)(e) && e.type === nf } function of(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? n[r] = (...e) => { null == o || o(...e), null == i || i(...e) } : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const af = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? ef : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}), sf = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? A.useLayoutEffect : () => { }, lf = I["useId".toString()] || (() => { }); let cf = 0; function uf(e) { const [t, n] = A.useState(lf()); return sf((() => { e || n((e => null != e ? e : String(cf++))) }), [e]), e || (t ? `radix-${t}` : "") } const df = "DropdownMenu", [pf, hf] = function (e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, $h(r, ...t)] }(df, [jc]), ff = jc(), [mf, gf] = pf(df), vf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, o = gf("DropdownMenuTrigger", n), a = ff(n); return (0, A.createElement)(Pu, bo({ asChild: !0 }, a), (0, A.createElement)(af.button, bo({ type: "button", id: o.triggerId, "aria-haspopup": "menu", "aria-expanded": !!o.open || void 0, "aria-controls": o.open ? o.contentId : void 0, "data-state": o.open ? "open" : "closed", "data-disabled": r ? "" : void 0, disabled: r }, i, { ref: Jh(t, o.triggerRef), onPointerDown: qh(e.onPointerDown, (e => { r || 0 !== e.button || !1 !== e.ctrlKey || (o.onOpenToggle(), o.open || e.preventDefault()) })), onKeyDown: qh(e.onKeyDown, (e => { r || (["Enter", " "].includes(e.key) && o.onOpenToggle(), "ArrowDown" === e.key && o.onOpenChange(!0), [" ", "ArrowDown"].includes(e.key) && e.preventDefault()) })) }))) })), yf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = gf("DropdownMenuContent", n), o = ff(n), a = (0, A.useRef)(!1); return (0, A.createElement)(Tu, bo({ id: i.contentId, "aria-labelledby": i.triggerId }, o, r, { ref: t, onCloseAutoFocus: qh(e.onCloseAutoFocus, (e => { var t; a.current || null === (t = i.triggerRef.current) || void 0 === t || t.focus(), a.current = !1, e.preventDefault() })), onInteractOutside: qh(e.onInteractOutside, (e => { const t = e.detail.originalEvent, n = 0 === t.button && !0 === t.ctrlKey, r = 2 === t.button || n; i.modal && !r || (a.current = !0) })), style: { ...e.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)" } })) })), bf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Ru, bo({}, i, r, { ref: t })) })), wf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Bu, bo({}, i, r, { ref: t })) })), Ef = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Du, bo({}, i, r, { ref: t })) })), Cf = e => { const { __scopeDropdownMenu: t, children: n, dir: r, open: i, defaultOpen: o, onOpenChange: a, modal: s = !0 } = e, l = ff(t), c = (0, A.useRef)(null), [u = !1, d] = Pl({ prop: i, defaultProp: o, onChange: a }); return (0, A.createElement)(mf, { scope: t, triggerId: uf(), triggerRef: c, contentId: uf(), open: u, onOpenChange: d, onOpenToggle: (0, A.useCallback)((() => d((e => !e))), [d]), modal: s }, (0, A.createElement)(Iu, bo({}, l, { open: u, onOpenChange: d, dir: r, modal: s }), n)) }, Sf = vf, kf = e => { const { __scopeDropdownMenu: t, ...n } = e, r = ff(t); return (0, A.createElement)(Mu, bo({}, r, n)) }, xf = yf, Af = bf, If = wf, Pf = Ef, Mf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Lu, bo({}, i, r, { ref: t })) })), Tf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Ou, bo({}, i, r, { ref: t })) })), Rf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Fu, bo({}, i, r, { ref: t })) })), Bf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(zu, bo({}, i, r, { ref: t })) })), Df = e => { const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: i, defaultOpen: o } = e, a = ff(t), [s = !1, l] = Pl({ prop: r, defaultProp: o, onChange: i }); return (0, A.createElement)(Hu, bo({}, a, { open: s, onOpenChange: l }), n) }, Lf = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(Nu, bo({}, i, r, { ref: t })) })), Of = (0, A.forwardRef)(((e, t) => { const { __scopeDropdownMenu: n, ...r } = e, i = ff(n); return (0, A.createElement)(ju, bo({}, i, r, { ref: t, style: { ...e.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)" } })) })); function Ff(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (r) { if (null == e || e(r), !1 === n || !r.defaultPrevented) return null == t ? void 0 : t(r) } } function zf(...e) { return t => e.forEach((e => function (e, t) { "function" == typeof e ? e(t) : null != e && (e.current = t) }(e, t))) } function Hf(...e) { return (0, A.useCallback)(zf(...e), e) } function Nf(e, t = []) { let n = []; const r = () => { const t = n.map((e => (0, A.createContext)(e))); return function (n) { const r = (null == n ? void 0 : n[e]) || t; return (0, A.useMemo)((() => ({ [`__scope${e}`]: { ...n, [e]: r } })), [n, r]) } }; return r.scopeName = e, [function (t, r) { const i = (0, A.createContext)(r), o = n.length; function a(t) { const { scope: n, children: r, ...a } = t, s = (null == n ? void 0 : n[e][o]) || i, l = (0, A.useMemo)((() => a), Object.values(a)); return (0, A.createElement)(s.Provider, { value: l }, r) } return n = [...n, r], a.displayName = t + "Provider", [a, function (n, a) { const s = (null == a ? void 0 : a[e][o]) || i, l = (0, A.useContext)(s); if (l) return l; if (void 0 !== r) return r; throw new Error(`\`${n}\` must be used within \`${t}\``) }] }, jf(r, ...t)] } function jf(...e) { const t = e[0]; if (1 === e.length) return t; const n = () => { const n = e.map((e => ({ useScope: e(), scopeName: e.scopeName }))); return function (e) { const r = n.reduce(((t, { useScope: n, scopeName: r }) => ({ ...t, ...n(e)[`__scope${r}`] })), {}); return (0, A.useMemo)((() => ({ [`__scope${t.scopeName}`]: r })), [r]) } }; return n.scopeName = t.scopeName, n } const Uf = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e, i = A.Children.toArray(n), o = i.find(Wf); if (o) { const e = o.props.children, n = i.map((t => t === o ? A.Children.count(e) > 1 ? A.Children.only(null) : (0, A.isValidElement)(e) ? e.props.children : null : t)); return (0, A.createElement)(Vf, bo({}, r, { ref: t }), (0, A.isValidElement)(e) ? (0, A.cloneElement)(e, void 0, n) : null) } return (0, A.createElement)(Vf, bo({}, r, { ref: t }), n) })); Uf.displayName = "Slot"; const Vf = (0, A.forwardRef)(((e, t) => { const { children: n, ...r } = e; return (0, A.isValidElement)(n) ? (0, A.cloneElement)(n, { ...Yf(r, n.props), ref: t ? zf(t, n.ref) : n.ref }) : A.Children.count(n) > 1 ? A.Children.only(null) : null })); Vf.displayName = "SlotClone"; const Kf = ({ children: e }) => (0, A.createElement)(A.Fragment, null, e); function Wf(e) { return (0, A.isValidElement)(e) && e.type === Kf } function Yf(e, t) { const n = { ...t }; for (const r in t) { const i = e[r], o = t[r]; /^on[A-Z]/.test(r) ? i && o ? n[r] = (...e) => { o(...e), i(...e) } : i && (n[r] = i) : "style" === r ? n[r] = { ...i, ...o } : "className" === r && (n[r] = [i, o].filter(Boolean).join(" ")) } return { ...e, ...n } } const Gf = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce(((e, t) => { const n = (0, A.forwardRef)(((e, n) => { const { asChild: r, ...i } = e, o = r ? Uf : t; return (0, A.useEffect)((() => { window[Symbol.for("radix-ui")] = !0 }), []), (0, A.createElement)(o, bo({}, i, { ref: n })) })); return n.displayName = `Primitive.${t}`, { ...e, [t]: n } }), {}); function Zf(e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) } const Xf = "dismissableLayer.update"; let _f; const Qf = (0, A.createContext)({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), qf = (0, A.forwardRef)(((e, t) => { var n; const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: i, onPointerDownOutside: o, onFocusOutside: a, onInteractOutside: s, onDismiss: l, ...c } = e, u = (0, A.useContext)(Qf), [d, p] = (0, A.useState)(null), h = null !== (n = null == d ? void 0 : d.ownerDocument) && void 0 !== n ? n : null === globalThis || void 0 === globalThis ? void 0 : globalThis.document, [, f] = (0, A.useState)({}), m = Hf(t, (e => p(e))), g = Array.from(u.layers), [v] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), y = g.indexOf(v), b = d ? g.indexOf(d) : -1, w = u.layersWithOutsidePointerEventsDisabled.size > 0, E = b >= y, C = function (e, t = (null === globalThis || void 0 === globalThis ? void 0 : globalThis.document)) { const n = Zf(e), r = (0, A.useRef)(!1), i = (0, A.useRef)((() => { })); return (0, A.useEffect)((() => { const e = e => { if (e.target && !r.current) { const o = { originalEvent: e }; function a() { $f("dismissableLayer.pointerDownOutside", n, o, { discrete: !0 }) } "touch" === e.pointerType ? (t.removeEventListener("click", i.current), i.current = a, t.addEventListener("click", i.current, { once: !0 })) : a() } else t.removeEventListener("click", i.current); r.current = !1 }, o = window.setTimeout((() => { t.addEventListener("pointerdown", e) }), 0); return () => { window.clearTimeout(o), t.removeEventListener("pointerdown", e), t.removeEventListener("click", i.current) } }), [t, n]), { onPointerDownCapture: () => r.current = !0 } }((e => { const t = e.target, n = [...u.branches].some((e => e.contains(t))); E && !n && (null == o || o(e), null == s || s(e), e.defaultPrevented || null == l || l()) }), h), S = function (e, t = (null === globalThis || void 0 === globalThis ? void 0 : globalThis.document)) { const n = Zf(e), r = (0, A.useRef)(!1); return (0, A.useEffect)((() => { const e = e => { e.target && !r.current && $f("dismissableLayer.focusOutside", n, { originalEvent: e }, { discrete: !1 }) }; return t.addEventListener("focusin", e), () => t.removeEventListener("focusin", e) }), [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } }((e => { const t = e.target;[...u.branches].some((e => e.contains(t))) || (null == a || a(e), null == s || s(e), e.defaultPrevented || null == l || l()) }), h); return function (e, t = (null === globalThis || void 0 === globalThis ? void 0 : globalThis.document)) { const n = function (e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) }(e); (0, A.useEffect)((() => { const e = e => { "Escape" === e.key && n(e) }; return t.addEventListener("keydown", e), () => t.removeEventListener("keydown", e) }), [n, t]) }((e => { b === u.layers.size - 1 && (null == i || i(e), !e.defaultPrevented && l && (e.preventDefault(), l())) }), h), (0, A.useEffect)((() => { if (d) return r && (0 === u.layersWithOutsidePointerEventsDisabled.size && (_f = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), Jf(), () => { r && 1 === u.layersWithOutsidePointerEventsDisabled.size && (h.body.style.pointerEvents = _f) } }), [d, h, r, u]), (0, A.useEffect)((() => () => { d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), Jf()) }), [d, u]), (0, A.useEffect)((() => { const e = () => f({}); return document.addEventListener(Xf, e), () => document.removeEventListener(Xf, e) }), []), (0, A.createElement)(Gf.div, bo({}, c, { ref: m, style: { pointerEvents: w ? E ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: Ff(e.onFocusCapture, S.onFocusCapture), onBlurCapture: Ff(e.onBlurCapture, S.onBlurCapture), onPointerDownCapture: Ff(e.onPointerDownCapture, C.onPointerDownCapture) })) })); function Jf() { const e = new CustomEvent(Xf); document.dispatchEvent(e) } function $f(e, t, n, { discrete: r }) { const i = n.originalEvent.target, o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && i.addEventListener(e, t, { once: !0 }), r ? function (e, t) { e && (0, Co.flushSync)((() => e.dispatchEvent(t))) }(i, o) : i.dispatchEvent(o) } const em = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? A.useLayoutEffect : () => { }, tm = I["useId".toString()] || (() => { }); let nm = 0; function rm(e) { const [t, n] = A.useState(tm()); return em((() => { e || n((e => null != e ? e : String(nm++))) }), [e]), e || (t ? `radix-${t}` : "") } const im = ["top", "right", "bottom", "left"], om = Math.min, am = Math.max, sm = Math.round, lm = Math.floor, cm = e => ({ x: e, y: e }), um = { left: "right", right: "left", bottom: "top", top: "bottom" }, dm = { start: "end", end: "start" }; function pm(e, t, n) { return am(e, om(t, n)) } function hm(e, t) { return "function" == typeof e ? e(t) : e } function fm(e) { return e.split("-")[0] } function mm(e) { return e.split("-")[1] } function gm(e) { return "x" === e ? "y" : "x" } function vm(e) { return "y" === e ? "height" : "width" } function ym(e) { return ["top", "bottom"].includes(fm(e)) ? "y" : "x" } function bm(e) { return gm(ym(e)) } function wm(e, t, n) { void 0 === n && (n = !1); const r = mm(e), i = bm(e), o = vm(i); let a = "x" === i ? r === (n ? "end" : "start") ? "right" : "left" : "start" === r ? "bottom" : "top"; return t.reference[o] > t.floating[o] && (a = km(a)), [a, km(a)] } function Em(e) { const t = km(e); return [Cm(e), t, Cm(t)] } function Cm(e) { return e.replace(/start|end/g, (e => dm[e])) } function Sm(e, t, n, r) { const i = mm(e); let o = function (e, t, n) { const r = ["left", "right"], i = ["right", "left"], o = ["top", "bottom"], a = ["bottom", "top"]; switch (e) { case "top": case "bottom": return n ? t ? i : r : t ? r : i; case "left": case "right": return t ? o : a; default: return [] } }(fm(e), "start" === n, r); return i && (o = o.map((e => e + "-" + i)), t && (o = o.concat(o.map(Cm)))), o } function km(e) { return e.replace(/left|right|bottom|top/g, (e => um[e])) } function xm(e) { return "number" != typeof e ? function (e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } }(e) : { top: e, right: e, bottom: e, left: e } } function Am(e) { return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height } } function Im(e, t, n) { let { reference: r, floating: i } = e; const o = ym(t), a = bm(t), s = vm(a), l = fm(t), c = "y" === o, u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, p = r[s] / 2 - i[s] / 2; let h; switch (l) { case "top": h = { x: u, y: r.y - i.height }; break; case "bottom": h = { x: u, y: r.y + r.height }; break; case "right": h = { x: r.x + r.width, y: d }; break; case "left": h = { x: r.x - i.width, y: d }; break; default: h = { x: r.x, y: r.y } }switch (mm(t)) { case "start": h[a] -= p * (n && c ? -1 : 1); break; case "end": h[a] += p * (n && c ? -1 : 1) }return h } async function Pm(e, t) { var n; void 0 === t && (t = {}); const { x: r, y: i, platform: o, rects: a, elements: s, strategy: l } = e, { boundary: c = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: p = !1, padding: h = 0 } = hm(t, e), f = xm(h), m = s[p ? "floating" === d ? "reference" : "floating" : d], g = Am(await o.getClippingRect({ element: null == (n = await (null == o.isElement ? void 0 : o.isElement(m))) || n ? m : m.contextElement || await (null == o.getDocumentElement ? void 0 : o.getDocumentElement(s.floating)), boundary: c, rootBoundary: u, strategy: l })), v = "floating" === d ? { ...a.floating, x: r, y: i } : a.reference, y = await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(s.floating)), b = await (null == o.isElement ? void 0 : o.isElement(y)) && await (null == o.getScale ? void 0 : o.getScale(y)) || { x: 1, y: 1 }, w = Am(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: y, strategy: l }) : v); return { top: (g.top - w.top + f.top) / b.y, bottom: (w.bottom - g.bottom + f.bottom) / b.y, left: (g.left - w.left + f.left) / b.x, right: (w.right - g.right + f.right) / b.x } } const Mm = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: r, placement: i, rects: o, platform: a, elements: s, middlewareData: l } = t, { element: c, padding: u = 0 } = hm(e, t) || {}; if (null == c) return {}; const d = xm(u), p = { x: n, y: r }, h = bm(i), f = vm(h), m = await a.getDimensions(c), g = "y" === h, v = g ? "top" : "left", y = g ? "bottom" : "right", b = g ? "clientHeight" : "clientWidth", w = o.reference[f] + o.reference[h] - p[h] - o.floating[f], E = p[h] - o.reference[h], C = await (null == a.getOffsetParent ? void 0 : a.getOffsetParent(c)); let S = C ? C[b] : 0; S && await (null == a.isElement ? void 0 : a.isElement(C)) || (S = s.floating[b] || o.floating[f]); const k = w / 2 - E / 2, x = S / 2 - m[f] / 2 - 1, A = om(d[v], x), I = om(d[y], x), P = A, M = S - m[f] - I, T = S / 2 - m[f] / 2 + k, R = pm(P, T, M), B = !l.arrow && null != mm(i) && T != R && o.reference[f] / 2 - (T < P ? A : I) - m[f] / 2 < 0, D = B ? T < P ? T - P : T - M : 0; return { [h]: p[h] + D, data: { [h]: R, centerOffset: T - R - D, ...B && { alignmentOffset: D } }, reset: B } } }), Tm = function (e) { return void 0 === e && (e = {}), { name: "flip", options: e, async fn(t) { var n, r; const { placement: i, middlewareData: o, rects: a, initialPlacement: s, platform: l, elements: c } = t, { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: p, fallbackStrategy: h = "bestFit", fallbackAxisSideDirection: f = "none", flipAlignment: m = !0, ...g } = hm(e, t); if (null != (n = o.arrow) && n.alignmentOffset) return {}; const v = fm(i), y = fm(s) === s, b = await (null == l.isRTL ? void 0 : l.isRTL(c.floating)), w = p || (y || !m ? [km(s)] : Em(s)); p || "none" === f || w.push(...Sm(s, m, f, b)); const E = [s, ...w], C = await Pm(t, g), S = []; let k = (null == (r = o.flip) ? void 0 : r.overflows) || []; if (u && S.push(C[v]), d) { const e = wm(i, a, b); S.push(C[e[0]], C[e[1]]) } if (k = [...k, { placement: i, overflows: S }], !S.every((e => e <= 0))) { var x, A; const e = ((null == (x = o.flip) ? void 0 : x.index) || 0) + 1, t = E[e]; if (t) return { data: { index: e, overflows: k }, reset: { placement: t } }; let n = null == (A = k.filter((e => e.overflows[0] <= 0)).sort(((e, t) => e.overflows[1] - t.overflows[1]))[0]) ? void 0 : A.placement; if (!n) switch (h) { case "bestFit": { var I; const e = null == (I = k.map((e => [e.placement, e.overflows.filter((e => e > 0)).reduce(((e, t) => e + t), 0)])).sort(((e, t) => e[1] - t[1]))[0]) ? void 0 : I[0]; e && (n = e); break } case "initialPlacement": n = s }if (i !== n) return { reset: { placement: n } } } return {} } } }; function Rm(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function Bm(e) { return im.some((t => e[t] >= 0)) } const Dm = function (e) { return void 0 === e && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: n } = t, { strategy: r = "referenceHidden", ...i } = hm(e, t); switch (r) { case "referenceHidden": { const e = Rm(await Pm(t, { ...i, elementContext: "reference" }), n.reference); return { data: { referenceHiddenOffsets: e, referenceHidden: Bm(e) } } } case "escaped": { const e = Rm(await Pm(t, { ...i, altBoundary: !0 }), n.floating); return { data: { escapedOffsets: e, escaped: Bm(e) } } } default: return {} } } } }, Lm = function (e) { return void 0 === e && (e = 0), { name: "offset", options: e, async fn(t) { const { x: n, y: r } = t, i = await async function (e, t) { const { placement: n, platform: r, elements: i } = e, o = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)), a = fm(n), s = mm(n), l = "y" === ym(n), c = ["left", "top"].includes(a) ? -1 : 1, u = o && l ? -1 : 1, d = hm(t, e); let { mainAxis: p, crossAxis: h, alignmentAxis: f } = "number" == typeof d ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d }; return s && "number" == typeof f && (h = "end" === s ? -1 * f : f), l ? { x: h * u, y: p * c } : { x: p * c, y: h * u } }(t, e); return { x: n + i.x, y: r + i.y, data: i } } } }, Om = function (e) { return void 0 === e && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: i } = t, { mainAxis: o = !0, crossAxis: a = !1, limiter: s = { fn: e => { let { x: t, y: n } = e; return { x: t, y: n } } }, ...l } = hm(e, t), c = { x: n, y: r }, u = await Pm(t, l), d = ym(fm(i)), p = gm(d); let h = c[p], f = c[d]; if (o) { const e = "y" === p ? "bottom" : "right"; h = pm(h + u["y" === p ? "top" : "left"], h, h - u[e]) } if (a) { const e = "y" === d ? "bottom" : "right"; f = pm(f + u["y" === d ? "top" : "left"], f, f - u[e]) } const m = s.fn({ ...t, [p]: h, [d]: f }); return { ...m, data: { x: m.x - n, y: m.y - r } } } } }, Fm = function (e) { return void 0 === e && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: i, rects: o, middlewareData: a } = t, { offset: s = 0, mainAxis: l = !0, crossAxis: c = !0 } = hm(e, t), u = { x: n, y: r }, d = ym(i), p = gm(d); let h = u[p], f = u[d]; const m = hm(s, t), g = "number" == typeof m ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m }; if (l) { const e = "y" === p ? "height" : "width", t = o.reference[p] - o.floating[e] + g.mainAxis, n = o.reference[p] + o.reference[e] - g.mainAxis; h < t ? h = t : h > n && (h = n) } if (c) { var v, y; const e = "y" === p ? "width" : "height", t = ["top", "left"].includes(fm(i)), n = o.reference[d] - o.floating[e] + (t && (null == (v = a.offset) ? void 0 : v[d]) || 0) + (t ? 0 : g.crossAxis), r = o.reference[d] + o.reference[e] + (t ? 0 : (null == (y = a.offset) ? void 0 : y[d]) || 0) - (t ? g.crossAxis : 0); f < n ? f = n : f > r && (f = r) } return { [p]: h, [d]: f } } } }, zm = function (e) { return void 0 === e && (e = {}), { name: "size", options: e, async fn(t) { const { placement: n, rects: r, platform: i, elements: o } = t, { apply: a = (() => { }), ...s } = hm(e, t), l = await Pm(t, s), c = fm(n), u = mm(n), d = "y" === ym(n), { width: p, height: h } = r.floating; let f, m; "top" === c || "bottom" === c ? (f = c, m = u === (await (null == i.isRTL ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (m = c, f = "end" === u ? "top" : "bottom"); const g = h - l[f], v = p - l[m], y = !t.middlewareData.shift; let b = g, w = v; if (d) { const e = p - l.left - l.right; w = u || y ? om(v, e) : e } else { const e = h - l.top - l.bottom; b = u || y ? om(g, e) : e } if (y && !u) { const e = am(l.left, 0), t = am(l.right, 0), n = am(l.top, 0), r = am(l.bottom, 0); d ? w = p - 2 * (0 !== e || 0 !== t ? e + t : am(l.left, l.right)) : b = h - 2 * (0 !== n || 0 !== r ? n + r : am(l.top, l.bottom)) } await a({ ...t, availableWidth: w, availableHeight: b }); const E = await i.getDimensions(o.floating); return p !== E.width || h !== E.height ? { reset: { rects: !0 } } : {} } } }; function Hm(e) { return Um(e) ? (e.nodeName || "").toLowerCase() : "#document" } function Nm(e) { var t; return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window } function jm(e) { var t; return null == (t = (Um(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement } function Um(e) { return e instanceof Node || e instanceof Nm(e).Node } function Vm(e) { return e instanceof Element || e instanceof Nm(e).Element } function Km(e) { return e instanceof HTMLElement || e instanceof Nm(e).HTMLElement } function Wm(e) { return "undefined" != typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof Nm(e).ShadowRoot) } function Ym(e) { const { overflow: t, overflowX: n, overflowY: r, display: i } = qm(e); return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i) } function Gm(e) { return ["table", "td", "th"].includes(Hm(e)) } function Zm(e) { const t = _m(), n = qm(e); return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some((e => (n.willChange || "").includes(e))) || ["paint", "layout", "strict", "content"].some((e => (n.contain || "").includes(e))) } function Xm(e) { let t = $m(e); for (; Km(t) && !Qm(t);) { if (Zm(t)) return t; t = $m(t) } return null } function _m() { return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none") } function Qm(e) { return ["html", "body", "#document"].includes(Hm(e)) } function qm(e) { return Nm(e).getComputedStyle(e) } function Jm(e) { return Vm(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function $m(e) { if ("html" === Hm(e)) return e; const t = e.assignedSlot || e.parentNode || Wm(e) && e.host || jm(e); return Wm(t) ? t.host : t } function eg(e) { const t = $m(e); return Qm(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Km(t) && Ym(t) ? t : eg(t) } function tg(e, t, n) { var r; void 0 === t && (t = []), void 0 === n && (n = !0); const i = eg(e), o = i === (null == (r = e.ownerDocument) ? void 0 : r.body), a = Nm(i); return o ? t.concat(a, a.visualViewport || [], Ym(i) ? i : [], a.frameElement && n ? tg(a.frameElement) : []) : t.concat(i, tg(i, [], n)) } function ng(e) { const t = qm(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const i = Km(e), o = i ? e.offsetWidth : n, a = i ? e.offsetHeight : r, s = sm(n) !== o || sm(r) !== a; return s && (n = o, r = a), { width: n, height: r, $: s } } function rg(e) { return Vm(e) ? e : e.contextElement } function ig(e) { const t = rg(e); if (!Km(t)) return cm(1); const n = t.getBoundingClientRect(), { width: r, height: i, $: o } = ng(t); let a = (o ? sm(n.width) : n.width) / r, s = (o ? sm(n.height) : n.height) / i; return a && Number.isFinite(a) || (a = 1), s && Number.isFinite(s) || (s = 1), { x: a, y: s } } const og = cm(0); function ag(e) { const t = Nm(e); return _m() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : og } function sg(e, t, n, r) { void 0 === t && (t = !1), void 0 === n && (n = !1); const i = e.getBoundingClientRect(), o = rg(e); let a = cm(1); t && (r ? Vm(r) && (a = ig(r)) : a = ig(e)); const s = function (e, t, n) { return void 0 === t && (t = !1), !(!n || t && n !== Nm(e)) && t }(o, n, r) ? ag(o) : cm(0); let l = (i.left + s.x) / a.x, c = (i.top + s.y) / a.y, u = i.width / a.x, d = i.height / a.y; if (o) { const e = Nm(o), t = r && Vm(r) ? Nm(r) : r; let n = e.frameElement; for (; n && r && t !== e;) { const e = ig(n), t = n.getBoundingClientRect(), r = qm(n), i = t.left + (n.clientLeft + parseFloat(r.paddingLeft)) * e.x, o = t.top + (n.clientTop + parseFloat(r.paddingTop)) * e.y; l *= e.x, c *= e.y, u *= e.x, d *= e.y, l += i, c += o, n = Nm(n).frameElement } } return Am({ width: u, height: d, x: l, y: c }) } function lg(e) { return sg(jm(e)).left + Jm(e).scrollLeft } function cg(e, t, n) { let r; if ("viewport" === t) r = function (e, t) { const n = Nm(e), r = jm(e), i = n.visualViewport; let o = r.clientWidth, a = r.clientHeight, s = 0, l = 0; if (i) { o = i.width, a = i.height; const e = _m(); (!e || e && "fixed" === t) && (s = i.offsetLeft, l = i.offsetTop) } return { width: o, height: a, x: s, y: l } }(e, n); else if ("document" === t) r = function (e) { const t = jm(e), n = Jm(e), r = e.ownerDocument.body, i = am(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = am(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let a = -n.scrollLeft + lg(e); const s = -n.scrollTop; return "rtl" === qm(r).direction && (a += am(t.clientWidth, r.clientWidth) - i), { width: i, height: o, x: a, y: s } }(jm(e)); else if (Vm(t)) r = function (e, t) { const n = sg(e, !0, "fixed" === t), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Km(e) ? ig(e) : cm(1); return { width: e.clientWidth * o.x, height: e.clientHeight * o.y, x: i * o.x, y: r * o.y } }(t, n); else { const n = ag(e); r = { ...t, x: t.x - n.x, y: t.y - n.y } } return Am(r) } function ug(e, t) { const n = $m(e); return !(n === t || !Vm(n) || Qm(n)) && ("fixed" === qm(n).position || ug(n, t)) } function dg(e, t, n) { const r = Km(t), i = jm(t), o = "fixed" === n, a = sg(e, !0, o, t); let s = { scrollLeft: 0, scrollTop: 0 }; const l = cm(0); if (r || !r && !o) if (("body" !== Hm(t) || Ym(i)) && (s = Jm(t)), r) { const e = sg(t, !0, o, t); l.x = e.x + t.clientLeft, l.y = e.y + t.clientTop } else i && (l.x = lg(i)); return { x: a.left + s.scrollLeft - l.x, y: a.top + s.scrollTop - l.y, width: a.width, height: a.height } } function pg(e, t) { return Km(e) && "fixed" !== qm(e).position ? t ? t(e) : e.offsetParent : null } function hg(e, t) { const n = Nm(e); if (!Km(e)) return n; let r = pg(e, t); for (; r && Gm(r) && "static" === qm(r).position;)r = pg(r, t); return r && ("html" === Hm(r) || "body" === Hm(r) && "static" === qm(r).position && !Zm(r)) ? n : r || Xm(e) || n } const fg = { convertOffsetParentRelativeRectToViewportRelativeRect: function (e) { let { rect: t, offsetParent: n, strategy: r } = e; const i = Km(n), o = jm(n); if (n === o) return t; let a = { scrollLeft: 0, scrollTop: 0 }, s = cm(1); const l = cm(0); if ((i || !i && "fixed" !== r) && (("body" !== Hm(n) || Ym(o)) && (a = Jm(n)), Km(n))) { const e = sg(n); s = ig(n), l.x = e.x + n.clientLeft, l.y = e.y + n.clientTop } return { width: t.width * s.x, height: t.height * s.y, x: t.x * s.x - a.scrollLeft * s.x + l.x, y: t.y * s.y - a.scrollTop * s.y + l.y } }, getDocumentElement: jm, getClippingRect: function (e) { let { element: t, boundary: n, rootBoundary: r, strategy: i } = e; const o = [..."clippingAncestors" === n ? function (e, t) { const n = t.get(e); if (n) return n; let r = tg(e, [], !1).filter((e => Vm(e) && "body" !== Hm(e))), i = null; const o = "fixed" === qm(e).position; let a = o ? $m(e) : e; for (; Vm(a) && !Qm(a);) { const t = qm(a), n = Zm(a); n || "fixed" !== t.position || (i = null), (o ? !n && !i : !n && "static" === t.position && i && ["absolute", "fixed"].includes(i.position) || Ym(a) && !n && ug(e, a)) ? r = r.filter((e => e !== a)) : i = t, a = $m(a) } return t.set(e, r), r }(t, this._c) : [].concat(n), r], a = o[0], s = o.reduce(((e, n) => { const r = cg(t, n, i); return e.top = am(r.top, e.top), e.right = om(r.right, e.right), e.bottom = om(r.bottom, e.bottom), e.left = am(r.left, e.left), e }), cg(t, a, i)); return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top } }, getOffsetParent: hg, getElementRects: async function (e) { let { reference: t, floating: n, strategy: r } = e; const i = this.getOffsetParent || hg, o = this.getDimensions; return { reference: dg(t, await i(n), r), floating: { x: 0, y: 0, ...await o(n) } } }, getClientRects: function (e) { return Array.from(e.getClientRects()) }, getDimensions: function (e) { return ng(e) }, getScale: ig, isElement: Vm, isRTL: function (e) { return "rtl" === qm(e).direction } }; const mg = (e, t, n) => { const r = new Map, i = { platform: fg, ...n }, o = { ...i.platform, _c: r }; return (async (e, t, n) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: o = [], platform: a } = n, s = o.filter(Boolean), l = await (null == a.isRTL ? void 0 : a.isRTL(t)); let c = await a.getElementRects({ reference: e, floating: t, strategy: i }), { x: u, y: d } = Im(c, r, l), p = r, h = {}, f = 0; for (let n = 0; n < s.length; n++) { const { name: o, fn: m } = s[n], { x: g, y: v, data: y, reset: b } = await m({ x: u, y: d, initialPlacement: r, placement: p, strategy: i, middlewareData: h, rects: c, platform: a, elements: { reference: e, floating: t } }); u = null != g ? g : u, d = null != v ? v : d, h = { ...h, [o]: { ...h[o], ...y } }, b && f <= 50 && (f++, "object" == typeof b && (b.placement && (p = b.placement), b.rects && (c = !0 === b.rects ? await a.getElementRects({ reference: e, floating: t, strategy: i }) : b.rects), ({ x: u, y: d } = Im(c, p, l))), n = -1) } return { x: u, y: d, placement: p, strategy: i, middlewareData: h } })(e, t, { ...i, platform: o }) }, gg = e => ({ name: "arrow", options: e, fn(t) { const { element: n, padding: r } = "function" == typeof e ? e(t) : e; return n && (i = n, {}.hasOwnProperty.call(i, "current")) ? null != n.current ? Mm({ element: n.current, padding: r }).fn(t) : {} : n ? Mm({ element: n, padding: r }).fn(t) : {}; var i } }); var vg = "undefined" != typeof document ? A.useLayoutEffect : A.useEffect; function yg(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if ("function" == typeof e && e.toString() === t.toString()) return !0; let n, r, i; if (e && t && "object" == typeof e) { if (Array.isArray(e)) { if (n = e.length, n != t.length) return !1; for (r = n; 0 != r--;)if (!yg(e[r], t[r])) return !1; return !0 } if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length) return !1; for (r = n; 0 != r--;)if (!{}.hasOwnProperty.call(t, i[r])) return !1; for (r = n; 0 != r--;) { const n = i[r]; if (!("_owner" === n && e.$$typeof || yg(e[n], t[n]))) return !1 } return !0 } return e != e && t != t } function bg(e) { return "undefined" == typeof window ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function wg(e, t) { const n = bg(e); return Math.round(t * n) / n } function Eg(e) { const t = A.useRef(e); return vg((() => { t.current = e })), t } const Cg = (0, A.forwardRef)(((e, t) => { const { children: n, width: r = 10, height: i = 5, ...o } = e; return (0, A.createElement)(Gf.svg, bo({}, o, { ref: t, width: r, height: i, viewBox: "0 0 30 10", preserveAspectRatio: "none" }), e.asChild ? n : (0, A.createElement)("polygon", { points: "0,0 30,0 15,10" })) })); function Sg(e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) } const kg = "Popper", [xg, Ag] = Nf(kg), [Ig, Pg] = xg(kg), Mg = (0, A.forwardRef)(((e, t) => { const { __scopePopper: n, virtualRef: r, ...i } = e, o = Pg("PopperAnchor", n), a = (0, A.useRef)(null), s = Hf(t, a); return (0, A.useEffect)((() => { o.onAnchorChange((null == r ? void 0 : r.current) || a.current) })), r ? null : (0, A.createElement)(Gf.div, bo({}, i, { ref: s })) })), Tg = "PopperContent", [Rg, Bg] = xg(Tg), Dg = (0, A.forwardRef)(((e, t) => { var n, r, i, o, a, s, l, c; const { __scopePopper: u, side: d = "bottom", sideOffset: p = 0, align: h = "center", alignOffset: f = 0, arrowPadding: m = 0, avoidCollisions: g = !0, collisionBoundary: v = [], collisionPadding: y = 0, sticky: b = "partial", hideWhenDetached: w = !1, updatePositionStrategy: E = "optimized", onPlaced: C, ...S } = e, k = Pg(Tg, u), [x, I] = (0, A.useState)(null), P = Hf(t, (e => I(e))), [M, T] = (0, A.useState)(null), R = function (e) { const [t, n] = (0, A.useState)(void 0); return em((() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const t = new ResizeObserver((t => { if (!Array.isArray(t)) return; if (!t.length) return; const r = t[0]; let i, o; if ("borderBoxSize" in r) { const e = r.borderBoxSize, t = Array.isArray(e) ? e[0] : e; i = t.inlineSize, o = t.blockSize } else i = e.offsetWidth, o = e.offsetHeight; n({ width: i, height: o }) })); return t.observe(e, { box: "border-box" }), () => t.unobserve(e) } n(void 0) }), [e]), t }(M), B = null !== (n = null == R ? void 0 : R.width) && void 0 !== n ? n : 0, D = null !== (r = null == R ? void 0 : R.height) && void 0 !== r ? r : 0, L = d + ("center" !== h ? "-" + h : ""), O = "number" == typeof y ? y : { top: 0, right: 0, bottom: 0, left: 0, ...y }, F = Array.isArray(v) ? v : [v], z = F.length > 0, H = { padding: O, boundary: F.filter(Og), altBoundary: z }, { refs: N, floatingStyles: j, placement: U, isPositioned: V, middlewareData: K } = function (e) { void 0 === e && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: i, elements: { reference: o, floating: a } = {}, transform: s = !0, whileElementsMounted: l, open: c } = e, [u, d] = A.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [p, h] = A.useState(r); yg(p, r) || h(r); const [f, m] = A.useState(null), [g, v] = A.useState(null), y = A.useCallback((e => { e != C.current && (C.current = e, m(e)) }), [m]), b = A.useCallback((e => { e !== S.current && (S.current = e, v(e)) }), [v]), w = o || f, E = a || g, C = A.useRef(null), S = A.useRef(null), k = A.useRef(u), x = Eg(l), I = Eg(i), P = A.useCallback((() => { if (!C.current || !S.current) return; const e = { placement: t, strategy: n, middleware: p }; I.current && (e.platform = I.current), mg(C.current, S.current, e).then((e => { const t = { ...e, isPositioned: !0 }; M.current && !yg(k.current, t) && (k.current = t, Co.flushSync((() => { d(t) }))) })) }), [p, t, n, I]); vg((() => { !1 === c && k.current.isPositioned && (k.current.isPositioned = !1, d((e => ({ ...e, isPositioned: !1 })))) }), [c]); const M = A.useRef(!1); vg((() => (M.current = !0, () => { M.current = !1 })), []), vg((() => { if (w && (C.current = w), E && (S.current = E), w && E) { if (x.current) return x.current(w, E, P); P() } }), [w, E, P, x]); const T = A.useMemo((() => ({ reference: C, floating: S, setReference: y, setFloating: b })), [y, b]), R = A.useMemo((() => ({ reference: w, floating: E })), [w, E]), B = A.useMemo((() => { const e = { position: n, left: 0, top: 0 }; if (!R.floating) return e; const t = wg(R.floating, u.x), r = wg(R.floating, u.y); return s ? { ...e, transform: "translate(" + t + "px, " + r + "px)", ...bg(R.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: t, top: r } }), [n, s, R.floating, u.x, u.y]); return A.useMemo((() => ({ ...u, update: P, refs: T, elements: R, floatingStyles: B })), [u, P, T, R, B]) }({ strategy: "fixed", placement: L, whileElementsMounted: (...e) => function (e, t, n, r) { void 0 === r && (r = {}); const { ancestorScroll: i = !0, ancestorResize: o = !0, elementResize: a = "function" == typeof ResizeObserver, layoutShift: s = "function" == typeof IntersectionObserver, animationFrame: l = !1 } = r, c = rg(e), u = i || o ? [...c ? tg(c) : [], ...tg(t)] : []; u.forEach((e => { i && e.addEventListener("scroll", n, { passive: !0 }), o && e.addEventListener("resize", n) })); const d = c && s ? function (e, t) { let n, r = null; const i = jm(e); function o() { clearTimeout(n), r && r.disconnect(), r = null } return function a(s, l) { void 0 === s && (s = !1), void 0 === l && (l = 1), o(); const { left: c, top: u, width: d, height: p } = e.getBoundingClientRect(); if (s || t(), !d || !p) return; const h = { rootMargin: -lm(u) + "px " + -lm(i.clientWidth - (c + d)) + "px " + -lm(i.clientHeight - (u + p)) + "px " + -lm(c) + "px", threshold: am(0, om(1, l)) || 1 }; let f = !0; function m(e) { const t = e[0].intersectionRatio; if (t !== l) { if (!f) return a(); t ? a(!1, t) : n = setTimeout((() => { a(!1, 1e-7) }), 100) } f = !1 } try { r = new IntersectionObserver(m, { ...h, root: i.ownerDocument }) } catch (e) { r = new IntersectionObserver(m, h) } r.observe(e) }(!0), o }(c, n) : null; let p, h = -1, f = null; a && (f = new ResizeObserver((e => { let [r] = e; r && r.target === c && f && (f.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame((() => { f && f.observe(t) }))), n() })), c && !l && f.observe(c), f.observe(t)); let m = l ? sg(e) : null; return l && function t() { const r = sg(e); !m || r.x === m.x && r.y === m.y && r.width === m.width && r.height === m.height || n(), m = r, p = requestAnimationFrame(t) }(), n(), () => { u.forEach((e => { i && e.removeEventListener("scroll", n), o && e.removeEventListener("resize", n) })), d && d(), f && f.disconnect(), f = null, l && cancelAnimationFrame(p) } }(...e, { animationFrame: "always" === E }), elements: { reference: k.anchor }, middleware: [Lm({ mainAxis: p + D, alignmentAxis: f }), g && Om({ mainAxis: !0, crossAxis: !1, limiter: "partial" === b ? Fm() : void 0, ...H }), g && Tm({ ...H }), zm({ ...H, apply: ({ elements: e, rects: t, availableWidth: n, availableHeight: r }) => { const { width: i, height: o } = t.reference, a = e.floating.style; a.setProperty("--radix-popper-available-width", `${n}px`), a.setProperty("--radix-popper-available-height", `${r}px`), a.setProperty("--radix-popper-anchor-width", `${i}px`), a.setProperty("--radix-popper-anchor-height", `${o}px`) } }), M && gg({ element: M, padding: m }), Fg({ arrowWidth: B, arrowHeight: D }), w && Dm({ strategy: "referenceHidden", ...H })] }), [W, Y] = zg(U), G = Sg(C); em((() => { V && (null == G || G()) }), [V, G]); const Z = null === (i = K.arrow) || void 0 === i ? void 0 : i.x, X = null === (o = K.arrow) || void 0 === o ? void 0 : o.y, _ = 0 !== (null === (a = K.arrow) || void 0 === a ? void 0 : a.centerOffset), [Q, q] = (0, A.useState)(); return em((() => { x && q(window.getComputedStyle(x).zIndex) }), [x]), (0, A.createElement)("div", { ref: N.setFloating, "data-radix-popper-content-wrapper": "", style: { ...j, transform: V ? j.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: Q, "--radix-popper-transform-origin": [null === (s = K.transformOrigin) || void 0 === s ? void 0 : s.x, null === (l = K.transformOrigin) || void 0 === l ? void 0 : l.y].join(" ") }, dir: e.dir }, (0, A.createElement)(Rg, { scope: u, placedSide: W, onArrowChange: T, arrowX: Z, arrowY: X, shouldHideArrow: _ }, (0, A.createElement)(Gf.div, bo({ "data-side": W, "data-align": Y }, S, { ref: P, style: { ...S.style, animation: V ? void 0 : "none", opacity: null !== (c = K.hide) && void 0 !== c && c.referenceHidden ? 0 : void 0 } })))) })), Lg = { top: "bottom", right: "left", bottom: "top", left: "right" }; function Og(e) { return null !== e } const Fg = e => ({ name: "transformOrigin", options: e, fn(t) { var n, r, i, o, a; const { placement: s, rects: l, middlewareData: c } = t, u = 0 !== (null === (n = c.arrow) || void 0 === n ? void 0 : n.centerOffset), d = u ? 0 : e.arrowWidth, p = u ? 0 : e.arrowHeight, [h, f] = zg(s), m = { start: "0%", center: "50%", end: "100%" }[f], g = (null !== (r = null === (i = c.arrow) || void 0 === i ? void 0 : i.x) && void 0 !== r ? r : 0) + d / 2, v = (null !== (o = null === (a = c.arrow) || void 0 === a ? void 0 : a.y) && void 0 !== o ? o : 0) + p / 2; let y = "", b = ""; return "bottom" === h ? (y = u ? m : `${g}px`, b = -p + "px") : "top" === h ? (y = u ? m : `${g}px`, b = `${l.floating.height + p}px`) : "right" === h ? (y = -p + "px", b = u ? m : `${v}px`) : "left" === h && (y = `${l.floating.width + p}px`, b = u ? m : `${v}px`), { data: { x: y, y: b } } } }); function zg(e) { const [t, n = "center"] = e.split("-"); return [t, n] } const Hg = e => { const { __scopePopper: t, children: n } = e, [r, i] = (0, A.useState)(null); return (0, A.createElement)(Ig, { scope: t, anchor: r, onAnchorChange: i }, n) }, Ng = Mg, jg = Dg, Ug = (0, A.forwardRef)((function (e, t) { const { __scopePopper: n, ...r } = e, i = Bg("PopperArrow", n), o = Lg[i.placedSide]; return (0, A.createElement)("span", { ref: i.onArrowChange, style: { position: "absolute", left: i.arrowX, top: i.arrowY, [o]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[i.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[i.placedSide], visibility: i.shouldHideArrow ? "hidden" : void 0 } }, (0, A.createElement)(Cg, bo({}, r, { ref: t, style: { ...r.style, display: "block" } }))) })), Vg = (0, A.forwardRef)(((e, t) => { var n; const { container: r = (null === globalThis || void 0 === globalThis || null === (n = globalThis.document) || void 0 === n ? void 0 : n.body), ...i } = e; return r ? Co.createPortal((0, A.createElement)(Gf.div, bo({}, i, { ref: t })), r) : null })), Kg = e => { const { present: t, children: n } = e, r = function (e) { const [t, n] = (0, A.useState)(), r = (0, A.useRef)({}), i = (0, A.useRef)(e), o = (0, A.useRef)("none"), a = e ? "mounted" : "unmounted", [s, l] = function (e, t) { return (0, A.useReducer)(((e, n) => { const r = t[e][n]; return null != r ? r : e }), e) }(a, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return (0, A.useEffect)((() => { const e = Wg(r.current); o.current = "mounted" === s ? e : "none" }), [s]), em((() => { const t = r.current, n = i.current; if (n !== e) { const r = o.current, a = Wg(t); e ? l("MOUNT") : "none" === a || "none" === (null == t ? void 0 : t.display) ? l("UNMOUNT") : l(n && r !== a ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e } }), [e, l]), em((() => { if (t) { const e = e => { const n = Wg(r.current).includes(e.animationName); e.target === t && n && (0, Co.flushSync)((() => l("ANIMATION_END"))) }, n = e => { e.target === t && (o.current = Wg(r.current)) }; return t.addEventListener("animationstart", n), t.addEventListener("animationcancel", e), t.addEventListener("animationend", e), () => { t.removeEventListener("animationstart", n), t.removeEventListener("animationcancel", e), t.removeEventListener("animationend", e) } } l("ANIMATION_END") }), [t, l]), { isPresent: ["mounted", "unmountSuspended"].includes(s), ref: (0, A.useCallback)((e => { e && (r.current = getComputedStyle(e)), n(e) }), []) } }(t), i = "function" == typeof n ? n({ present: r.isPresent }) : A.Children.only(n), o = Hf(r.ref, i.ref); return "function" == typeof n || r.isPresent ? (0, A.cloneElement)(i, { ref: o }) : null }; function Wg(e) { return (null == e ? void 0 : e.animationName) || "none" } Kg.displayName = "Presence"; const Yg = (0, A.forwardRef)(((e, t) => (0, A.createElement)(Gf.span, bo({}, e, { ref: t, style: { position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal", ...e.style } })))), [Gg, Zg] = Nf("Tooltip", [Ag]), Xg = Ag(), _g = 700, Qg = "tooltip.open", [qg, Jg] = Gg("TooltipProvider"), $g = "Tooltip", [ev, tv] = Gg($g), nv = "TooltipTrigger", rv = (0, A.forwardRef)(((e, t) => { const { __scopeTooltip: n, ...r } = e, i = tv(nv, n), o = Jg(nv, n), a = Xg(n), s = Hf(t, (0, A.useRef)(null), i.onTriggerChange), l = (0, A.useRef)(!1), c = (0, A.useRef)(!1), u = (0, A.useCallback)((() => l.current = !1), []); return (0, A.useEffect)((() => () => document.removeEventListener("pointerup", u)), [u]), (0, A.createElement)(Ng, bo({ asChild: !0 }, a), (0, A.createElement)(Gf.button, bo({ "aria-describedby": i.open ? i.contentId : void 0, "data-state": i.stateAttribute }, r, { ref: s, onPointerMove: Ff(e.onPointerMove, (e => { "touch" !== e.pointerType && (c.current || o.isPointerInTransitRef.current || (i.onTriggerEnter(), c.current = !0)) })), onPointerLeave: Ff(e.onPointerLeave, (() => { i.onTriggerLeave(), c.current = !1 })), onPointerDown: Ff(e.onPointerDown, (() => { l.current = !0, document.addEventListener("pointerup", u, { once: !0 }) })), onFocus: Ff(e.onFocus, (() => { l.current || i.onOpen() })), onBlur: Ff(e.onBlur, i.onClose), onClick: Ff(e.onClick, i.onClose) }))) })), [iv, ov] = Gg("TooltipPortal", { forceMount: void 0 }), av = "TooltipContent", sv = (0, A.forwardRef)(((e, t) => { const n = ov(av, e.__scopeTooltip), { forceMount: r = n.forceMount, side: i = "top", ...o } = e, a = tv(av, e.__scopeTooltip); return (0, A.createElement)(Kg, { present: r || a.open }, a.disableHoverableContent ? (0, A.createElement)(dv, bo({ side: i }, o, { ref: t })) : (0, A.createElement)(lv, bo({ side: i }, o, { ref: t }))) })), lv = (0, A.forwardRef)(((e, t) => { const n = tv(av, e.__scopeTooltip), r = Jg(av, e.__scopeTooltip), i = (0, A.useRef)(null), o = Hf(t, i), [a, s] = (0, A.useState)(null), { trigger: l, onClose: c } = n, u = i.current, { onPointerInTransitChange: d } = r, p = (0, A.useCallback)((() => { s(null), d(!1) }), [d]), h = (0, A.useCallback)(((e, t) => { const n = e.currentTarget, r = { x: e.clientX, y: e.clientY }, i = function (e, t, n = 5) { const r = []; switch (t) { case "top": r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n }); break; case "bottom": r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n }); break; case "left": r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n }); break; case "right": r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n }) }return r }(r, function (e, t) { const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), o = Math.abs(t.left - e.x); switch (Math.min(n, r, i, o)) { case o: return "left"; case i: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } }(r, n.getBoundingClientRect())), o = function (e) { const t = e.slice(); return t.sort(((e, t) => e.x < t.x ? -1 : e.x > t.x ? 1 : e.y < t.y ? -1 : e.y > t.y ? 1 : 0)), function (e) { if (e.length <= 1) return e.slice(); const t = []; for (let n = 0; n < e.length; n++) { const r = e[n]; for (; t.length >= 2;) { const e = t[t.length - 1], n = t[t.length - 2]; if (!((e.x - n.x) * (r.y - n.y) >= (e.y - n.y) * (r.x - n.x))) break; t.pop() } t.push(r) } t.pop(); const n = []; for (let t = e.length - 1; t >= 0; t--) { const r = e[t]; for (; n.length >= 2;) { const e = n[n.length - 1], t = n[n.length - 2]; if (!((e.x - t.x) * (r.y - t.y) >= (e.y - t.y) * (r.x - t.x))) break; n.pop() } n.push(r) } return n.pop(), 1 === t.length && 1 === n.length && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n) }(t) }([...i, ...function (e) { const { top: t, right: n, bottom: r, left: i } = e; return [{ x: i, y: t }, { x: n, y: t }, { x: n, y: r }, { x: i, y: r }] }(t.getBoundingClientRect())]); s(o), d(!0) }), [d]); return (0, A.useEffect)((() => () => p()), [p]), (0, A.useEffect)((() => { if (l && u) { const e = e => h(e, u), t = e => h(e, l); return l.addEventListener("pointerleave", e), u.addEventListener("pointerleave", t), () => { l.removeEventListener("pointerleave", e), u.removeEventListener("pointerleave", t) } } }), [l, u, h, p]), (0, A.useEffect)((() => { if (a) { const e = e => { const t = e.target, n = { x: e.clientX, y: e.clientY }, r = (null == l ? void 0 : l.contains(t)) || (null == u ? void 0 : u.contains(t)), i = !function (e, t) { const { x: n, y: r } = e; let i = !1; for (let e = 0, o = t.length - 1; e < t.length; o = e++) { const a = t[e].x, s = t[e].y, l = t[o].x, c = t[o].y; s > r != c > r && n < (l - a) * (r - s) / (c - s) + a && (i = !i) } return i }(n, a); r ? p() : i && (p(), c()) }; return document.addEventListener("pointermove", e), () => document.removeEventListener("pointermove", e) } }), [l, u, a, c, p]), (0, A.createElement)(dv, bo({}, e, { ref: o })) })), [cv, uv] = Gg($g, { isInside: !1 }), dv = (0, A.forwardRef)(((e, t) => { const { __scopeTooltip: n, children: r, "aria-label": i, onEscapeKeyDown: o, onPointerDownOutside: a, ...s } = e, l = tv(av, n), c = Xg(n), { onClose: u } = l; return (0, A.useEffect)((() => (document.addEventListener(Qg, u), () => document.removeEventListener(Qg, u))), [u]), (0, A.useEffect)((() => { if (l.trigger) { const e = e => { const t = e.target; null != t && t.contains(l.trigger) && u() }; return window.addEventListener("scroll", e, { capture: !0 }), () => window.removeEventListener("scroll", e, { capture: !0 }) } }), [l.trigger, u]), (0, A.createElement)(qf, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: o, onPointerDownOutside: a, onFocusOutside: e => e.preventDefault(), onDismiss: u }, (0, A.createElement)(jg, bo({ "data-state": l.stateAttribute }, c, s, { ref: t, style: { ...s.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" } }), (0, A.createElement)(Kf, null, r), (0, A.createElement)(cv, { scope: n, isInside: !0 }, (0, A.createElement)(Yg, { id: l.contentId, role: "tooltip" }, i || r)))) })), pv = e => { const { __scopeTooltip: t, delayDuration: n = _g, skipDelayDuration: r = 300, disableHoverableContent: i = !1, children: o } = e, [a, s] = (0, A.useState)(!0), l = (0, A.useRef)(!1), c = (0, A.useRef)(0); return (0, A.useEffect)((() => { const e = c.current; return () => window.clearTimeout(e) }), []), (0, A.createElement)(qg, { scope: t, isOpenDelayed: a, delayDuration: n, onOpen: (0, A.useCallback)((() => { window.clearTimeout(c.current), s(!1) }), []), onClose: (0, A.useCallback)((() => { window.clearTimeout(c.current), c.current = window.setTimeout((() => s(!0)), r) }), [r]), isPointerInTransitRef: l, onPointerInTransitChange: (0, A.useCallback)((e => { l.current = e }), []), disableHoverableContent: i }, o) }, hv = e => { const { __scopeTooltip: t, children: n, open: r, defaultOpen: i = !1, onOpenChange: o, disableHoverableContent: a, delayDuration: s } = e, l = Jg($g, e.__scopeTooltip), c = Xg(t), [u, d] = (0, A.useState)(null), p = rm(), h = (0, A.useRef)(0), f = null != a ? a : l.disableHoverableContent, m = null != s ? s : l.delayDuration, g = (0, A.useRef)(!1), [v = !1, y] = function ({ prop: e, defaultProp: t, onChange: n = (() => { }) }) { const [r, i] = function ({ defaultProp: e, onChange: t }) { const n = (0, A.useState)(e), [r] = n, i = (0, A.useRef)(r), o = Sg(t); return (0, A.useEffect)((() => { i.current !== r && (o(r), i.current = r) }), [r, i, o]), n }({ defaultProp: t, onChange: n }), o = void 0 !== e, a = o ? e : r, s = Sg(n); return [a, (0, A.useCallback)((t => { if (o) { const n = "function" == typeof t ? t(e) : t; n !== e && s(n) } else i(t) }), [o, e, i, s])] }({ prop: r, defaultProp: i, onChange: e => { e ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Qg))) : l.onClose(), null == o || o(e) } }), b = (0, A.useMemo)((() => v ? g.current ? "delayed-open" : "instant-open" : "closed"), [v]), w = (0, A.useCallback)((() => { window.clearTimeout(h.current), g.current = !1, y(!0) }), [y]), E = (0, A.useCallback)((() => { window.clearTimeout(h.current), y(!1) }), [y]), C = (0, A.useCallback)((() => { window.clearTimeout(h.current), h.current = window.setTimeout((() => { g.current = !0, y(!0) }), m) }), [m, y]); return (0, A.useEffect)((() => () => window.clearTimeout(h.current)), []), (0, A.createElement)(Hg, c, (0, A.createElement)(ev, { scope: t, contentId: p, open: v, stateAttribute: b, trigger: u, onTriggerChange: d, onTriggerEnter: (0, A.useCallback)((() => { l.isOpenDelayed ? C() : w() }), [l.isOpenDelayed, C, w]), onTriggerLeave: (0, A.useCallback)((() => { f ? E() : window.clearTimeout(h.current) }), [E, f]), onOpen: w, onClose: E, disableHoverableContent: f }, n)) }, fv = rv, mv = sv, gv = (0, A.forwardRef)(((e, t) => { const { __scopeTooltip: n, ...r } = e, i = Xg(n); return uv("TooltipArrow", n).isInside ? null : (0, A.createElement)(Ug, bo({}, i, r, { ref: t })) })); var vv = "undefined" != typeof navigator && navigator.userAgent.toLowerCase().indexOf("firefox") > 0; function yv(e, t, n, r) { e.addEventListener ? e.addEventListener(t, n, r) : e.attachEvent && e.attachEvent("on".concat(t), (function () { n(window.event) })) } function bv(e, t) { for (var n = t.slice(0, t.length - 1), r = 0; r < n.length; r++)n[r] = e[n[r].toLowerCase()]; return n } function wv(e) { "string" != typeof e && (e = ""); for (var t = (e = e.replace(/\s/g, "")).split(","), n = t.lastIndexOf(""); n >= 0;)t[n - 1] += ",", t.splice(n, 1), n = t.lastIndexOf(""); return t } for (var Ev = { backspace: 8, tab: 9, clear: 12, enter: 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, "": 20, ",": 188, ".": 190, "/": 191, "`": 192, "-": vv ? 173 : 189, "=": vv ? 61 : 187, ";": vv ? 59 : 186, "'": 222, "[": 219, "]": 221, "\\": 220 }, Cv = { "": 16, shift: 16, "": 18, alt: 18, option: 18, "": 17, ctrl: 17, control: 17, "": 91, cmd: 91, command: 91 }, Sv = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 }, kv = { 16: !1, 18: !1, 17: !1, 91: !1 }, xv = {}, Av = 1; Av < 20; Av++)Ev["f".concat(Av)] = 111 + Av; var Iv = [], Pv = !1, Mv = "all", Tv = [], Rv = function (e) { return Ev[e.toLowerCase()] || Cv[e.toLowerCase()] || e.toUpperCase().charCodeAt(0) }; function Bv(e) { Mv = e || "all" } function Dv() { return Mv || "all" } var Lv = function (e) { var t = e.key, n = e.scope, r = e.method, i = e.splitKey, o = void 0 === i ? "+" : i; wv(t).forEach((function (e) { var t = e.split(o), i = t.length, a = t[i - 1], s = "*" === a ? "*" : Rv(a); if (xv[s]) { n || (n = Dv()); var l = i > 1 ? bv(Cv, t) : []; xv[s] = xv[s].filter((function (e) { return !((!r || e.method === r) && e.scope === n && function (e, t) { for (var n = e.length >= t.length ? e : t, r = e.length >= t.length ? t : e, i = !0, o = 0; o < n.length; o++)-1 === r.indexOf(n[o]) && (i = !1); return i }(e.mods, l)) })) } })) }; function Ov(e, t, n, r) { var i; if (t.element === r && (t.scope === n || "all" === t.scope)) { for (var o in i = t.mods.length > 0, kv) Object.prototype.hasOwnProperty.call(kv, o) && (!kv[o] && t.mods.indexOf(+o) > -1 || kv[o] && -1 === t.mods.indexOf(+o)) && (i = !1); (0 !== t.mods.length || kv[16] || kv[18] || kv[17] || kv[91]) && !i && "*" !== t.shortcut || !1 === t.method(e, t) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation && e.stopPropagation(), e.cancelBubble && (e.cancelBubble = !0)) } } function Fv(e, t) { var n = xv["*"], r = e.keyCode || e.which || e.charCode; if (zv.filter.call(this, e)) { if (93 !== r && 224 !== r || (r = 91), -1 === Iv.indexOf(r) && 229 !== r && Iv.push(r), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((function (t) { var n = Sv[t]; e[t] && -1 === Iv.indexOf(n) ? Iv.push(n) : !e[t] && Iv.indexOf(n) > -1 ? Iv.splice(Iv.indexOf(n), 1) : "metaKey" === t && e[t] && 3 === Iv.length && (e.ctrlKey || e.shiftKey || e.altKey || (Iv = Iv.slice(Iv.indexOf(n)))) })), r in kv) { for (var i in kv[r] = !0, Cv) Cv[i] === r && (zv[i] = !0); if (!n) return } for (var o in kv) Object.prototype.hasOwnProperty.call(kv, o) && (kv[o] = e[Sv[o]]); e.getModifierState && (!e.altKey || e.ctrlKey) && e.getModifierState("AltGraph") && (-1 === Iv.indexOf(17) && Iv.push(17), -1 === Iv.indexOf(18) && Iv.push(18), kv[17] = !0, kv[18] = !0); var a = Dv(); if (n) for (var s = 0; s < n.length; s++)n[s].scope === a && ("keydown" === e.type && n[s].keydown || "keyup" === e.type && n[s].keyup) && Ov(e, n[s], a, t); if (r in xv) for (var l = 0; l < xv[r].length; l++)if (("keydown" === e.type && xv[r][l].keydown || "keyup" === e.type && xv[r][l].keyup) && xv[r][l].key) { for (var c = xv[r][l], u = c.splitKey, d = c.key.split(u), p = [], h = 0; h < d.length; h++)p.push(Rv(d[h])); p.sort().join("") === Iv.sort().join("") && Ov(e, c, a, t) } } } function zv(e, t, n) { Iv = []; var r = wv(e), i = [], o = "all", a = document, s = 0, l = !1, c = !0, u = "+", d = !1; for (void 0 === n && "function" == typeof t && (n = t), "[object Object]" === Object.prototype.toString.call(t) && (t.scope && (o = t.scope), t.element && (a = t.element), t.keyup && (l = t.keyup), void 0 !== t.keydown && (c = t.keydown), void 0 !== t.capture && (d = t.capture), "string" == typeof t.splitKey && (u = t.splitKey)), "string" == typeof t && (o = t); s < r.length; s++)i = [], (e = r[s].split(u)).length > 1 && (i = bv(Cv, e)), (e = "*" === (e = e[e.length - 1]) ? "*" : Rv(e)) in xv || (xv[e] = []), xv[e].push({ keyup: l, keydown: c, scope: o, mods: i, shortcut: r[s], method: n, key: r[s], splitKey: u, element: a }); void 0 !== a && !function (e) { return Tv.indexOf(e) > -1 }(a) && window && (Tv.push(a), yv(a, "keydown", (function (e) { Fv(e, a) }), d), Pv || (Pv = !0, yv(window, "focus", (function () { Iv = [] }), d)), yv(a, "keyup", (function (e) { Fv(e, a), function (e) { var t = e.keyCode || e.which || e.charCode, n = Iv.indexOf(t); if (n >= 0 && Iv.splice(n, 1), e.key && "meta" === e.key.toLowerCase() && Iv.splice(0, Iv.length), 93 !== t && 224 !== t || (t = 91), t in kv) for (var r in kv[t] = !1, Cv) Cv[r] === t && (zv[r] = !1) }(e) }), d)) } var Hv = { setScope: Bv, getScope: Dv, deleteScope: function (e, t) { var n, r; for (var i in e || (e = Dv()), xv) if (Object.prototype.hasOwnProperty.call(xv, i)) for (n = xv[i], r = 0; r < n.length;)n[r].scope === e ? n.splice(r, 1) : r++; Dv() === e && Bv(t || "all") }, getPressedKeyCodes: function () { return Iv.slice(0) }, isPressed: function (e) { return "string" == typeof e && (e = Rv(e)), -1 !== Iv.indexOf(e) }, filter: function (e) { var t = e.target || e.srcElement, n = t.tagName, r = !0; return !t.isContentEditable && ("INPUT" !== n && "TEXTAREA" !== n && "SELECT" !== n || t.readOnly) || (r = !1), r }, trigger: function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "all"; Object.keys(xv).forEach((function (n) { var r = xv[n].find((function (n) { return n.scope === t && n.shortcut === e })); r && r.method && r.method() })) }, unbind: function (e) { if (void 0 === e) Object.keys(xv).forEach((function (e) { return delete xv[e] })); else if (Array.isArray(e)) e.forEach((function (e) { e.key && Lv(e) })); else if ("object" == typeof e) e.key && Lv(e); else if ("string" == typeof e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; var i = n[0], o = n[1]; "function" == typeof i && (o = i, i = ""), Lv({ key: e, scope: i, method: o, splitKey: "+" }) } }, keyMap: Ev, modifier: Cv, modifierMap: Sv }; for (var Nv in Hv) Object.prototype.hasOwnProperty.call(Hv, Nv) && (zv[Nv] = Hv[Nv]); if ("undefined" != typeof window) { var jv = window.hotkeys; zv.noConflict = function (e) { return e && window.hotkeys === zv && (window.hotkeys = jv), zv }, window.hotkeys = zv } zv.filter = function () { return !0 }; var Uv = function (e, t) { var n = e.target, r = n && n.tagName; return Boolean(r && t && t.includes(r)) }; function Vv(e, t, n, r) { n instanceof Array && (r = n, n = void 0); var i = n || {}, o = i.enableOnTags, a = i.filter, s = i.keyup, l = i.keydown, c = i.filterPreventDefault, u = void 0 === c || c, d = i.enabled, p = void 0 === d || d, h = i.enableOnContentEditable, f = void 0 !== h && h, m = (0, A.useRef)(null), g = (0, A.useCallback)((function (e, n) { var r, i; return a && !a(e) ? !u : !!(Uv(e, ["INPUT", "TEXTAREA", "SELECT"]) && !Uv(e, o) || null != (r = e.target) && r.isContentEditable && !f) || !!(null === m.current || document.activeElement === m.current || null != (i = m.current) && i.contains(document.activeElement)) && (t(e, n), !0) }), r ? [m, o, a].concat(r) : [m, o, a]); return (0, A.useEffect)((function () { if (p) return s && !0 !== l && (n.keydown = !1), zv(e, n || {}, g), function () { return zv.unbind(e, g) }; zv.unbind(e, g) }), [g, e, p]), m } function Kv(e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) } function Wv(e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) } zv.isPressed; const Yv = "focusScope.autoFocusOnMount", Gv = "focusScope.autoFocusOnUnmount", Zv = { bubbles: !1, cancelable: !0 }, Xv = (0, A.forwardRef)(((e, t) => { const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: o, ...a } = e, [s, l] = (0, A.useState)(null), c = Wv(i), u = Wv(o), d = (0, A.useRef)(null), p = Hf(t, (e => l(e))), h = (0, A.useRef)({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; (0, A.useEffect)((() => { if (r) { function e(e) { if (h.paused || !s) return; const t = e.target; s.contains(t) ? d.current = t : Jv(d.current, { select: !0 }) } function t(e) { if (h.paused || !s) return; const t = e.relatedTarget; null !== t && (s.contains(t) || Jv(d.current, { select: !0 })) } function n(e) { if (document.activeElement === document.body) for (const t of e) t.removedNodes.length > 0 && Jv(s) } document.addEventListener("focusin", e), document.addEventListener("focusout", t); const i = new MutationObserver(n); return s && i.observe(s, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", e), document.removeEventListener("focusout", t), i.disconnect() } } }), [r, s, h.paused]), (0, A.useEffect)((() => { if (s) { $v.add(h); const e = document.activeElement; if (!s.contains(e)) { const t = new CustomEvent(Yv, Zv); s.addEventListener(Yv, c), s.dispatchEvent(t), t.defaultPrevented || (function (e, { select: t = !1 } = {}) { const n = document.activeElement; for (const r of e) if (Jv(r, { select: t }), document.activeElement !== n) return }(_v(s).filter((e => "A" !== e.tagName)), { select: !0 }), document.activeElement === e && Jv(s)) } return () => { s.removeEventListener(Yv, c), setTimeout((() => { const t = new CustomEvent(Gv, Zv); s.addEventListener(Gv, u), s.dispatchEvent(t), t.defaultPrevented || Jv(null != e ? e : document.body, { select: !0 }), s.removeEventListener(Gv, u), $v.remove(h) }), 0) } } }), [s, c, u, h]); const f = (0, A.useCallback)((e => { if (!n && !r) return; if (h.paused) return; const t = "Tab" === e.key && !e.altKey && !e.ctrlKey && !e.metaKey, i = document.activeElement; if (t && i) { const t = e.currentTarget, [r, o] = function (e) { const t = _v(e); return [Qv(t, e), Qv(t.reverse(), e)] }(t); r && o ? e.shiftKey || i !== o ? e.shiftKey && i === r && (e.preventDefault(), n && Jv(o, { select: !0 })) : (e.preventDefault(), n && Jv(r, { select: !0 })) : i === t && e.preventDefault() } }), [n, r, h.paused]); return (0, A.createElement)(Gf.div, bo({ tabIndex: -1 }, a, { ref: p, onKeyDown: f })) })); function _v(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: e => { const t = "INPUT" === e.tagName && "hidden" === e.type; return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function Qv(e, t) { for (const n of e) if (!qv(n, { upTo: t })) return n } function qv(e, { upTo: t }) { if ("hidden" === getComputedStyle(e).visibility) return !0; for (; e;) { if (void 0 !== t && e === t) return !1; if ("none" === getComputedStyle(e).display) return !0; e = e.parentElement } return !1 } function Jv(e, { select: t = !1 } = {}) { if (e && e.focus) { const n = document.activeElement; e.focus({ preventScroll: !0 }), e !== n && function (e) { return e instanceof HTMLInputElement && "select" in e }(e) && t && e.select() } } const $v = function () { let e = []; return { add(t) { const n = e[0]; t !== n && (null == n || n.pause()), e = ey(e, t), e.unshift(t) }, remove(t) { var n; e = ey(e, t), null === (n = e[0]) || void 0 === n || n.resume() } } }(); function ey(e, t) { const n = [...e], r = n.indexOf(t); return -1 !== r && n.splice(r, 1), n } let ty = 0; function ny() { (0, A.useEffect)((() => { var e, t; const n = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", null !== (e = n[0]) && void 0 !== e ? e : ry()), document.body.insertAdjacentElement("beforeend", null !== (t = n[1]) && void 0 !== t ? t : ry()), ty++, () => { 1 === ty && document.querySelectorAll("[data-radix-focus-guard]").forEach((e => e.remove())), ty-- } }), []) } function ry() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e } var iy = nc(), oy = function () { }, ay = A.forwardRef((function (e, t) { var n = A.useRef(null), r = A.useState({ onScrollCapture: oy, onWheelCapture: oy, onTouchMoveCapture: oy }), i = r[0], o = r[1], a = e.forwardProps, s = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, d = e.shards, p = e.sideCar, h = e.noIsolation, f = e.inert, m = e.allowPinchZoom, g = e.as, v = void 0 === g ? "div" : g, y = qn(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), b = p, w = ec([n, t]), E = Qn(Qn({}, y), i); return A.createElement(A.Fragment, null, u && A.createElement(b, { sideCar: iy, removeScrollBar: c, shards: d, noIsolation: h, inert: f, setCallbacks: o, allowPinchZoom: !!m, lockRef: n }), a ? A.cloneElement(A.Children.only(s), Qn(Qn({}, E), { ref: w })) : A.createElement(v, Qn({}, E, { className: l, ref: w }), s)) })); ay.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }, ay.classNames = { fullWidth: $l, zeroRight: Jl }; var sy = !1; if ("undefined" != typeof window) try { var ly = Object.defineProperty({}, "passive", { get: function () { return sy = !0, !0 } }); window.addEventListener("test", ly, ly), window.removeEventListener("test", ly, ly) } catch (e) { sy = !1 } var cy = !!sy && { passive: !1 }, uy = function (e, t) { var n = window.getComputedStyle(e); return "hidden" !== n[t] && !(n.overflowY === n.overflowX && !function (e) { return "TEXTAREA" === e.tagName }(e) && "visible" === n[t]) }, dy = function (e, t) { var n = t; do { if ("undefined" != typeof ShadowRoot && n instanceof ShadowRoot && (n = n.host), py(e, n)) { var r = hy(e, n); if (r[1] > r[2]) return !0 } n = n.parentNode } while (n && n !== document.body); return !1 }, py = function (e, t) { return "v" === e ? function (e) { return uy(e, "overflowY") }(t) : function (e) { return uy(e, "overflowX") }(t) }, hy = function (e, t) { return "v" === e ? function (e) { return [e.scrollTop, e.scrollHeight, e.clientHeight] }(t) : function (e) { return [e.scrollLeft, e.scrollWidth, e.clientWidth] }(t) }, fy = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, my = function (e) { return [e.deltaX, e.deltaY] }, gy = function (e) { return e && "current" in e ? e.current : e }, vy = function (e) { return "\n  .block-interactivity-".concat(e, " {pointer-events: none;}\n  .allow-interactivity-").concat(e, " {pointer-events: all;}\n") }, yy = 0, by = []; const wy = sc(iy, (function (e) { var t = A.useRef([]), n = A.useRef([0, 0]), r = A.useRef(), i = A.useState(yy++)[0], o = A.useState((function () { return cc() }))[0], a = A.useRef(e); A.useEffect((function () { a.current = e }), [e]), A.useEffect((function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(i)); var t = Jn([e.lockRef.current], (e.shards || []).map(gy), !0).filter(Boolean); return t.forEach((function (e) { return e.classList.add("allow-interactivity-".concat(i)) })), function () { document.body.classList.remove("block-interactivity-".concat(i)), t.forEach((function (e) { return e.classList.remove("allow-interactivity-".concat(i)) })) } } }), [e.inert, e.lockRef.current, e.shards]); var s = A.useCallback((function (e, t) { if ("touches" in e && 2 === e.touches.length) return !a.current.allowPinchZoom; var i, o = fy(e), s = n.current, l = "deltaX" in e ? e.deltaX : s[0] - o[0], c = "deltaY" in e ? e.deltaY : s[1] - o[1], u = e.target, d = Math.abs(l) > Math.abs(c) ? "h" : "v"; if ("touches" in e && "h" === d && "range" === u.type) return !1; var p = dy(d, u); if (!p) return !0; if (p ? i = d : (i = "v" === d ? "h" : "v", p = dy(d, u)), !p) return !1; if (!r.current && "changedTouches" in e && (l || c) && (r.current = i), !i) return !0; var h = r.current || i; return function (e, t, n, r, i) { var o = function (e, t) { return "h" === e && "rtl" === t ? -1 : 1 }(e, window.getComputedStyle(t).direction), a = o * r, s = n.target, l = t.contains(s), c = !1, u = a > 0, d = 0, p = 0; do { var h = hy(e, s), f = h[0], m = h[1] - h[2] - o * f; (f || m) && py(e, s) && (d += m, p += f), s = s.parentNode } while (!l && s !== document.body || l && (t.contains(s) || t === s)); return (u && (0 === d || !1) || !u && (0 === p || !1)) && (c = !0), c }(h, t, e, "h" === h ? l : c) }), []), l = A.useCallback((function (e) { var n = e; if (by.length && by[by.length - 1] === o) { var r = "deltaY" in n ? my(n) : fy(n), i = t.current.filter((function (e) { return e.name === n.type && e.target === n.target && function (e, t) { return e[0] === t[0] && e[1] === t[1] }(e.delta, r) }))[0]; if (i && i.should) n.cancelable && n.preventDefault(); else if (!i) { var l = (a.current.shards || []).map(gy).filter(Boolean).filter((function (e) { return e.contains(n.target) })); (l.length > 0 ? s(n, l[0]) : !a.current.noIsolation) && n.cancelable && n.preventDefault() } } }), []), c = A.useCallback((function (e, n, r, i) { var o = { name: e, delta: n, target: r, should: i }; t.current.push(o), setTimeout((function () { t.current = t.current.filter((function (e) { return e !== o })) }), 1) }), []), u = A.useCallback((function (e) { n.current = fy(e), r.current = void 0 }), []), d = A.useCallback((function (t) { c(t.type, my(t), t.target, s(t, e.lockRef.current)) }), []), p = A.useCallback((function (t) { c(t.type, fy(t), t.target, s(t, e.lockRef.current)) }), []); A.useEffect((function () { return by.push(o), e.setCallbacks({ onScrollCapture: d, onWheelCapture: d, onTouchMoveCapture: p }), document.addEventListener("wheel", l, cy), document.addEventListener("touchmove", l, cy), document.addEventListener("touchstart", u, cy), function () { by = by.filter((function (e) { return e !== o })), document.removeEventListener("wheel", l, cy), document.removeEventListener("touchmove", l, cy), document.removeEventListener("touchstart", u, cy) } }), []); var h = e.removeScrollBar, f = e.inert; return A.createElement(A.Fragment, null, f ? A.createElement(o, { styles: vy(i) }) : null, h ? A.createElement(fc, { gapMode: "margin" }) : null) })); var Ey = A.forwardRef((function (e, t) { return A.createElement(ay, Qn({}, e, { ref: t, sideCar: wy })) })); Ey.classNames = ay.classNames; const Cy = Ey, Sy = "Dialog", [ky, xy] = Nf(Sy), [Ay, Iy] = ky(Sy), Py = (0, A.forwardRef)(((e, t) => { const { __scopeDialog: n, ...r } = e, i = Iy("DialogTrigger", n), o = Hf(t, i.triggerRef); return (0, A.createElement)(Gf.button, bo({ type: "button", "aria-haspopup": "dialog", "aria-expanded": i.open, "aria-controls": i.contentId, "data-state": Wy(i.open) }, r, { ref: o, onClick: Ff(e.onClick, i.onOpenToggle) })) })), My = "DialogPortal", [Ty, Ry] = ky(My, { forceMount: void 0 }), By = "DialogOverlay", Dy = (0, A.forwardRef)(((e, t) => { const n = Ry(By, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = Iy(By, e.__scopeDialog); return o.modal ? (0, A.createElement)(Kg, { present: r || o.open }, (0, A.createElement)(Ly, bo({}, i, { ref: t }))) : null })), Ly = (0, A.forwardRef)(((e, t) => { const { __scopeDialog: n, ...r } = e, i = Iy(By, n); return (0, A.createElement)(Cy, { as: Uf, allowPinchZoom: !0, shards: [i.contentRef] }, (0, A.createElement)(Gf.div, bo({ "data-state": Wy(i.open) }, r, { ref: t, style: { pointerEvents: "auto", ...r.style } }))) })), Oy = "DialogContent", Fy = (0, A.forwardRef)(((e, t) => { const n = Ry(Oy, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, o = Iy(Oy, e.__scopeDialog); return (0, A.createElement)(Kg, { present: r || o.open }, o.modal ? (0, A.createElement)(zy, bo({}, i, { ref: t })) : (0, A.createElement)(Hy, bo({}, i, { ref: t }))) })), zy = (0, A.forwardRef)(((e, t) => { const n = Iy(Oy, e.__scopeDialog), r = (0, A.useRef)(null), i = Hf(t, n.contentRef, r); return (0, A.useEffect)((() => { const e = r.current; if (e) return ql(e) }), []), (0, A.createElement)(Ny, bo({}, e, { ref: i, trapFocus: n.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: Ff(e.onCloseAutoFocus, (e => { var t; e.preventDefault(), null === (t = n.triggerRef.current) || void 0 === t || t.focus() })), onPointerDownOutside: Ff(e.onPointerDownOutside, (e => { const t = e.detail.originalEvent, n = 0 === t.button && !0 === t.ctrlKey; (2 === t.button || n) && e.preventDefault() })), onFocusOutside: Ff(e.onFocusOutside, (e => e.preventDefault())) })) })), Hy = (0, A.forwardRef)(((e, t) => { const n = Iy(Oy, e.__scopeDialog), r = (0, A.useRef)(!1), i = (0, A.useRef)(!1); return (0, A.createElement)(Ny, bo({}, e, { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: t => { var o, a; null === (o = e.onCloseAutoFocus) || void 0 === o || o.call(e, t), t.defaultPrevented || (r.current || null === (a = n.triggerRef.current) || void 0 === a || a.focus(), t.preventDefault()), r.current = !1, i.current = !1 }, onInteractOutside: t => { var o, a; null === (o = e.onInteractOutside) || void 0 === o || o.call(e, t), t.defaultPrevented || (r.current = !0, "pointerdown" === t.detail.originalEvent.type && (i.current = !0)); const s = t.target; (null === (a = n.triggerRef.current) || void 0 === a ? void 0 : a.contains(s)) && t.preventDefault(), "focusin" === t.detail.originalEvent.type && i.current && t.preventDefault() } })) })), Ny = (0, A.forwardRef)(((e, t) => { const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, ...a } = e, s = Iy(Oy, n), l = Hf(t, (0, A.useRef)(null)); return ny(), (0, A.createElement)(A.Fragment, null, (0, A.createElement)(Xv, { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: i, onUnmountAutoFocus: o }, (0, A.createElement)(qf, bo({ role: "dialog", id: s.contentId, "aria-describedby": s.descriptionId, "aria-labelledby": s.titleId, "data-state": Wy(s.open) }, a, { ref: l, onDismiss: () => s.onOpenChange(!1) }))), !1) })), jy = "DialogTitle", Uy = (0, A.forwardRef)(((e, t) => { const { __scopeDialog: n, ...r } = e, i = Iy(jy, n); return (0, A.createElement)(Gf.h2, bo({ id: i.titleId }, r, { ref: t })) })), Vy = (0, A.forwardRef)(((e, t) => { const { __scopeDialog: n, ...r } = e, i = Iy("DialogDescription", n); return (0, A.createElement)(Gf.p, bo({ id: i.descriptionId }, r, { ref: t })) })), Ky = (0, A.forwardRef)(((e, t) => { const { __scopeDialog: n, ...r } = e, i = Iy("DialogClose", n); return (0, A.createElement)(Gf.button, bo({ type: "button" }, r, { ref: t, onClick: Ff(e.onClick, (() => i.onOpenChange(!1))) })) })); function Wy(e) { return e ? "open" : "closed" } const [Yy, Gy] = function (e, t) { const n = (0, A.createContext)(t); function r(e) { const { children: t, ...r } = e, i = (0, A.useMemo)((() => r), Object.values(r)); return (0, A.createElement)(n.Provider, { value: i }, t) } return r.displayName = e + "Provider", [r, function (r) { const i = (0, A.useContext)(n); if (i) return i; if (void 0 !== t) return t; throw new Error(`\`${r}\` must be used within \`${e}\``) }] }("DialogTitleWarning", { contentName: Oy, titleName: jy, docsSlug: "dialog" }), Zy = e => { const { __scopeDialog: t, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: a = !0 } = e, s = (0, A.useRef)(null), l = (0, A.useRef)(null), [c = !1, u] = function ({ prop: e, defaultProp: t, onChange: n = (() => { }) }) { const [r, i] = function ({ defaultProp: e, onChange: t }) { const n = (0, A.useState)(e), [r] = n, i = (0, A.useRef)(r), o = Kv(t); return (0, A.useEffect)((() => { i.current !== r && (o(r), i.current = r) }), [r, i, o]), n }({ defaultProp: t, onChange: n }), o = void 0 !== e, a = o ? e : r, s = Kv(n); return [a, (0, A.useCallback)((t => { if (o) { const n = "function" == typeof t ? t(e) : t; n !== e && s(n) } else i(t) }), [o, e, i, s])] }({ prop: r, defaultProp: i, onChange: o }); return (0, A.createElement)(Ay, { scope: t, triggerRef: s, contentRef: l, contentId: rm(), titleId: rm(), descriptionId: rm(), open: c, onOpenChange: u, onOpenToggle: (0, A.useCallback)((() => u((e => !e))), [u]), modal: a }, n) }, Xy = Py, _y = e => { const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, o = Iy(My, t); return (0, A.createElement)(Ty, { scope: t, forceMount: n }, A.Children.map(r, (e => (0, A.createElement)(Kg, { present: n || o.open }, (0, A.createElement)(Vg, { asChild: !0, container: i }, e))))) }, Qy = Dy, qy = Fy, Jy = Uy, $y = Vy, eb = Ky, [tb, nb] = Nf("AlertDialog", [xy]), rb = xy(), ib = (0, A.forwardRef)(((e, t) => { const { __scopeAlertDialog: n, ...r } = e, i = rb(n); return (0, A.createElement)(Xy, bo({}, i, r, { ref: t })) })), ob = (0, A.forwardRef)(((e, t) => { const { __scopeAlertDialog: n, ...r } = e, i = rb(n); return (0, A.createElement)(Qy, bo({}, i, r, { ref: t })) })), ab = "AlertDialogContent", [sb, lb] = tb(ab), cb = (0, A.forwardRef)(((e, t) => { const { __scopeAlertDialog: n, children: r, ...i } = e, o = rb(n), a = Hf(t, (0, A.useRef)(null)), s = (0, A.useRef)(null); return (0, A.createElement)(Yy, { contentName: ab, titleName: ub, docsSlug: "alert-dialog" }, (0, A.createElement)(sb, { scope: n, cancelRef: s }, (0, A.createElement)(qy, bo({ role: "alertdialog" }, o, i, { ref: a, onOpenAutoFocus: Ff(i.onOpenAutoFocus, (e => { var t; e.preventDefault(), null === (t = s.current) || void 0 === t || t.focus({ preventScroll: !0 }) })), onPointerDownOutside: e => e.preventDefault(), onInteractOutside: e => e.preventDefault() }), (0, A.createElement)(Kf, null, r), !1))) })), ub = "AlertDialogTitle", db = (0, A.forwardRef)(((e, t) => { const { __scopeAlertDialog: n, ...r } = e, i = rb(n); return (0, A.createElement)($y, bo({}, i, r, { ref: t })) })), pb = e => { const { __scopeAlertDialog: t, ...n } = e, r = rb(t); return (0, A.createElement)(Zy, bo({}, r, n, { modal: !0 })) }, hb = ib, fb = e => { const { __scopeAlertDialog: t, ...n } = e, r = rb(t); return (0, A.createElement)(_y, bo({}, r, n)) }, mb = ob, gb = cb, vb = (0, A.forwardRef)(((e, t) => { const { __scopeAlertDialog: n, ...r } = e, i = rb(n); return (0, A.createElement)(eb, bo({}, i, r, { ref: t })) })), yb = (0, A.forwardRef)(((e, t) => { const { __scopeAlertDialog: n, ...r } = e, { cancelRef: i } = lb("AlertDialogCancel", n), o = rb(n), a = Hf(t, i); return (0, A.createElement)(eb, bo({}, o, r, { ref: a })) })), bb = db; function wb(e, t, n) { let { reference: r, floating: i } = e; const o = ym(t), a = bm(t), s = vm(a), l = fm(t), c = "y" === o, u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, p = r[s] / 2 - i[s] / 2; let h; switch (l) { case "top": h = { x: u, y: r.y - i.height }; break; case "bottom": h = { x: u, y: r.y + r.height }; break; case "right": h = { x: r.x + r.width, y: d }; break; case "left": h = { x: r.x - i.width, y: d }; break; default: h = { x: r.x, y: r.y } }switch (mm(t)) { case "start": h[a] -= p * (n && c ? -1 : 1); break; case "end": h[a] += p * (n && c ? -1 : 1) }return h } async function Eb(e, t) { var n; void 0 === t && (t = {}); const { x: r, y: i, platform: o, rects: a, elements: s, strategy: l } = e, { boundary: c = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: p = !1, padding: h = 0 } = hm(t, e), f = xm(h), m = s[p ? "floating" === d ? "reference" : "floating" : d], g = Am(await o.getClippingRect({ element: null == (n = await (null == o.isElement ? void 0 : o.isElement(m))) || n ? m : m.contextElement || await (null == o.getDocumentElement ? void 0 : o.getDocumentElement(s.floating)), boundary: c, rootBoundary: u, strategy: l })), v = "floating" === d ? { ...a.floating, x: r, y: i } : a.reference, y = await (null == o.getOffsetParent ? void 0 : o.getOffsetParent(s.floating)), b = await (null == o.isElement ? void 0 : o.isElement(y)) && await (null == o.getScale ? void 0 : o.getScale(y)) || { x: 1, y: 1 }, w = Am(o.convertOffsetParentRelativeRectToViewportRelativeRect ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: y, strategy: l }) : v); return { top: (g.top - w.top + f.top) / b.y, bottom: (w.bottom - g.bottom + f.bottom) / b.y, left: (g.left - w.left + f.left) / b.x, right: (w.right - g.right + f.right) / b.x } } const Cb = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: r, placement: i, rects: o, platform: a, elements: s, middlewareData: l } = t, { element: c, padding: u = 0 } = hm(e, t) || {}; if (null == c) return {}; const d = xm(u), p = { x: n, y: r }, h = bm(i), f = vm(h), m = await a.getDimensions(c), g = "y" === h, v = g ? "top" : "left", y = g ? "bottom" : "right", b = g ? "clientHeight" : "clientWidth", w = o.reference[f] + o.reference[h] - p[h] - o.floating[f], E = p[h] - o.reference[h], C = await (null == a.getOffsetParent ? void 0 : a.getOffsetParent(c)); let S = C ? C[b] : 0; S && await (null == a.isElement ? void 0 : a.isElement(C)) || (S = s.floating[b] || o.floating[f]); const k = w / 2 - E / 2, x = S / 2 - m[f] / 2 - 1, A = om(d[v], x), I = om(d[y], x), P = A, M = S - m[f] - I, T = S / 2 - m[f] / 2 + k, R = pm(P, T, M), B = !l.arrow && null != mm(i) && T != R && o.reference[f] / 2 - (T < P ? A : I) - m[f] / 2 < 0, D = B ? T < P ? T - P : T - M : 0; return { [h]: p[h] + D, data: { [h]: R, centerOffset: T - R - D, ...B && { alignmentOffset: D } }, reset: B } } }), Sb = function (e) { return void 0 === e && (e = {}), { name: "flip", options: e, async fn(t) { var n, r; const { placement: i, middlewareData: o, rects: a, initialPlacement: s, platform: l, elements: c } = t, { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: p, fallbackStrategy: h = "bestFit", fallbackAxisSideDirection: f = "none", flipAlignment: m = !0, ...g } = hm(e, t); if (null != (n = o.arrow) && n.alignmentOffset) return {}; const v = fm(i), y = fm(s) === s, b = await (null == l.isRTL ? void 0 : l.isRTL(c.floating)), w = p || (y || !m ? [km(s)] : Em(s)); p || "none" === f || w.push(...Sm(s, m, f, b)); const E = [s, ...w], C = await Eb(t, g), S = []; let k = (null == (r = o.flip) ? void 0 : r.overflows) || []; if (u && S.push(C[v]), d) { const e = wm(i, a, b); S.push(C[e[0]], C[e[1]]) } if (k = [...k, { placement: i, overflows: S }], !S.every((e => e <= 0))) { var x, A; const e = ((null == (x = o.flip) ? void 0 : x.index) || 0) + 1, t = E[e]; if (t) return { data: { index: e, overflows: k }, reset: { placement: t } }; let n = null == (A = k.filter((e => e.overflows[0] <= 0)).sort(((e, t) => e.overflows[1] - t.overflows[1]))[0]) ? void 0 : A.placement; if (!n) switch (h) { case "bestFit": { var I; const e = null == (I = k.map((e => [e.placement, e.overflows.filter((e => e > 0)).reduce(((e, t) => e + t), 0)])).sort(((e, t) => e[1] - t[1]))[0]) ? void 0 : I[0]; e && (n = e); break } case "initialPlacement": n = s }if (i !== n) return { reset: { placement: n } } } return {} } } }; function kb(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function xb(e) { return im.some((t => e[t] >= 0)) } const Ab = function (e) { return void 0 === e && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: n } = t, { strategy: r = "referenceHidden", ...i } = hm(e, t); switch (r) { case "referenceHidden": { const e = kb(await Eb(t, { ...i, elementContext: "reference" }), n.reference); return { data: { referenceHiddenOffsets: e, referenceHidden: xb(e) } } } case "escaped": { const e = kb(await Eb(t, { ...i, altBoundary: !0 }), n.floating); return { data: { escapedOffsets: e, escaped: xb(e) } } } default: return {} } } } }, Ib = function (e) { return void 0 === e && (e = 0), { name: "offset", options: e, async fn(t) { const { x: n, y: r } = t, i = await async function (e, t) { const { placement: n, platform: r, elements: i } = e, o = await (null == r.isRTL ? void 0 : r.isRTL(i.floating)), a = fm(n), s = mm(n), l = "y" === ym(n), c = ["left", "top"].includes(a) ? -1 : 1, u = o && l ? -1 : 1, d = hm(t, e); let { mainAxis: p, crossAxis: h, alignmentAxis: f } = "number" == typeof d ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d }; return s && "number" == typeof f && (h = "end" === s ? -1 * f : f), l ? { x: h * u, y: p * c } : { x: p * c, y: h * u } }(t, e); return { x: n + i.x, y: r + i.y, data: i } } } }, Pb = function (e) { return void 0 === e && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: r, placement: i } = t, { mainAxis: o = !0, crossAxis: a = !1, limiter: s = { fn: e => { let { x: t, y: n } = e; return { x: t, y: n } } }, ...l } = hm(e, t), c = { x: n, y: r }, u = await Eb(t, l), d = ym(fm(i)), p = gm(d); let h = c[p], f = c[d]; if (o) { const e = "y" === p ? "bottom" : "right"; h = pm(h + u["y" === p ? "top" : "left"], h, h - u[e]) } if (a) { const e = "y" === d ? "bottom" : "right"; f = pm(f + u["y" === d ? "top" : "left"], f, f - u[e]) } const m = s.fn({ ...t, [p]: h, [d]: f }); return { ...m, data: { x: m.x - n, y: m.y - r } } } } }, Mb = function (e) { return void 0 === e && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: i, rects: o, middlewareData: a } = t, { offset: s = 0, mainAxis: l = !0, crossAxis: c = !0 } = hm(e, t), u = { x: n, y: r }, d = ym(i), p = gm(d); let h = u[p], f = u[d]; const m = hm(s, t), g = "number" == typeof m ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m }; if (l) { const e = "y" === p ? "height" : "width", t = o.reference[p] - o.floating[e] + g.mainAxis, n = o.reference[p] + o.reference[e] - g.mainAxis; h < t ? h = t : h > n && (h = n) } if (c) { var v, y; const e = "y" === p ? "width" : "height", t = ["top", "left"].includes(fm(i)), n = o.reference[d] - o.floating[e] + (t && (null == (v = a.offset) ? void 0 : v[d]) || 0) + (t ? 0 : g.crossAxis), r = o.reference[d] + o.reference[e] + (t ? 0 : (null == (y = a.offset) ? void 0 : y[d]) || 0) - (t ? g.crossAxis : 0); f < n ? f = n : f > r && (f = r) } return { [p]: h, [d]: f } } } }, Tb = function (e) { return void 0 === e && (e = {}), { name: "size", options: e, async fn(t) { const { placement: n, rects: r, platform: i, elements: o } = t, { apply: a = (() => { }), ...s } = hm(e, t), l = await Eb(t, s), c = fm(n), u = mm(n), d = "y" === ym(n), { width: p, height: h } = r.floating; let f, m; "top" === c || "bottom" === c ? (f = c, m = u === (await (null == i.isRTL ? void 0 : i.isRTL(o.floating)) ? "start" : "end") ? "left" : "right") : (m = c, f = "end" === u ? "top" : "bottom"); const g = h - l[f], v = p - l[m], y = !t.middlewareData.shift; let b = g, w = v; if (d) { const e = p - l.left - l.right; w = u || y ? om(v, e) : e } else { const e = h - l.top - l.bottom; b = u || y ? om(g, e) : e } if (y && !u) { const e = am(l.left, 0), t = am(l.right, 0), n = am(l.top, 0), r = am(l.bottom, 0); d ? w = p - 2 * (0 !== e || 0 !== t ? e + t : am(l.left, l.right)) : b = h - 2 * (0 !== n || 0 !== r ? n + r : am(l.top, l.bottom)) } await a({ ...t, availableWidth: w, availableHeight: b }); const E = await i.getDimensions(o.floating); return p !== E.width || h !== E.height ? { reset: { rects: !0 } } : {} } } }; function Rb(e) { const t = qm(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const i = Km(e), o = i ? e.offsetWidth : n, a = i ? e.offsetHeight : r, s = sm(n) !== o || sm(r) !== a; return s && (n = o, r = a), { width: n, height: r, $: s } } function Bb(e) { return Vm(e) ? e : e.contextElement } function Db(e) { const t = Bb(e); if (!Km(t)) return cm(1); const n = t.getBoundingClientRect(), { width: r, height: i, $: o } = Rb(t); let a = (o ? sm(n.width) : n.width) / r, s = (o ? sm(n.height) : n.height) / i; return a && Number.isFinite(a) || (a = 1), s && Number.isFinite(s) || (s = 1), { x: a, y: s } } const Lb = cm(0); function Ob(e) { const t = Nm(e); return _m() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : Lb } function Fb(e, t, n, r) { void 0 === t && (t = !1), void 0 === n && (n = !1); const i = e.getBoundingClientRect(), o = Bb(e); let a = cm(1); t && (r ? Vm(r) && (a = Db(r)) : a = Db(e)); const s = function (e, t, n) { return void 0 === t && (t = !1), !(!n || t && n !== Nm(e)) && t }(o, n, r) ? Ob(o) : cm(0); let l = (i.left + s.x) / a.x, c = (i.top + s.y) / a.y, u = i.width / a.x, d = i.height / a.y; if (o) { const e = Nm(o), t = r && Vm(r) ? Nm(r) : r; let n = e.frameElement; for (; n && r && t !== e;) { const e = Db(n), t = n.getBoundingClientRect(), r = qm(n), i = t.left + (n.clientLeft + parseFloat(r.paddingLeft)) * e.x, o = t.top + (n.clientTop + parseFloat(r.paddingTop)) * e.y; l *= e.x, c *= e.y, u *= e.x, d *= e.y, l += i, c += o, n = Nm(n).frameElement } } return Am({ width: u, height: d, x: l, y: c }) } function zb(e) { return Fb(jm(e)).left + Jm(e).scrollLeft } function Hb(e, t, n) { let r; if ("viewport" === t) r = function (e, t) { const n = Nm(e), r = jm(e), i = n.visualViewport; let o = r.clientWidth, a = r.clientHeight, s = 0, l = 0; if (i) { o = i.width, a = i.height; const e = _m(); (!e || e && "fixed" === t) && (s = i.offsetLeft, l = i.offsetTop) } return { width: o, height: a, x: s, y: l } }(e, n); else if ("document" === t) r = function (e) { const t = jm(e), n = Jm(e), r = e.ownerDocument.body, i = am(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), o = am(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let a = -n.scrollLeft + zb(e); const s = -n.scrollTop; return "rtl" === qm(r).direction && (a += am(t.clientWidth, r.clientWidth) - i), { width: i, height: o, x: a, y: s } }(jm(e)); else if (Vm(t)) r = function (e, t) { const n = Fb(e, !0, "fixed" === t), r = n.top + e.clientTop, i = n.left + e.clientLeft, o = Km(e) ? Db(e) : cm(1); return { width: e.clientWidth * o.x, height: e.clientHeight * o.y, x: i * o.x, y: r * o.y } }(t, n); else { const n = Ob(e); r = { ...t, x: t.x - n.x, y: t.y - n.y } } return Am(r) } function Nb(e, t) { const n = $m(e); return !(n === t || !Vm(n) || Qm(n)) && ("fixed" === qm(n).position || Nb(n, t)) } function jb(e, t, n) { const r = Km(t), i = jm(t), o = "fixed" === n, a = Fb(e, !0, o, t); let s = { scrollLeft: 0, scrollTop: 0 }; const l = cm(0); if (r || !r && !o) if (("body" !== Hm(t) || Ym(i)) && (s = Jm(t)), r) { const e = Fb(t, !0, o, t); l.x = e.x + t.clientLeft, l.y = e.y + t.clientTop } else i && (l.x = zb(i)); return { x: a.left + s.scrollLeft - l.x, y: a.top + s.scrollTop - l.y, width: a.width, height: a.height } } function Ub(e, t) { return Km(e) && "fixed" !== qm(e).position ? t ? t(e) : e.offsetParent : null } function Vb(e, t) { const n = Nm(e); if (!Km(e)) return n; let r = Ub(e, t); for (; r && Gm(r) && "static" === qm(r).position;)r = Ub(r, t); return r && ("html" === Hm(r) || "body" === Hm(r) && "static" === qm(r).position && !Zm(r)) ? n : r || Xm(e) || n } const Kb = { convertOffsetParentRelativeRectToViewportRelativeRect: function (e) { let { rect: t, offsetParent: n, strategy: r } = e; const i = Km(n), o = jm(n); if (n === o) return t; let a = { scrollLeft: 0, scrollTop: 0 }, s = cm(1); const l = cm(0); if ((i || !i && "fixed" !== r) && (("body" !== Hm(n) || Ym(o)) && (a = Jm(n)), Km(n))) { const e = Fb(n); s = Db(n), l.x = e.x + n.clientLeft, l.y = e.y + n.clientTop } return { width: t.width * s.x, height: t.height * s.y, x: t.x * s.x - a.scrollLeft * s.x + l.x, y: t.y * s.y - a.scrollTop * s.y + l.y } }, getDocumentElement: jm, getClippingRect: function (e) { let { element: t, boundary: n, rootBoundary: r, strategy: i } = e; const o = [..."clippingAncestors" === n ? function (e, t) { const n = t.get(e); if (n) return n; let r = tg(e, [], !1).filter((e => Vm(e) && "body" !== Hm(e))), i = null; const o = "fixed" === qm(e).position; let a = o ? $m(e) : e; for (; Vm(a) && !Qm(a);) { const t = qm(a), n = Zm(a); n || "fixed" !== t.position || (i = null), (o ? !n && !i : !n && "static" === t.position && i && ["absolute", "fixed"].includes(i.position) || Ym(a) && !n && Nb(e, a)) ? r = r.filter((e => e !== a)) : i = t, a = $m(a) } return t.set(e, r), r }(t, this._c) : [].concat(n), r], a = o[0], s = o.reduce(((e, n) => { const r = Hb(t, n, i); return e.top = am(r.top, e.top), e.right = om(r.right, e.right), e.bottom = om(r.bottom, e.bottom), e.left = am(r.left, e.left), e }), Hb(t, a, i)); return { width: s.right - s.left, height: s.bottom - s.top, x: s.left, y: s.top } }, getOffsetParent: Vb, getElementRects: async function (e) { let { reference: t, floating: n, strategy: r } = e; const i = this.getOffsetParent || Vb, o = this.getDimensions; return { reference: jb(t, await i(n), r), floating: { x: 0, y: 0, ...await o(n) } } }, getClientRects: function (e) { return Array.from(e.getClientRects()) }, getDimensions: function (e) { return Rb(e) }, getScale: Db, isElement: Vm, isRTL: function (e) { return "rtl" === qm(e).direction } }; const Wb = e => ({ name: "arrow", options: e, fn(t) { const { element: n, padding: r } = "function" == typeof e ? e(t) : e; return n && (i = n, {}.hasOwnProperty.call(i, "current")) ? null != n.current ? Cb({ element: n.current, padding: r }).fn(t) : {} : n ? Cb({ element: n, padding: r }).fn(t) : {}; var i } }); var Yb = "undefined" != typeof document ? A.useLayoutEffect : A.useEffect; function Gb(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if ("function" == typeof e && e.toString() === t.toString()) return !0; let n, r, i; if (e && t && "object" == typeof e) { if (Array.isArray(e)) { if (n = e.length, n != t.length) return !1; for (r = n; 0 != r--;)if (!Gb(e[r], t[r])) return !1; return !0 } if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length) return !1; for (r = n; 0 != r--;)if (!{}.hasOwnProperty.call(t, i[r])) return !1; for (r = n; 0 != r--;) { const n = i[r]; if (!("_owner" === n && e.$$typeof || Gb(e[n], t[n]))) return !1 } return !0 } return e != e && t != t } function Zb(e) { return "undefined" == typeof window ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function Xb(e, t) { const n = Zb(e); return Math.round(t * n) / n } function _b(e) { const t = A.useRef(e); return Yb((() => { t.current = e })), t } function Qb(e) { const t = (0, A.useRef)(e); return (0, A.useEffect)((() => { t.current = e })), (0, A.useMemo)((() => (...e) => { var n; return null === (n = t.current) || void 0 === n ? void 0 : n.call(t, ...e) }), []) } const qb = "Popper", [Jb, $b] = Nf(qb), [ew, tw] = Jb(qb), nw = (0, A.forwardRef)(((e, t) => { const { __scopePopper: n, virtualRef: r, ...i } = e, o = tw("PopperAnchor", n), a = (0, A.useRef)(null), s = Hf(t, a); return (0, A.useEffect)((() => { o.onAnchorChange((null == r ? void 0 : r.current) || a.current) })), r ? null : (0, A.createElement)(Gf.div, bo({}, i, { ref: s })) })), rw = "PopperContent", [iw, ow] = Jb(rw), aw = (0, A.forwardRef)(((e, t) => { var n, r, i, o, a, s, l, c; const { __scopePopper: u, side: d = "bottom", sideOffset: p = 0, align: h = "center", alignOffset: f = 0, arrowPadding: m = 0, avoidCollisions: g = !0, collisionBoundary: v = [], collisionPadding: y = 0, sticky: b = "partial", hideWhenDetached: w = !1, updatePositionStrategy: E = "optimized", onPlaced: C, ...S } = e, k = tw(rw, u), [x, I] = (0, A.useState)(null), P = Hf(t, (e => I(e))), [M, T] = (0, A.useState)(null), R = function (e) { const [t, n] = (0, A.useState)(void 0); return em((() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const t = new ResizeObserver((t => { if (!Array.isArray(t)) return; if (!t.length) return; const r = t[0]; let i, o; if ("borderBoxSize" in r) { const e = r.borderBoxSize, t = Array.isArray(e) ? e[0] : e; i = t.inlineSize, o = t.blockSize } else i = e.offsetWidth, o = e.offsetHeight; n({ width: i, height: o }) })); return t.observe(e, { box: "border-box" }), () => t.unobserve(e) } n(void 0) }), [e]), t }(M), B = null !== (n = null == R ? void 0 : R.width) && void 0 !== n ? n : 0, D = null !== (r = null == R ? void 0 : R.height) && void 0 !== r ? r : 0, L = d + ("center" !== h ? "-" + h : ""), O = "number" == typeof y ? y : { top: 0, right: 0, bottom: 0, left: 0, ...y }, F = Array.isArray(v) ? v : [v], z = F.length > 0, H = { padding: O, boundary: F.filter(sw), altBoundary: z }, { refs: N, floatingStyles: j, placement: U, isPositioned: V, middlewareData: K } = function (e) { void 0 === e && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: i, elements: { reference: o, floating: a } = {}, transform: s = !0, whileElementsMounted: l, open: c } = e, [u, d] = A.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [p, h] = A.useState(r); Gb(p, r) || h(r); const [f, m] = A.useState(null), [g, v] = A.useState(null), y = A.useCallback((e => { e != C.current && (C.current = e, m(e)) }), [m]), b = A.useCallback((e => { e !== S.current && (S.current = e, v(e)) }), [v]), w = o || f, E = a || g, C = A.useRef(null), S = A.useRef(null), k = A.useRef(u), x = _b(l), I = _b(i), P = A.useCallback((() => { if (!C.current || !S.current) return; const e = { placement: t, strategy: n, middleware: p }; I.current && (e.platform = I.current), ((e, t, n) => { const r = new Map, i = { platform: Kb, ...n }, o = { ...i.platform, _c: r }; return (async (e, t, n) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: o = [], platform: a } = n, s = o.filter(Boolean), l = await (null == a.isRTL ? void 0 : a.isRTL(t)); let c = await a.getElementRects({ reference: e, floating: t, strategy: i }), { x: u, y: d } = wb(c, r, l), p = r, h = {}, f = 0; for (let n = 0; n < s.length; n++) { const { name: o, fn: m } = s[n], { x: g, y: v, data: y, reset: b } = await m({ x: u, y: d, initialPlacement: r, placement: p, strategy: i, middlewareData: h, rects: c, platform: a, elements: { reference: e, floating: t } }); u = null != g ? g : u, d = null != v ? v : d, h = { ...h, [o]: { ...h[o], ...y } }, b && f <= 50 && (f++, "object" == typeof b && (b.placement && (p = b.placement), b.rects && (c = !0 === b.rects ? await a.getElementRects({ reference: e, floating: t, strategy: i }) : b.rects), ({ x: u, y: d } = wb(c, p, l))), n = -1) } return { x: u, y: d, placement: p, strategy: i, middlewareData: h } })(e, t, { ...i, platform: o }) })(C.current, S.current, e).then((e => { const t = { ...e, isPositioned: !0 }; M.current && !Gb(k.current, t) && (k.current = t, Co.flushSync((() => { d(t) }))) })) }), [p, t, n, I]); Yb((() => { !1 === c && k.current.isPositioned && (k.current.isPositioned = !1, d((e => ({ ...e, isPositioned: !1 })))) }), [c]); const M = A.useRef(!1); Yb((() => (M.current = !0, () => { M.current = !1 })), []), Yb((() => { if (w && (C.current = w), E && (S.current = E), w && E) { if (x.current) return x.current(w, E, P); P() } }), [w, E, P, x]); const T = A.useMemo((() => ({ reference: C, floating: S, setReference: y, setFloating: b })), [y, b]), R = A.useMemo((() => ({ reference: w, floating: E })), [w, E]), B = A.useMemo((() => { const e = { position: n, left: 0, top: 0 }; if (!R.floating) return e; const t = Xb(R.floating, u.x), r = Xb(R.floating, u.y); return s ? { ...e, transform: "translate(" + t + "px, " + r + "px)", ...Zb(R.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: t, top: r } }), [n, s, R.floating, u.x, u.y]); return A.useMemo((() => ({ ...u, update: P, refs: T, elements: R, floatingStyles: B })), [u, P, T, R, B]) }({ strategy: "fixed", placement: L, whileElementsMounted: (...e) => function (e, t, n, r) { void 0 === r && (r = {}); const { ancestorScroll: i = !0, ancestorResize: o = !0, elementResize: a = "function" == typeof ResizeObserver, layoutShift: s = "function" == typeof IntersectionObserver, animationFrame: l = !1 } = r, c = Bb(e), u = i || o ? [...c ? tg(c) : [], ...tg(t)] : []; u.forEach((e => { i && e.addEventListener("scroll", n, { passive: !0 }), o && e.addEventListener("resize", n) })); const d = c && s ? function (e, t) { let n, r = null; const i = jm(e); function o() { clearTimeout(n), r && r.disconnect(), r = null } return function a(s, l) { void 0 === s && (s = !1), void 0 === l && (l = 1), o(); const { left: c, top: u, width: d, height: p } = e.getBoundingClientRect(); if (s || t(), !d || !p) return; const h = { rootMargin: -lm(u) + "px " + -lm(i.clientWidth - (c + d)) + "px " + -lm(i.clientHeight - (u + p)) + "px " + -lm(c) + "px", threshold: am(0, om(1, l)) || 1 }; let f = !0; function m(e) { const t = e[0].intersectionRatio; if (t !== l) { if (!f) return a(); t ? a(!1, t) : n = setTimeout((() => { a(!1, 1e-7) }), 100) } f = !1 } try { r = new IntersectionObserver(m, { ...h, root: i.ownerDocument }) } catch (e) { r = new IntersectionObserver(m, h) } r.observe(e) }(!0), o }(c, n) : null; let p, h = -1, f = null; a && (f = new ResizeObserver((e => { let [r] = e; r && r.target === c && f && (f.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame((() => { f && f.observe(t) }))), n() })), c && !l && f.observe(c), f.observe(t)); let m = l ? Fb(e) : null; return l && function t() { const r = Fb(e); !m || r.x === m.x && r.y === m.y && r.width === m.width && r.height === m.height || n(), m = r, p = requestAnimationFrame(t) }(), n(), () => { u.forEach((e => { i && e.removeEventListener("scroll", n), o && e.removeEventListener("resize", n) })), d && d(), f && f.disconnect(), f = null, l && cancelAnimationFrame(p) } }(...e, { animationFrame: "always" === E }), elements: { reference: k.anchor }, middleware: [Ib({ mainAxis: p + D, alignmentAxis: f }), g && Pb({ mainAxis: !0, crossAxis: !1, limiter: "partial" === b ? Mb() : void 0, ...H }), g && Sb({ ...H }), Tb({ ...H, apply: ({ elements: e, rects: t, availableWidth: n, availableHeight: r }) => { const { width: i, height: o } = t.reference, a = e.floating.style; a.setProperty("--radix-popper-available-width", `${n}px`), a.setProperty("--radix-popper-available-height", `${r}px`), a.setProperty("--radix-popper-anchor-width", `${i}px`), a.setProperty("--radix-popper-anchor-height", `${o}px`) } }), M && Wb({ element: M, padding: m }), lw({ arrowWidth: B, arrowHeight: D }), w && Ab({ strategy: "referenceHidden", ...H })] }), [W, Y] = cw(U), G = Qb(C); em((() => { V && (null == G || G()) }), [V, G]); const Z = null === (i = K.arrow) || void 0 === i ? void 0 : i.x, X = null === (o = K.arrow) || void 0 === o ? void 0 : o.y, _ = 0 !== (null === (a = K.arrow) || void 0 === a ? void 0 : a.centerOffset), [Q, q] = (0, A.useState)(); return em((() => { x && q(window.getComputedStyle(x).zIndex) }), [x]), (0, A.createElement)("div", { ref: N.setFloating, "data-radix-popper-content-wrapper": "", style: { ...j, transform: V ? j.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: Q, "--radix-popper-transform-origin": [null === (s = K.transformOrigin) || void 0 === s ? void 0 : s.x, null === (l = K.transformOrigin) || void 0 === l ? void 0 : l.y].join(" ") }, dir: e.dir }, (0, A.createElement)(iw, { scope: u, placedSide: W, onArrowChange: T, arrowX: Z, arrowY: X, shouldHideArrow: _ }, (0, A.createElement)(Gf.div, bo({ "data-side": W, "data-align": Y }, S, { ref: P, style: { ...S.style, animation: V ? void 0 : "none", opacity: null !== (c = K.hide) && void 0 !== c && c.referenceHidden ? 0 : void 0 } })))) })); function sw(e) { return null !== e } const lw = e => ({ name: "transformOrigin", options: e, fn(t) { var n, r, i, o, a; const { placement: s, rects: l, middlewareData: c } = t, u = 0 !== (null === (n = c.arrow) || void 0 === n ? void 0 : n.centerOffset), d = u ? 0 : e.arrowWidth, p = u ? 0 : e.arrowHeight, [h, f] = cw(s), m = { start: "0%", center: "50%", end: "100%" }[f], g = (null !== (r = null === (i = c.arrow) || void 0 === i ? void 0 : i.x) && void 0 !== r ? r : 0) + d / 2, v = (null !== (o = null === (a = c.arrow) || void 0 === a ? void 0 : a.y) && void 0 !== o ? o : 0) + p / 2; let y = "", b = ""; return "bottom" === h ? (y = u ? m : `${g}px`, b = -p + "px") : "top" === h ? (y = u ? m : `${g}px`, b = `${l.floating.height + p}px`) : "right" === h ? (y = -p + "px", b = u ? m : `${v}px`) : "left" === h && (y = `${l.floating.width + p}px`, b = u ? m : `${v}px`), { data: { x: y, y: b } } } }); function cw(e) { const [t, n = "center"] = e.split("-"); return [t, n] } const uw = e => { const { __scopePopper: t, children: n } = e, [r, i] = (0, A.useState)(null); return (0, A.createElement)(ew, { scope: t, anchor: r, onAnchorChange: i }, n) }, dw = nw, pw = aw; const hw = "Popover", [fw, mw] = Nf(hw, [$b]), gw = $b(), [vw, yw] = fw(hw), bw = (0, A.forwardRef)(((e, t) => { const { __scopePopover: n, ...r } = e, i = yw("PopoverAnchor", n), o = gw(n), { onCustomAnchorAdd: a, onCustomAnchorRemove: s } = i; return (0, A.useEffect)((() => (a(), () => s())), [a, s]), (0, A.createElement)(dw, bo({}, o, r, { ref: t })) })), ww = (0, A.forwardRef)(((e, t) => { const { __scopePopover: n, ...r } = e, i = yw("PopoverTrigger", n), o = gw(n), a = Hf(t, i.triggerRef), s = (0, A.createElement)(Gf.button, bo({ type: "button", "aria-haspopup": "dialog", "aria-expanded": i.open, "aria-controls": i.contentId, "data-state": Pw(i.open) }, r, { ref: a, onClick: Ff(e.onClick, i.onOpenToggle) })); return i.hasCustomAnchor ? s : (0, A.createElement)(dw, bo({ asChild: !0 }, o), s) })), [Ew, Cw] = fw("PopoverPortal", { forceMount: void 0 }), Sw = "PopoverContent", kw = (0, A.forwardRef)(((e, t) => { const n = Cw(Sw, e.__scopePopover), { forceMount: r = n.forceMount, ...i } = e, o = yw(Sw, e.__scopePopover); return (0, A.createElement)(Kg, { present: r || o.open }, o.modal ? (0, A.createElement)(xw, bo({}, i, { ref: t })) : (0, A.createElement)(Aw, bo({}, i, { ref: t }))) })), xw = (0, A.forwardRef)(((e, t) => { const n = yw(Sw, e.__scopePopover), r = (0, A.useRef)(null), i = Hf(t, r), o = (0, A.useRef)(!1); return (0, A.useEffect)((() => { const e = r.current; if (e) return ql(e) }), []), (0, A.createElement)(Cy, { as: Uf, allowPinchZoom: !0 }, (0, A.createElement)(Iw, bo({}, e, { ref: i, trapFocus: n.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: Ff(e.onCloseAutoFocus, (e => { var t; e.preventDefault(), o.current || null === (t = n.triggerRef.current) || void 0 === t || t.focus() })), onPointerDownOutside: Ff(e.onPointerDownOutside, (e => { const t = e.detail.originalEvent, n = 0 === t.button && !0 === t.ctrlKey, r = 2 === t.button || n; o.current = r }), { checkForDefaultPrevented: !1 }), onFocusOutside: Ff(e.onFocusOutside, (e => e.preventDefault()), { checkForDefaultPrevented: !1 }) }))) })), Aw = (0, A.forwardRef)(((e, t) => { const n = yw(Sw, e.__scopePopover), r = (0, A.useRef)(!1), i = (0, A.useRef)(!1); return (0, A.createElement)(Iw, bo({}, e, { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: t => { var o, a; null === (o = e.onCloseAutoFocus) || void 0 === o || o.call(e, t), t.defaultPrevented || (r.current || null === (a = n.triggerRef.current) || void 0 === a || a.focus(), t.preventDefault()), r.current = !1, i.current = !1 }, onInteractOutside: t => { var o, a; null === (o = e.onInteractOutside) || void 0 === o || o.call(e, t), t.defaultPrevented || (r.current = !0, "pointerdown" === t.detail.originalEvent.type && (i.current = !0)); const s = t.target; (null === (a = n.triggerRef.current) || void 0 === a ? void 0 : a.contains(s)) && t.preventDefault(), "focusin" === t.detail.originalEvent.type && i.current && t.preventDefault() } })) })), Iw = (0, A.forwardRef)(((e, t) => { const { __scopePopover: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: o, disableOutsidePointerEvents: a, onEscapeKeyDown: s, onPointerDownOutside: l, onFocusOutside: c, onInteractOutside: u, ...d } = e, p = yw(Sw, n), h = gw(n); return ny(), (0, A.createElement)(Xv, { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: i, onUnmountAutoFocus: o }, (0, A.createElement)(qf, { asChild: !0, disableOutsidePointerEvents: a, onInteractOutside: u, onEscapeKeyDown: s, onPointerDownOutside: l, onFocusOutside: c, onDismiss: () => p.onOpenChange(!1) }, (0, A.createElement)(pw, bo({ "data-state": Pw(p.open), role: "dialog", id: p.contentId }, h, d, { ref: t, style: { ...d.style, "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-popover-content-available-width": "var(--radix-popper-available-width)", "--radix-popover-content-available-height": "var(--radix-popper-available-height)", "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)", "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)" } })))) })); function Pw(e) { return e ? "open" : "closed" } const Mw = e => { const { __scopePopover: t, children: n, open: r, defaultOpen: i, onOpenChange: o, modal: a = !1 } = e, s = gw(t), l = (0, A.useRef)(null), [c, u] = (0, A.useState)(!1), [d = !1, p] = function ({ prop: e, defaultProp: t, onChange: n = (() => { }) }) { const [r, i] = function ({ defaultProp: e, onChange: t }) { const n = (0, A.useState)(e), [r] = n, i = (0, A.useRef)(r), o = Qb(t); return (0, A.useEffect)((() => { i.current !== r && (o(r), i.current = r) }), [r, i, o]), n }({ defaultProp: t, onChange: n }), o = void 0 !== e, a = o ? e : r, s = Qb(n); return [a, (0, A.useCallback)((t => { if (o) { const n = "function" == typeof t ? t(e) : t; n !== e && s(n) } else i(t) }), [o, e, i, s])] }({ prop: r, defaultProp: i, onChange: o }); return (0, A.createElement)(uw, s, (0, A.createElement)(vw, { scope: t, contentId: rm(), triggerRef: l, open: d, onOpenChange: p, onOpenToggle: (0, A.useCallback)((() => p((e => !e))), [p]), hasCustomAnchor: c, onCustomAnchorAdd: (0, A.useCallback)((() => u(!0)), []), onCustomAnchorRemove: (0, A.useCallback)((() => u(!1)), []), modal: a }, n)) }, Tw = bw, Rw = ww, Bw = kw, Dw = (() => { if ("undefined" == typeof self) return !1; if ("top" in self && self !== top) try { top } catch (e) { return !1 } else if ("showOpenFilePicker" in self) return "showOpenFilePicker"; return !1 })(), Lw = Dw ? Promise.resolve().then((function () { return Vw })) : Promise.resolve().then((function () { return Qw })); async function Ow(...e) { return (await Lw).default(...e) } const Fw = Dw ? Promise.resolve().then((function () { return Gw })) : Promise.resolve().then((function () { return Jw })); async function zw(...e) { return (await Fw).default(...e) } const Hw = Dw ? Promise.resolve().then((function () { return Xw })) : Promise.resolve().then((function () { return eE })); async function Nw(...e) { return (await Hw).default(...e) } const jw = async e => { const t = await e.getFile(); return t.handle = e, t }; var Uw = async (e = [{}]) => { Array.isArray(e) || (e = [e]); const t = []; e.forEach(((e, n) => { t[n] = { description: e.description || "Files", accept: {} }, e.mimeTypes ? e.mimeTypes.map((r => { t[n].accept[r] = e.extensions || [] })) : t[n].accept["*/*"] = e.extensions || [] })); const n = await window.showOpenFilePicker({ id: e[0].id, startIn: e[0].startIn, types: t, multiple: e[0].multiple || !1, excludeAcceptAllOption: e[0].excludeAcceptAllOption || !1 }), r = await Promise.all(n.map(jw)); return e[0].multiple ? r : r[0] }, Vw = { __proto__: null, default: Uw }; function Kw(e) { function t(e) { if (Object(e) !== e) return Promise.reject(new TypeError(e + " is not an object.")); var t = e.done; return Promise.resolve(e.value).then((function (e) { return { value: e, done: t } })) } return Kw = function (e) { this.s = e, this.n = e.next }, Kw.prototype = { s: null, n: null, next: function () { return t(this.n.apply(this.s, arguments)) }, return: function (e) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: e, done: !0 }) : t(n.apply(this.s, arguments)) }, throw: function (e) { var n = this.s.return; return void 0 === n ? Promise.reject(e) : t(n.apply(this.s, arguments)) } }, new Kw(e) } const Ww = async (e, t, n = e.name, r) => { const i = [], o = []; var a, s = !1, l = !1; try { for (var c, u = function (e) { var t, n, r, i = 2; for ("undefined" != typeof Symbol && (n = Symbol.asyncIterator, r = Symbol.iterator); i--;) { if (n && null != (t = e[n])) return t.call(e); if (r && null != (t = e[r])) return new Kw(t.call(e)); n = "@@asyncIterator", r = "@@iterator" } throw new TypeError("Object is not async iterable") }(e.values()); s = !(c = await u.next()).done; s = !1) { const a = c.value, s = `${n}/${a.name}`; "file" === a.kind ? o.push(a.getFile().then((t => (t.directoryHandle = e, t.handle = a, Object.defineProperty(t, "webkitRelativePath", { configurable: !0, enumerable: !0, get: () => s }))))) : "directory" !== a.kind || !t || r && r(a) || i.push(Ww(a, t, s, r)) } } catch (e) { l = !0, a = e } finally { try { s && null != u.return && await u.return() } finally { if (l) throw a } } return [...(await Promise.all(i)).flat(), ...await Promise.all(o)] }; var Yw = async (e = {}) => { e.recursive = e.recursive || !1, e.mode = e.mode || "read"; const t = await window.showDirectoryPicker({ id: e.id, startIn: e.startIn, mode: e.mode }); return Ww(t, e.recursive, void 0, e.skipDirectory) }, Gw = { __proto__: null, default: Yw }, Zw = async (e, t = [{}], n = null, r = !1, i = null) => { Array.isArray(t) || (t = [t]), t[0].fileName = t[0].fileName || "Untitled"; const o = []; let a = null; if (e instanceof Blob && e.type ? a = e.type : e.headers && e.headers.get("content-type") && (a = e.headers.get("content-type")), t.forEach(((e, t) => { o[t] = { description: e.description || "Files", accept: {} }, e.mimeTypes ? (0 === t && a && e.mimeTypes.push(a), e.mimeTypes.map((n => { o[t].accept[n] = e.extensions || [] }))) : a ? o[t].accept[a] = e.extensions || [] : o[t].accept["*/*"] = e.extensions || [] })), n) try { await n.getFile() } catch (e) { if (n = null, r) throw e } const s = n || await window.showSaveFilePicker({ suggestedName: t[0].fileName, id: t[0].id, startIn: t[0].startIn, types: o, excludeAcceptAllOption: t[0].excludeAcceptAllOption || !1 }); !n && i && i(s); const l = await s.createWritable(); if ("stream" in e) { const t = e.stream(); return await t.pipeTo(l), s } return "body" in e ? (await e.body.pipeTo(l), s) : (await l.write(await e), await l.close(), s) }, Xw = { __proto__: null, default: Zw }, _w = async (e = [{}]) => (Array.isArray(e) || (e = [e]), new Promise(((t, n) => { const r = document.createElement("input"); r.type = "file"; const i = [...e.map((e => e.mimeTypes || [])), ...e.map((e => e.extensions || []))].join(); r.multiple = e[0].multiple || !1, r.accept = i || "", r.style.display = "none", document.body.append(r); const o = e => { "function" == typeof a && a(), t(e) }, a = e[0].legacySetup && e[0].legacySetup(o, (() => a(n)), r), s = () => { window.removeEventListener("focus", s), r.remove() }; r.addEventListener("click", (() => { window.addEventListener("focus", s) })), r.addEventListener("change", (() => { window.removeEventListener("focus", s), r.remove(), o(r.multiple ? Array.from(r.files) : r.files[0]) })), "showPicker" in HTMLInputElement.prototype ? r.showPicker() : r.click() }))), Qw = { __proto__: null, default: _w }, qw = async (e = [{}]) => (Array.isArray(e) || (e = [e]), e[0].recursive = e[0].recursive || !1, new Promise(((t, n) => { const r = document.createElement("input"); r.type = "file", r.webkitdirectory = !0; const i = e => { "function" == typeof o && o(), t(e) }, o = e[0].legacySetup && e[0].legacySetup(i, (() => o(n)), r); r.addEventListener("change", (() => { let t = Array.from(r.files); e[0].recursive ? e[0].recursive && e[0].skipDirectory && (t = t.filter((t => t.webkitRelativePath.split("/").every((t => !e[0].skipDirectory({ name: t, kind: "directory" })))))) : t = t.filter((e => 2 === e.webkitRelativePath.split("/").length)), i(t) })), "showPicker" in HTMLInputElement.prototype ? r.showPicker() : r.click() }))), Jw = { __proto__: null, default: qw }, $w = async (e, t = {}) => { Array.isArray(t) && (t = t[0]); const n = document.createElement("a"); let r = e; "body" in e && (r = await async function (e, t) { const n = e.getReader(), r = new ReadableStream({ start: e => async function t() { return n.read().then((({ done: n, value: r }) => { if (!n) return e.enqueue(r), t(); e.close() })) }() }), i = new Response(r), o = await i.blob(); return n.releaseLock(), new Blob([o], { type: t }) }(e.body, e.headers.get("content-type"))), n.download = t.fileName || "Untitled", n.href = URL.createObjectURL(await r); const i = () => { "function" == typeof o && o() }, o = t.legacySetup && t.legacySetup(i, (() => o()), n); return n.addEventListener("click", (() => { setTimeout((() => URL.revokeObjectURL(n.href)), 3e4), i() })), n.click(), null }, eE = { __proto__: null, default: $w }; function tE(e) { return new Promise(((t, n) => { e.oncomplete = e.onsuccess = () => t(e.result), e.onabort = e.onerror = () => n(e.error) })) } let nE; function rE() { return nE || (nE = function (e, t) { const n = indexedDB.open("keyval-store"); n.onupgradeneeded = () => n.result.createObjectStore(t); const r = tE(n); return (e, n) => r.then((r => n(r.transaction(t, e).objectStore(t)))) }(0, "keyval")), nE } function iE(e, t = rE()) { return t("readonly", (t => tE(t.get(e)))) } function oE(e, t, n = rE()) { return n("readwrite", (n => (n.put(t, e), tE(n.transaction)))) } const aE = e => { let t; const n = new Set, r = (e, r) => { const i = "function" == typeof e ? e(t) : e; if (!Object.is(i, t)) { const e = t; t = (null != r ? r : "object" != typeof i) ? i : Object.assign({}, t, i), n.forEach((n => n(t, e))) } }, i = () => t, o = { setState: r, getState: i, subscribe: e => (n.add(e), () => n.delete(e)), destroy: () => { console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear() } }; return t = e(r, i, o), o }, sE = e => e ? aE(e) : aE; var lE = n(2798); const { useSyncExternalStoreWithSelector: cE } = lE; let uE = !1; const dE = e => { "function" != typeof e && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."); const t = "function" == typeof e ? sE(e) : e, n = (e, n) => function (e, t = e.getState, n) { n && !uE && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), uE = !0); const r = cE(e.subscribe, e.getState, e.getServerState || e.getState, t, n); return (0, A.useDebugValue)(r), r }(t, e, n); return Object.assign(n, t), n }; var pE = Object.defineProperty, hE = Object.defineProperties, fE = Object.getOwnPropertyDescriptor, mE = Object.getOwnPropertyDescriptors, gE = Object.getOwnPropertyNames, vE = Object.getOwnPropertySymbols, yE = Object.prototype.hasOwnProperty, bE = Object.prototype.propertyIsEnumerable, wE = (e, t, n) => t in e ? pE(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, EE = (e, t) => { for (var n in t || (t = {})) yE.call(t, n) && wE(e, n, t[n]); if (vE) for (var n of vE(t)) bE.call(t, n) && wE(e, n, t[n]); return e }, CE = (e, t) => hE(e, mE(t)), SE = (e, t) => { var n = {}; for (var r in e) yE.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && vE) for (var r of vE(e)) t.indexOf(r) < 0 && bE.call(e, r) && (n[r] = e[r]); return n }, kE = (e, t, n) => (wE(e, "symbol" != typeof t ? t + "" : t, n), n), xE = (e, t, n) => new Promise(((r, i) => { var o = e => { try { s(n.next(e)) } catch (e) { i(e) } }, a = e => { try { s(n.throw(e)) } catch (e) { i(e) } }, s = e => e.done ? r(e.value) : Promise.resolve(e.value).then(o, a); s((n = n.apply(e, t)).next()) })), { styled: AE, createTheme: IE } = _h({ themeMap: EE({}, ih), theme: { colors: { bounds: "rgba(65, 132, 244, 1.000)", boundsBg: "rgba(65, 132, 244, 0.05)", hover: "#ececec", overlay: "rgba(0, 0, 0, 0.15)", overlayContrast: "rgba(255, 255, 255, 0.15)", panel: "#fefefe", panelContrast: "#ffffff", selected: "rgba(66, 133, 244, 1.000)", selectedContrast: "#fefefe", text: "#333333", tooltip: "#1d1d1d", tooltipContrast: "#ffffff", warn: "rgba(255, 100, 100, 1)", canvas: "rgb(248, 249, 250)" }, shadows: { 2: "0px 1px 1px rgba(0, 0, 0, 0.14)", 3: "0px 2px 3px rgba(0, 0, 0, 0.14)", 4: "0px 4px 5px -1px rgba(0, 0, 0, 0.14)", 8: "0px 12px 17px rgba(0, 0, 0, 0.14)", 12: "0px 12px 17px rgba(0, 0, 0, 0.14)", 24: "0px 24px 38px rgba(0, 0, 0, 0.14)", key: "1px 1px rgba(0,0,0,1)", panel: "0px 0px 16px -1px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -8px rgba(0, 0, 0, 0.05), \n        0px 0px 16px -12px rgba(0, 0, 0, 0.12),\n        0px 0px 2px 0px rgba(0, 0, 0, 0.08)" }, space: { 0: "2px", 1: "3px", 2: "4px", 3: "8px", 4: "12px", 5: "16px", 6: "32px", 7: "48px" }, fontSizes: { 0: "10px", 1: "12px", 2: "13px", 3: "16px", 4: "18px" }, fonts: { ui: '"Recursive", system-ui, sans-serif', body: '"Recursive", system-ui, sans-serif', mono: '"Recursive Mono", monospace' }, fontWeights: {}, lineHeights: {}, letterSpacings: {}, sizes: {}, borderWidths: { 0: "$1" }, borderStyles: {}, radii: { 0: "2px", 1: "4px", 2: "8px", 3: "12px", 4: "16px" }, zIndices: {}, transitions: {} }, media: { micro: "(max-width: 370px)", sm: "(min-width: 640px)", md: "(min-width: 768px)", lg: "(min-width: 1024px)" }, utils: { zStrokeWidth: () => e => Array.isArray(e) ? { strokeWidth: `calc(${e[0]}px / var(--camera-zoom))` } : { strokeWidth: `calc(${e}px / var(--camera-zoom))` } } }), PE = IE({ colors: { bounds: "rgba(38, 150, 255, 1.000)", boundsBg: "rgba(38, 150, 255, 0.05)", hover: "#444A50", overlay: "rgba(0, 0, 0, 0.15)", overlayContrast: "rgba(255, 255, 255, 0.15)", panel: "#363D44", panelContrast: "#49555f", selected: "rgba(38, 150, 255, 1.000)", selectedContrast: "#fefefe", text: "#f8f9fa", tooltip: "#1d1d1d", tooltipContrast: "#ffffff", canvas: "#212529" }, shadows: { 2: "0px 1px 1px rgba(0, 0, 0, 0.24)", 3: "0px 2px 3px rgba(0, 0, 0, 0.24)", 4: "0px 4px 5px -1px rgba(0, 0, 0, 0.24)", 8: "0px 12px 17px rgba(0, 0, 0, 0.24)", 12: "0px 12px 17px rgba(0, 0, 0, 0.24)", 24: "0px 24px 38px rgba(0, 0, 0, 0.24)", panel: "0px 0px 16px -1px rgba(0, 0, 0, 0.05), \n      0px 0px 16px -8px rgba(0, 0, 0, 0.09), \n      0px 0px 16px -12px rgba(0, 0, 0, 0.2)" } }), ME = AE("hr", { height: 0, paddingTop: 1, width: "calc(100%+8px)", backgroundColor: "$hover", border: "none", margin: "$2 -4px" }), TE = AE("div", { position: "relative", overflow: "hidden", userSelect: "none", WebkitUserSelect: "none", display: "flex", flexDirection: "column", zIndex: 99997, minWidth: 180, pointerEvents: "all", backgroundColor: "$panel", border: "1px solid $panelContrast", boxShadow: "$panel", padding: "$2 $2", borderRadius: "$3", font: "$ui", maxHeight: "100vh", overflowY: "auto", overflowX: "hidden", "&::webkit-scrollbar": { display: "none" }, "-ms-overflow-style": "none", scrollbarWidth: "none", variants: { size: { small: { minWidth: 72 } }, overflow: { true: { maxHeight: "60vh" } } } }), RE = () => Zt.isDarwin() ? "" : "Ctrl"; function BE({ variant: e, children: t }) { return A.createElement(DE, { variant: e }, t.split("").map(((e, t) => A.createElement("span", { key: t }, e.replace("#", RE()))))) } var DE = AE("kbd", { marginLeft: "$3", textShadow: "$2", textAlign: "center", fontSize: "$0", fontFamily: "$ui", color: "$text", background: "none", fontWeight: 400, gap: "$1", display: "flex", alignItems: "center", "& > span": { padding: "$0", borderRadius: "$0", display: "flex", alignItems: "center", justifyContent: "center" }, variants: { variant: { tooltip: { "& > span": { color: "$tooltipContrast", background: "$overlayContrast", boxShadow: "$key", width: "20px", height: "20px" } }, menu: {} } } }), LE = AE("div", { height: "100%", borderRadius: "4px", marginRight: "1px", width: "fit-content", display: "grid", alignItems: "center", justifyContent: "center", outline: "none", border: "none", pointerEvents: "all", cursor: "pointer", color: "currentColor", "& svg": { height: 16, width: 16, strokeWidth: 1 }, "& > *": { gridRow: 1, gridColumn: 1 } }), OE = { "@initial": "mobile", "@micro": "micro", "@sm": "small", "@md": "medium", "@lg": "large" }, FE = A.forwardRef(((e, t) => { var n = e, { onClick: r, isActive: i = !1, isWarning: o = !1, hasIndicator: a = !1, hasArrow: s = !1, disabled: l = !1, variant: c, kbd: u, children: d } = n, p = SE(n, ["onClick", "isActive", "isWarning", "hasIndicator", "hasArrow", "disabled", "variant", "kbd", "children"]); return A.createElement(HE, EE({ ref: t, bp: OE, isWarning: o, isActive: i, disabled: l, onClick: r, variant: c }, p), A.createElement(zE, null, d, u ? A.createElement(BE, { variant: "menu" }, u) : void 0, a && A.createElement(Tf, { dir: "ltr" }, A.createElement(LE, null, A.createElement(Rd, null))), s && A.createElement(LE, null, A.createElement(Dd, null)))) })), zE = AE("div", { height: "100%", width: "100%", backgroundColor: "$panel", borderRadius: "$2", display: "flex", gap: "$1", flexDirection: "row", alignItems: "center", padding: "0 $3", justifyContent: "space-between", border: "1px solid transparent", "& svg": { position: "relative", stroke: "$overlay", strokeWidth: 1, zIndex: 1 }, [`& > ${LE}`]: { paddingLeft: "$3" } }), HE = AE("button", { position: "relative", width: "100%", background: "none", border: "none", cursor: "pointer", height: 32, minHeight: 32, outline: "none", color: "$text", fontFamily: "$ui", fontWeight: 400, fontSize: "$1", borderRadius: 4, userSelect: "none", WebkitUserSelect: "none", margin: 0, padding: "0 0", "&[data-disabled]": { opacity: .3 }, "&:disabled": { opacity: .3 }, [`&:focus:not(:disabled) ${zE}`]: { backgroundColor: "$hover" }, "& a": { textDecoration: "none", color: "$text" }, variants: { bp: { mobile: {}, small: {} }, variant: { styleMenu: { margin: "$1 0 $1 0" }, wide: { gridColumn: "1 / span 4" } }, size: { icon: { padding: "4px ", width: "auto" } }, isWarning: { true: { color: "$warn" } }, isActive: { true: { backgroundColor: "$hover" }, false: {} } } }); function NE({ children: e, label: t, kbd: n, id: r, side: i = "top" }) { return A.createElement("span", { id: r }, A.createElement(pv, null, A.createElement(hv, null, A.createElement(fv, { dir: "ltr", asChild: !0 }, A.createElement("span", null, e)), A.createElement(jE, { dir: "ltr", side: i, sideOffset: 8 }, t, n ? A.createElement(BE, { variant: "tooltip" }, n) : null, A.createElement(UE, null))))) } var jE = AE(mv, { borderRadius: 3, padding: "$3 $3 $3 $3", fontSize: "$1", backgroundColor: "$tooltip", color: "$tooltipContrast", boxShadow: "$3", display: "flex", alignItems: "center", fontFamily: "$ui", userSelect: "none", WebkitUserSelect: "none" }), UE = AE(gv, { fill: "$tooltip", margin: "0 8px" }); function VE() { let e = A.useCallback(((e, t) => xE(this, null, (function* () { t(e.fileSystemHandle ? "saveFirstTime" : "saveAgain", (() => xE(this, null, (function* () { try { yield e.saveProject(), e.newProject() } catch (e) { } }))), (() => xE(this, null, (function* () { e.newProject() }))), (() => xE(this, null, (function* () { })))) }))), []), t = A.useCallback(((e, t) => xE(this, null, (function* () { t(e.fileSystemHandle ? "saveFirstTime" : "saveAgain", (() => xE(this, null, (function* () { try { yield e.saveProject(), yield e.openProject() } catch (e) { } }))), (() => xE(this, null, (function* () { e.openProject() }))), (() => xE(this, null, (function* () { })))) }))), []), n = A.useCallback((e => { e.saveProject() }), []), r = A.useCallback((e => { e.saveProjectAs() }), []), i = A.useCallback((e => xE(this, null, (function* () { var t; null == (t = e.openAsset) || t.call(e) }))), []); return { onNewProject: e, onSaveProject: n, onSaveProjectAs: r, onOpenProject: t, onOpenMedia: i } } function KE() { let e = pC(), { openDialog: t } = yC(), n = A.useCallback((n => xE(this, null, (function* () { var r, i; n && e.callbacks.onOpenProject && n.preventDefault(), null == (i = (r = e.callbacks).onNewProject) || i.call(r, e, t) }))), [e, t]), r = A.useCallback((t => { var n, r; t && e.callbacks.onOpenProject && t.preventDefault(), null == (r = (n = e.callbacks).onSaveProject) || r.call(n, e) }), [e]), i = A.useCallback((t => { var n, r; t && e.callbacks.onOpenProject && t.preventDefault(), null == (r = (n = e.callbacks).onSaveProjectAs) || r.call(n, e) }), [e]), o = A.useCallback((n => xE(this, null, (function* () { var r, i; n && e.callbacks.onOpenProject && n.preventDefault(), null == (i = (r = e.callbacks).onOpenProject) || i.call(r, e, t) }))), [e, t]), a = A.useCallback((t => xE(this, null, (function* () { var n, r; t && e.callbacks.onOpenMedia && t.preventDefault(), null == (r = (n = e.callbacks).onOpenMedia) || r.call(n, e) }))), [e]); return { onNewProject: n, onSaveProject: r, onSaveProjectAs: i, onOpenProject: o, onOpenMedia: a } } var WE = class { constructor() { kE(this, "onPinchStart"), kE(this, "onPinchEnd"), kE(this, "onPinch"), kE(this, "onKeyDown"), kE(this, "onKeyUp"), kE(this, "onPointerMove"), kE(this, "onPointerUp"), kE(this, "onPan"), kE(this, "onZoom"), kE(this, "onPointerDown"), kE(this, "onPointCanvas"), kE(this, "onDoubleClickCanvas"), kE(this, "onRightPointCanvas"), kE(this, "onDragCanvas"), kE(this, "onReleaseCanvas"), kE(this, "onPointShape"), kE(this, "onDoubleClickShape"), kE(this, "onRightPointShape"), kE(this, "onDragShape"), kE(this, "onHoverShape"), kE(this, "onUnhoverShape"), kE(this, "onReleaseShape"), kE(this, "onPointBounds"), kE(this, "onDoubleClickBounds"), kE(this, "onRightPointBounds"), kE(this, "onDragBounds"), kE(this, "onHoverBounds"), kE(this, "onUnhoverBounds"), kE(this, "onReleaseBounds"), kE(this, "onPointBoundsHandle"), kE(this, "onDoubleClickBoundsHandle"), kE(this, "onRightPointBoundsHandle"), kE(this, "onDragBoundsHandle"), kE(this, "onHoverBoundsHandle"), kE(this, "onUnhoverBoundsHandle"), kE(this, "onReleaseBoundsHandle"), kE(this, "onPointHandle"), kE(this, "onDoubleClickHandle"), kE(this, "onRightPointHandle"), kE(this, "onDragHandle"), kE(this, "onHoverHandle"), kE(this, "onUnhoverHandle"), kE(this, "onReleaseHandle"), kE(this, "onShapeBlur"), kE(this, "onShapeClone") } }, YE = (e => (e.Idle = "idle", e.Connecting = "connecting", e.Connected = "connected", e.Disconnected = "disconnected", e))(YE || {}), GE = (e => (e.Transform = "transform", e.Translate = "translate", e.TransformSingle = "transformSingle", e.Brush = "brush", e.Arrow = "arrow", e.Draw = "draw", e.Erase = "erase", e.Rotate = "rotate", e.Handle = "handle", e.Grid = "grid", e.Edit = "edit", e))(GE || {}), ZE = (e => (e.Idle = "idle", e.PointingHandle = "pointingHandle", e.PointingBounds = "pointingBounds", e.PointingBoundsHandle = "pointingBoundsHandle", e.TranslatingLabel = "translatingLabel", e.TranslatingHandle = "translatingHandle", e.Translating = "translating", e.Transforming = "transforming", e.Rotating = "rotating", e.Pinching = "pinching", e.Brushing = "brushing", e.Creating = "creating", e.EditingText = "editing-text", e))(ZE || {}), XE = (e => (e.Backward = "backward", e.Forward = "forward", e.ToFront = "toFront", e.ToBack = "toBack", e))(XE || {}), _E = (e => (e.Top = "top", e.CenterVertical = "centerVertical", e.Bottom = "bottom", e.Left = "left", e.CenterHorizontal = "centerHorizontal", e.Right = "right", e))(_E || {}), QE = (e => (e.Horizontal = "horizontal", e.Vertical = "vertical", e))(QE || {}), qE = (e => (e.Horizontal = "horizontal", e.Vertical = "vertical", e))(qE || {}), JE = (e => (e.Horizontal = "horizontal", e.Vertical = "vertical", e))(JE || {}), $E = (e => (e.Sticky = "sticky", e.Ellipse = "ellipse", e.Rectangle = "rectangle", e.Triangle = "triangle", e.Draw = "draw", e.Arrow = "arrow", e.Line = "line", e.Text = "text", e.Group = "group", e.Image = "image", e.Video = "video", e))($E || {}), eC = (e => (e.Arrow = "arrow", e))(eC || {}), tC = (e => (e.White = "white", e.LightGray = "lightGray", e.Gray = "gray", e.Black = "black", e.Green = "green", e.Cyan = "cyan", e.Blue = "blue", e.Indigo = "indigo", e.Violet = "violet", e.Red = "red", e.Orange = "orange", e.Yellow = "yellow", e))(tC || {}), nC = (e => (e.Small = "small", e.Medium = "medium", e.Large = "large", e))(nC || {}), rC = (e => (e.Draw = "draw", e.Solid = "solid", e.Dashed = "dashed", e.Dotted = "dotted", e))(rC || {}), iC = (e => (e.Small = "small", e.Medium = "medium", e.Large = "large", e.ExtraLarge = "extraLarge", e))(iC || {}), oC = (e => (e.Start = "start", e.Middle = "middle", e.End = "end", e.Justify = "justify", e))(oC || {}), aC = (e => (e.Script = "script", e.Sans = "sans", e.Serif = "serif", e.Mono = "mono", e))(aC || {}), sC = (e => (e.Image = "image", e.Video = "video", e))(sC || {}), lC = (e => (e.PNG = "png", e.JPG = "jpeg", e.WEBP = "webp", e.SVG = "svg", e.JSON = "json", e))(lC || {}), cC = (e => (e.Transparent = "transparent", e.Auto = "auto", e.Light = "light", e.Dark = "dark", e))(cC || {}), uC = A.createContext({}), dC = () => { let [e, t] = A.useState(0); A.useEffect((() => t(1))) }; function pC() { return A.useContext(uC) } var hC = A.createContext({}); function fC() { let e = A.useContext(hC); return dC(), e } var mC = { "style.menu.color": "Color", "style.menu.fill": "Fill", "style.menu.dash": "Dash", "style.menu.size": "Size", "style.menu.keep.open": "Keep Open", "style.menu.font": "Font", "style.menu.align": "Align", styles: "Styles", "zoom.in": "Zoom In", "zoom.out": "Zoom Out", to: "To", "menu.tools": "Tools", "menu.transform": "Transform", "menu.file": "File", "menu.edit": "Edit", "menu.view": "View", "menu.preferences": "Preferences", "menu.sign.in": "Sign In", "menu.sign.out": "Sign Out", "become.a.sponsor": "Become a Sponsor", "zoom.to.content": "Back to content", "zoom.to.selection": "Zoom to Selection", "zoom.to.fit": "Zoom to Fit", "zoom.to": "Zoom to", "preferences.dark.mode": "Dark Mode", "preferences.focus.mode": "Focus Mode", "preferences.debug.mode": "Debug Mode", "preferences.show.grid": "Show Grid", "preferences.use.cad.selection": "Use CAD Selection", "preferences.keep.stylemenu.open": "Keep Style Menu Open", "preferences.always.show.snaps": "Always Show Snaps", "preferences.rotate.handles": "Rotate Handles", "preferences.binding.handles": "Binding Handles", "preferences.clone.handles": "Clone Handles", undo: "Undo", redo: "Redo", cut: "Cut", copy: "Copy", paste: "Paste", "copy.as": "Copy As", "export.as": "Export As", "select.all": "Select All", "select.none": "Select None", delete: "Delete", "new.project": "New Project", open: "Open", save: "Save", "save.as": "Save As", "upload.media": "Upload Media", "create.page": "Create Page", "new.page": "New Page", "page.name": "Page Name", duplicate: "Duplicate", "shape.options": "Shape Options", shapes: "Shapes", cancel: "Cancel", "copy.invite.link": "Copy Invite Link", "copy.readonly.link": "Copy ReadOnly Link", "create.multiplayer.project": "Create a Multiplayer Project", "copy.multiplayer.project": "Copy to Multiplayer Project", select: "Select", eraser: "Eraser", draw: "Draw", arrow: "Arrow", text: "Text", sticky: "Sticky", rectangle: "Rectangle", ellipse: "Ellipse", triangle: "Triangle", line: "Line", rotate: "Rotate", "lock.aspect.ratio": "Lock Aspect Ratio", "unlock.aspect.ratio": "Unlock Aspect Ratio", group: "Group", ungroup: "Ungroup", "move.to.back": "Move to Back", "move.backward": "Move Backward", "move.forward": "Move Forward", "move.to.front": "Move to Front", "reset.angle": "Reset Angle", lock: "Lock", unlock: "Unlock", "align.distribute": "Align / Distribute", "move.to.page": "Move to Page", "flip.horizontal": "Flip Horizontal", "flip.vertical": "Flip Vertical", move: "Move", "to.front": "To Front", forward: "Forward", backward: "Backward", back: "To Back", language: "Language", "translation.link": "Learn More", "dock.position": "Dock Position", bottom: "Bottom", left: "Left", right: "Right", top: "Top", page: "Page", "keyboard.shortcuts": "Keyboard shortcuts", search: "Search", loading: "Loading{dots}", "export.background": "Export Background", transparent: "Transparent", auto: "Auto", light: "Light", dark: "Dark", github: "Github", twitter: "Twitter", discord: "Discord", image: "Image", "align.left": "Align Left", "align.center.x": "Align Horizontal Center", "align.right": "Align Right", "align.top": "Align Top", "align.center.y": "Align Vertical Center", "align.bottom": "Align Bottom", "distribute.x": "Distribute Horizontal", "distribute.y": "Distribute Vertical", "stretch.x": "Stretch Horizontal", "stretch.y": "Stretch Vertical", "dialog.save.firsttime": "Do you want to save your current project?", "dialog.save.again": "Do you want to save changes to your current project?", "dialog.cancel": "Cancel", "dialog.no": "No", "dialog.yes": "Yes", "enter.file.name": "Enter file name", "tldraw-beta": "Try the new tldraw", white: "White", lightGray: "Light gray", gray: "Gray", black: "Black", green: "Green", cyan: "Cyan", blue: "Blue", indigo: "Indigo", violet: "Violet", red: "Red", orange: "Orange", yellow: "Yellow", solid: "Solid", dashed: "Dashed", dotted: "Dotted", small: "Small", medium: "Medium", large: "Large" }, gC = [{ locale: "ar", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": " ", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.content": "  ", "zoom.to.selection": " ", "zoom.to.fit": " ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": "  CAD", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "  ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": " ", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": "  ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "  ", "copy.readonly.link": "    ", "create.multiplayer.project": "    ", "copy.multiplayer.project": "    ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "  ", "unlock.aspect.ratio": "   ", group: "", ungroup: " ", "move.to.back": "  ", "move.backward": " ", "move.forward": " ", "move.to.front": " ", "reset.angle": "  ", lock: "", unlock: " ", "move.to.page": "  ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": "", forward: "", backward: "", back: "", language: "", "translation.link": "", "dock.position": " ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": "  ", search: "", loading: "{dots} ", "export.background": " ", transparent: "", auto: "", light: "", dark: "", "dialog.save.firsttime": "      ", "dialog.save.again": "      ", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "", "enter.file.name": "  ", image: "", "align.left": " ", "align.center.x": "   ", "align.right": " ", "align.top": " ", "align.center.y": "   ", "align.bottom": " ", "distribute.x": " ", "distribute.y": " ", "stretch.x": " ", "stretch.y": " " } }, { locale: "da", label: "Danish", messages: { "style.menu.color": "Farve", "style.menu.fill": "Fyld", "style.menu.dash": "Streg", "style.menu.size": "Strrelse", "style.menu.keep.open": "Hold ben", "style.menu.font": "Skrifttype", "style.menu.align": "Juster", styles: "Format", "zoom.in": "Zoom ind", "zoom.out": "Zoom ud", to: "til", "menu.tools": "Vrktjer", "menu.transform": "Transformer", "menu.file": "Fil", "menu.edit": "Rediger", "menu.view": "Vis", "menu.preferences": "Indstillinger", "menu.sign.in": "Log ind", "menu.sign.out": "Log ud", "become.a.sponsor": "Bliv sponsor", "zoom.to.selection": "Zoom til valgte", "zoom.to.fit": "Zoom til lrred", "zoom.to": "Zoom til", "zoom.to.content": "Zoom til indhold", "preferences.dark.mode": "Mrkt udseende", "preferences.focus.mode": "Fokus tilstand", "preferences.debug.mode": "Debug tilstand", "preferences.show.grid": "Vis net", "preferences.use.cad.selection": "Brug CAD udvlgelse", "preferences.keep.stylemenu.open": "Hold formatmenuen ben", "preferences.always.show.snaps": "Vis altid snaps", "preferences.rotate.handles": "Roteringshndtag", "preferences.binding.handles": "Bindingshndtag", "preferences.clone.handles": "Kloningshndtag", undo: "Fortryd", redo: "Gentag", cut: "Klip", copy: "Kopier", paste: "Indst", "copy.as": "Kopier som", "export.as": "Eksporter som", "select.all": "Vlg alt", "select.none": "Fravlg alt", delete: "Slet", "new.project": "Nyt projekt", open: "ben", save: "Gem", "save.as": "Gem som", "upload.media": "Upload medie", "create.page": "Opret side", "new.page": "Ny side", "page.name": "Sidenavn", duplicate: "Dupliker", cancel: "Fortryd", "copy.invite.link": "Kopier invitationslink", "create.multiplayer.project": "Opret multiplayer projekt", "copy.multiplayer.project": "Kopier til multiplayer projekt", select: "Vlg", eraser: "Viskelder", draw: "Tegn", arrow: "Pil", text: "Tekst", sticky: "Note", rectangle: "Rektangel", ellipse: "Ellipse", triangle: "Trekant", line: "Linje", rotate: "Roter", "lock.aspect.ratio": "Ls billedformat", "unlock.aspect.ratio": "Frigr billedformat", group: "Grupper", ungroup: "Opdel gruppe", "move.to.back": "Placer bagerst", "move.backward": "Flyt tilbage", "move.forward": "Flyt frem", "move.to.front": "Lg forrest", "reset.angle": "Nulstil vinkel", lock: "Ls", unlock: "Ls op", "move.to.page": "Flyt til side", "flip.horizontal": "Vend vandret", "flip.vertical": "Vend lodret", move: "Flyt", "to.front": "Forrest", forward: "Frem", backward: "Tilbage", back: "Bagerst", language: "Sprog", "align.bottom": "Justering nederst", "align.center.x": "Vandret justering centreret", "align.center.y": "Lodret justering centreret", "align.distribute": "Juster / distribuer", "align.left": "Justering til venstre", "align.right": "Justering til hjre", "align.top": "Justering verst", "copy.readonly.link": "Kopier skrivebeskyttet link", "dialog.save.again": "Vil du gemme ndringerne til dit projekt?", "dialog.save.firsttime": "Vil du gemme dit projekt?", "dialog.yes": "Ja", "dialog.no": "Nej", "dialog.cancel": "Fortryd", "enter.file.name": "Skriv filnavn", "distribute.x": "Vandret distribuering", "distribute.y": "Lodret distribuering", "dock.position": "Placering af vrktjslinje", bottom: "Nederst", left: "Venstre", right: "Hjre", top: "verst", "export.background": "Baggrund ved eksport", auto: "Automatisk", light: "Lys", dark: "Mrk", image: "Billede", "keyboard.shortcuts": "Tastaturgenveje", loading: "Indlser", page: "Side", search: "Sg", "stretch.x": "Strk vandret", "stretch.y": "Strk lodret", "translation.link": "Lr mere", transparent: "Gennemsigtig" } }, { locale: "de", label: "Deutsch", messages: { "style.menu.color": "Farbe", "style.menu.fill": "Fllen", "style.menu.dash": "Strich", "style.menu.size": "Gre", "style.menu.keep.open": "Offen halten", "style.menu.font": "Schriftart", "style.menu.align": "Ausrichten", styles: "Stile", "zoom.in": "Heranzoomen", "zoom.out": "Herauszoomen", to: "zu", "menu.tools": "Werkzeuge", "menu.transform": "Transformieren", "menu.file": "Datei", "menu.edit": "Bearbeiten", "menu.view": "Ansicht", "menu.preferences": "Prferenzen", "menu.sign.in": "Einloggen", "menu.sign.out": "Ausloggen", "become.a.sponsor": "Sponsor werden", "zoom.to.content": "Zurck zum Inhalt", "zoom.to.selection": "Zur Auswahl zoomen", "zoom.to.fit": "Zoom anpassen", "zoom.to": "Zoomen nach", "preferences.dark.mode": "Dunkler Modus", "preferences.focus.mode": "Fokus Modus", "preferences.debug.mode": "Debug Modus", "preferences.show.grid": "Gitter anzeigen", "preferences.use.cad.selection": "CAD Auswahl verwenden", "preferences.keep.stylemenu.open": "Stilmen offen halten", "preferences.always.show.snaps": "Hilfslinien immer anzeigen", "preferences.rotate.handles": "Rotiergriffe", "preferences.binding.handles": "Bindegriffe", "preferences.clone.handles": "Klongriffe", undo: "Rckgngig machen", redo: "Wiederherstellen", cut: "Ausschneiden", copy: "Kopieren", paste: "Einfgen", "copy.as": "Kopieren als", "export.as": "Exportieren als", "select.all": "Alles auswhlen", "select.none": "Nichts auswhlen", delete: "Lschen", "new.project": "Neues Projekt", open: "ffnen", save: "Speichern", "save.as": "Speichern als", "upload.media": "Medien hochladen", "create.page": "Seite erstellen", "new.page": "Neue Seite", "page.name": "Seitenname", duplicate: "Duplizieren", "shape.options": "Form Optionen", shapes: "Fromen", cancel: "Abbrechen", "copy.invite.link": "Einladungslink kopieren", "copy.readonly.link": "Schreibgeschtzten Link kopieren", "create.multiplayer.project": "Geteiltes Projekt erstellen", "copy.multiplayer.project": "In ein Geteiltes Projekt kopieren", select: "Auswhlen", eraser: "Radierer", draw: "Malen", arrow: "Pfeil", text: "Text", sticky: "Notiz", rectangle: "Rechteck", ellipse: "Ellipse", triangle: "Dreieck", line: "Linie", rotate: "Drehen", "lock.aspect.ratio": "Seitenverhltnis sperren", "unlock.aspect.ratio": "Seitenverhltnis entsperren", group: "Gruppieren", ungroup: "Gruppierung aufheben", "move.to.back": "Nach Hinten verschieben", "move.backward": "Rckwrts schieben", "move.forward": "Vorwrts schieben", "move.to.front": "Nach Vorne verschieben", "reset.angle": "Winkel zurcksetzen", lock: "Sperren", unlock: "Entsperren", "align.distribute": "Ausrichten / Verteilen", "move.to.page": "Zu Seite verschieben", "flip.horizontal": "Horizontal spiegeln", "flip.vertical": "Vertikal spiegeln", move: "Verschieben", "to.front": "Nach Vorne", forward: "Vorwrts", backward: "Rckwrts", back: "Hinten", language: "Sprache", "translation.link": "Mehr erfahren", "dock.position": "Dock Position", bottom: "Unten", left: "Links", right: "Rechts", top: "Oben", page: "Seite", "keyboard.shortcuts": "Tastaturkurzbefehle", search: "Suche", loading: "Laden{dots}", "export.background": "Hintergrund Exportieren", transparent: "Transparent", auto: "Auto", light: "Hell", dark: "Dunkel", github: "Github", twitter: "Twitter", discord: "Discord", image: "Bild", "align.left": "Links ausrichten", "align.center.x": "Horizontal mittig ausrichten", "align.right": "Rechts ausrichten", "align.top": "Oben ausrichten", "align.center.y": "Vertikal mittig ausrichten", "align.bottom": "Unten ausrichten", "distribute.x": "Horizontal verteilen", "distribute.y": "Vertikal verteilen", "stretch.x": "Horizontal strecken", "stretch.y": "Vertikal strecken", "dialog.save.firsttime": "Mchten Sie Ihr aktuelles Projekt speichern?", "dialog.save.again": "Mchten Sie die nderungen an Ihrem aktuellen Projekt speichern?", "dialog.cancel": "Abbrechen", "dialog.no": "Nein", "dialog.yes": "Ja", "enter.file.name": "Dateiname eingeben", "tldraw-beta": "Probieren Sie das neue tldraw", white: "Wei", lightGray: "hellgrau", gray: "Frau", black: "Schwarz", green: "Grn", cyan: "Cyan", blue: "Blau", indigo: "Indigo", violet: "Violett", red: "Rot", orange: "Orange", yellow: "Gelb", solid: "Durchgehend", dashed: "Gestrichelt", dotted: "Gepunktet", small: "Klein", medium: "Mittel", large: "Gro" } }, { locale: "en", label: "English", messages: {} }, { locale: "es", label: "Espaol", messages: { "style.menu.color": "Color", "style.menu.fill": "Relleno", "style.menu.dash": "Lnea", "style.menu.size": "Tamao", "style.menu.keep.open": "Mantener abierto", "style.menu.font": "Fuente", "style.menu.align": "Alineacin", styles: "Estilos", "zoom.in": "Acercar", "zoom.out": "Alejar", to: "A", "menu.tools": "Herramientas", "menu.transform": "Transformar", "menu.file": "Archivo", "menu.edit": "Editar", "menu.view": "Ver", "menu.preferences": "Preferencias", "menu.sign.in": "Iniciar sesin", "menu.sign.out": "Cerrar sesin", "become.a.sponsor": "Convirtete en patrocinador", "zoom.to.content": "Acercar al contenido", "zoom.to.selection": "Acercar a la seleccin", "zoom.to.fit": "Ajustar a la ventana", "zoom.to": "Acercar a", "preferences.dark.mode": "Modo oscuro", "preferences.focus.mode": "Modo concentracin", "preferences.debug.mode": "Modo depuracin", "preferences.show.grid": "Mostrar cuadrcula", "preferences.use.cad.selection": "Usar seleccin CAD", "preferences.keep.stylemenu.open": "Mantener men de estilos abierto", "preferences.always.show.snaps": "Mostrar puntos de ajuste", "preferences.rotate.handles": "Control de rotacin", "preferences.binding.handles": "Control de vinculacin", "preferences.clone.handles": "Control de clonacin", undo: "Deshacer", redo: "Rehacer", cut: "Cortar", copy: "Copiar", paste: "Pegar", "copy.as": "Copiar como", "export.as": "Exportar como", "select.all": "Selecionar todo", "select.none": "Selecionar nada", delete: "Borrar", "new.project": "Nuevo Proyecto", open: "Abrir", save: "Guardar", "save.as": "Guardar como", "upload.media": "Subir medios", "create.page": "Crear pgina", "new.page": "Nueva pgina", "page.name": "Nombre de pgina", duplicate: "Duplicar", "shape.options": "Opciones de formas", shapes: "Formas", cancel: "Cancelar", "copy.invite.link": "Copiar invitacin", "copy.readonly.link": "Copiar invitacin (solo lectura)", "create.multiplayer.project": "Crear proyecto multijugador", "copy.multiplayer.project": "Copiar proyecto multijugador", select: "Seleccionar", eraser: "Borrador", draw: "Dibujar", arrow: "Flecha", text: "Texto", sticky: "Pegatina", rectangle: "Rectngulo", ellipse: "Elipse", triangle: "Tringulo", line: "Lnea", rotate: "Rotar", "lock.aspect.ratio": "Bloquear relacin de aspecto", "unlock.aspect.ratio": "Desbloquear relacin de aspecto", group: "Agrupar", ungroup: "Desagrupar", "move.to.back": "Mover al fondo", "move.backward": "Mover atrs", "move.forward": "Mover adelante", "move.to.front": "Mover al frente", "reset.angle": "Restablecer ngulo", lock: "Bloquear", unlock: "Desbloquear", "align.distribute": "Alinear / Distribuir", "move.to.page": "Mover a pgina", "flip.horizontal": "Voltear horizontalmente", "flip.vertical": "Voltear verticalmente", move: "Mover", "to.front": "Al frente", forward: "Adelante", backward: "Atrs", back: "Fondo", language: "Idioma", "translation.link": "Saber ms", "dock.position": "Posicin del dock", bottom: "Abajo", left: "Izquierda", right: "Derecha", top: "Arriba", page: "Pgina", "keyboard.shortcuts": "Atajos de teclado", search: "Buscar", loading: "Cargando{dots}", "export.background": "Exportar fondo", transparent: "Transparente", auto: "Auto", light: "Claro", dark: "Oscuro", github: "Github", twitter: "Twitter", discord: "Discord", image: "Imagen", "align.left": "Alinear a la izquierda", "align.center.x": "Alinear al centro horizontalmente", "align.right": "Alinear a la derecha", "align.top": "Alinear arriba", "align.center.y": "Alinear al centro verticalmente", "align.bottom": "Alinear abajo", "distribute.x": "Distribuir horizontalmente", "distribute.y": "Distribuir verticalmente", "stretch.x": "Estirar horizontalmente", "stretch.y": "Estirar verticalmente", "dialog.save.firsttime": "Quieres guardar el proyecto actual?", "dialog.save.again": "Quieres guardar los cambios en el proyecto actual?", "dialog.cancel": "Cancelar", "dialog.no": "No", "dialog.yes": "S", "enter.file.name": "Introduce el nombre del arquivo", "tldraw-beta": "Prueba el nuevo tldraw", white: "Blanco", lightGray: "Gris claro", gray: "Gris", black: "Negro", green: "Verde", cyan: "Cian", blue: "Azul", indigo: "Indigo", violet: "Violeta", red: "Rojo", orange: "Naranja", yellow: "Amarillo", solid: "Contnuo", dashed: "Discontnuo", dotted: "Punteado", small: "Pequeo", medium: "Mediano", large: "Grande" } }, { locale: "fa", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.tools": "", "menu.transform": " ", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.content": "  ", "zoom.to.selection": "   ", "zoom.to.fit": "   ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": "  ", "preferences.use.cad.selection": "    CAD", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "     ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": " ", undo: "", redo: " ", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", "shape.options": " ", shapes: "", cancel: "", "copy.invite.link": "  ", "copy.readonly.link": "   ", "create.multiplayer.project": "   ", "copy.multiplayer.project": "   ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: " ", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "  ", "unlock.aspect.ratio": "   ", group: "", ungroup: " ", "move.to.back": "  ", "move.backward": "   ", "move.forward": "   ", "move.to.front": "  ", "reset.angle": " ", lock: "", unlock: " ", "align.distribute": " / ", "move.to.page": "  ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": " ", forward: "  ", backward: "  ", back: " ", language: "", "translation.link": " ", "dock.position": "  ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": " ", search: "", loading: "{dots}", "export.background": " ", transparent: "", auto: "", light: "", dark: "", github: "", twitter: "", discord: "", image: "", "align.left": "  ", "align.center.x": "   ", "align.right": "  ", "align.top": "  ", "align.center.y": "   ", "align.bottom": "  ", "distribute.x": " ", "distribute.y": " ", "stretch.x": " ", "stretch.y": " ", "dialog.save.firsttime": "       ", "dialog.save.again": "          ", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "", "enter.file.name": "    ", "tldraw-beta": " tldraw ", white: "", lightGray: " ", gray: "", black: "", green: "", cyan: "", blue: "", indigo: "", violet: "", red: "", orange: "", yellow: "", solid: "", dashed: "", dotted: "", small: "", medium: "", large: "" } }, { locale: "fr", label: "Franais", messages: { "style.menu.color": "Couleur", "style.menu.fill": "Remplir", "style.menu.dash": "Bordure", "style.menu.size": "Taille", "style.menu.keep.open": "Toujours afficher le menu", "style.menu.font": "Police", "style.menu.align": "Alignement", styles: "Styles", "zoom.in": "Zoom avant", "zoom.out": "Zoom arrire", to: "", "menu.tools": "Outils", "menu.transform": "Transformation", "menu.file": "Fichier", "menu.edit": "dition", "menu.view": "Afficher", "menu.preferences": "Prfrences", "menu.sign.in": "S'authentifier", "menu.sign.out": "Se dconnecter", "become.a.sponsor": "Devenir un sponsor", "zoom.to.content": "Retour au contenu", "zoom.to.selection": "Ajuster le zoom  la slection", "zoom.to.fit": "Adapter le zoom au contenu", "zoom.to": "Rtablir le zoom ", "preferences.dark.mode": "Mode sombre", "preferences.focus.mode": "Mode focus", "preferences.debug.mode": "Afficher la barre dveloppeur", "preferences.show.grid": "Afficher la grille", "preferences.use.cad.selection": "Utiliser la slection CAD", "preferences.keep.stylemenu.open": "Toujours afficher le menu styles", "preferences.always.show.snaps": "Afficher les repres dynamiques", "preferences.rotate.handles": "Manier la rotation", "preferences.binding.handles": "Manier les liaisons", "preferences.clone.handles": "Manier le clonage", undo: "Annuler", redo: "Rtablir", cut: "Couper", copy: "Copier", paste: "Coller", "copy.as": "Copier au format", "export.as": "Exporter au format", "select.all": "Tout slectionner", "select.none": "Tout dslectionner", delete: "Supprimer", "new.project": "Nouveau project", open: "Ouvrir", save: "Enregistrer", "save.as": "Enregistrer sous", "upload.media": "Importer un mdia", "create.page": "Crer une page", "new.page": "Nouvelle Page", "page.name": "Nom de la page", duplicate: "Dupliquer", cancel: "Annuler", "copy.invite.link": "Copier le lien d'invitation", "copy.readonly.link": "Copier le lien en lecture seule d'invitation", "create.multiplayer.project": "Crer un project multi-joueurs", "copy.multiplayer.project": "Copier dans un projet multi-joueurs", select: "Slection", eraser: "Gomme", draw: "Crayon", arrow: "Flche", text: "Texte", sticky: "Note", rectangle: "Rectangle", ellipse: "Cercle", triangle: "Triangle", line: "Ligne", rotate: "Rotation", "lock.aspect.ratio": "Verrouiller les proportions", "unlock.aspect.ratio": "Dverrouiller les proportions", group: "Grouper", ungroup: "Dgrouper", "move.to.back": "Dplacer  l'arrire-plan", "move.backward": "Reculer d'un plan", "move.forward": "Avancer d'un plan", "move.to.front": "Placer au premier plan", "reset.angle": "Rinitialiser la rotation", lock: "Verrouiller", unlock: "Dverrouiller", "align.distribute": "Alignement / Rpartion", "move.to.page": "Dplacer vers la page", "flip.horizontal": "Retourner horizontalement", "flip.vertical": "Retourner verticalement", move: "Disposition", "to.front": "Placer au premier plan", forward: "Avancer d'un plan", backward: "Reculer d'un plan", back: "Dplacer  l'arrire-plan", language: "Langage", "translation.link": "En savoir plus", "dock.position": "Position du dock", bottom: "En bas", left: " gauche", right: " droite", top: "En haut", page: "Page", "keyboard.shortcuts": "Raccourcis clavier", search: "Rechercher", loading: "Chargement{dots}", "export.background": "Couleur d'arrire-plan de l'export", transparent: "Transparent", auto: "Automatique", light: "Clair", dark: "Sombre" } }, { locale: "gl", label: "Galego", messages: { "style.menu.color": "Cor", "style.menu.fill": "Recheo", "style.menu.dash": "Lia", "style.menu.size": "Tamao", "style.menu.keep.open": "Manter aberto", "style.menu.font": "Fonte", "style.menu.align": "Aliamento", styles: "Estilos", "zoom.in": "Achegar", "zoom.out": "Afastar", to: "A", "menu.tools": "Ferramentas", "menu.transform": "Transformar", "menu.file": "Arquivo", "menu.edit": "Editar", "menu.view": "Ver", "menu.preferences": "Preferencias", "menu.sign.in": "Iniciar sesin", "menu.sign.out": "Pechar sesin", "become.a.sponsor": "Convrtete en patrocinador", "zoom.to.content": "Achegar ao contido", "zoom.to.selection": "Achegar  seleccin", "zoom.to.fit": "Axustar  vent", "zoom.to": "Achegar a", "preferences.dark.mode": "Modo escuro", "preferences.focus.mode": "Modo concentracin", "preferences.debug.mode": "Modo depuracin", "preferences.show.grid": "Amosar cuadrcula", "preferences.use.cad.selection": "Usar seleccin CAD", "preferences.keep.stylemenu.open": "Manter men de estilos aberto", "preferences.always.show.snaps": "Amosar puntos de axuste", "preferences.rotate.handles": "Control de rotacin", "preferences.binding.handles": "Control de vinculacin", "preferences.clone.handles": "Control de clonacin", undo: "Desfacer", redo: "Refacer", cut: "Cortar", copy: "Copiar", paste: "Pegar", "copy.as": "Copiar como", "export.as": "Exportar como", "select.all": "Selecionar todo", "select.none": "Selecionar nada", delete: "Borrar", "new.project": "Novo Proxecto", open: "Abrir", save: "Gardar", "save.as": "Gardar como", "upload.media": "Subir medios", "create.page": "Crear pxina", "new.page": "Nova pxina", "page.name": "Nome de pxina", duplicate: "Duplicar", "shape.options": "Opcins de formas", shapes: "Formas", cancel: "Cancelar", "copy.invite.link": "Copiar invitacin", "copy.readonly.link": "Copiar invitacin (s lectura)", "create.multiplayer.project": "Crear proxecto multixogador", "copy.multiplayer.project": "Copiar proxecto multixogador", select: "Seleccionar", eraser: "Borrador", draw: "Debuxar", arrow: "Frecha", text: "Texto", sticky: "Pegatina", rectangle: "Rectngulo", ellipse: "Elipse", triangle: "Tringulo", line: "Lia", rotate: "Rotar", "lock.aspect.ratio": "Bloquear relacin de aspecto", "unlock.aspect.ratio": "Desbloquear relacin de aspecto", group: "Agrupar", ungroup: "Desagrupar", "move.to.back": "Mover ao fondo", "move.backward": "Mover atrs", "move.forward": "Mover adiante", "move.to.front": "Mover ao fronte", "reset.angle": "Restablecer ngulo", lock: "Bloquear", unlock: "Desbloquear", "align.distribute": "Aliar / Distribur", "move.to.page": "Mover  pxina", "flip.horizontal": "Voltear horizontalmente", "flip.vertical": "Voltear verticalmente", move: "Mover", "to.front": "Ao fronte", forward: "Adilante", backward: "Atrs", back: "Fondo", language: "Idioma", "translation.link": "Saber mis", "dock.position": "Posicin do dock", bottom: "Abaixo", left: "Esquerda", right: "Dereita", top: "Arriba", page: "Pxina", "keyboard.shortcuts": "Atallos de teclado", search: "Buscar", loading: "Cargando{dots}", "export.background": "Exportar fondo", transparent: "Transparente", auto: "Auto", light: "Claro", dark: "Escuro", github: "Github", twitter: "Twitter", discord: "Discord", image: "Imaxe", "align.left": "Aliar  esquerda", "align.center.x": "Aliar ao centro horizontalmente", "align.right": "Aliar  dereita", "align.top": "Aliar arriba", "align.center.y": "Aliar ao centro verticalmente", "align.bottom": "Aliar abaixo", "distribute.x": "Distribur horizontalmente", "distribute.y": "Distribur verticalmente", "stretch.x": "Estirar horizontalmente", "stretch.y": "Estirar verticalmente", "dialog.save.firsttime": "Queres gardar o proxecto actual?", "dialog.save.again": "Queres gardar os cambios ao proxecto actual?", "dialog.cancel": "Cancelar", "dialog.no": "No", "dialog.yes": "S", "enter.file.name": "Introduce o nome do arquivo", "tldraw-beta": "Proba o novo tldraw", white: "Branco", lightGray: "Gris claro", gray: "Gris", black: "Negro", green: "Verde", cyan: "Cian", blue: "Azul", indigo: "Indigo", violet: "Violeta", red: "Vermello", orange: "Laranxa", yellow: "Amarelo", solid: "Contnuo", dashed: "Discontnuo", dotted: "Punteado", small: "Pequeno", medium: "Mediano", large: "Grande" } }, { locale: "he", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": " ", "zoom.out": " ", to: "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.selection": " ", "zoom.to.fit": " ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": "()  ", "preferences.use.cad.selection": " CAD", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "  ", "preferences.rotate.handles": "  ", "preferences.binding.handles": "  ", "preferences.clone.handles": "  ", undo: "", redo: " ", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "  ", "create.multiplayer.project": "   ", "copy.multiplayer.project": "   ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "  -", "unlock.aspect.ratio": "   -", group: "", ungroup: " ", "move.to.back": " ", "move.backward": " ", "move.forward": " ", "move.to.front": " ", "reset.angle": " ", lock: "", unlock: " ", "move.to.page": " ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": " ", forward: "", backward: "", back: "", language: "" } }, { locale: "it", label: "Italiano", messages: { "style.menu.color": "Colore", "style.menu.fill": "Riempi", "style.menu.dash": "Tratteggo", "style.menu.size": "Dimensione", "style.menu.keep.open": "Mantieni aperto", "style.menu.font": "Font", "style.menu.align": "Allineamento", styles: "Stile", "zoom.in": "Ingrandisci", "zoom.out": "Rimpicciolisci", to: "Imposta", "menu.file": "File", "menu.edit": "Modifica", "menu.view": "Visualizzazione", "menu.preferences": "Preferenze", "menu.sign.in": "Accedi", "menu.sign.out": "Esci", "become.a.sponsor": "Sponsorizza", "zoom.to.selection": "Adatta alla selezione", "zoom.to.fit": "Adatta", "zoom.to": "Ingrandisci", "preferences.dark.mode": "Modalit scura", "preferences.focus.mode": "Modalit zen", "preferences.debug.mode": "Modalit sviluppatore", "preferences.show.grid": "Mostra griglia", "preferences.use.cad.selection": "Selezione CAD", "preferences.keep.stylemenu.open": "Mantieni menu stile aperto", "preferences.always.show.snaps": "Mostra sempre le guide", "preferences.rotate.handles": "Controlli d'inclinazione", "preferences.binding.handles": "Controlli d'associazione", "preferences.clone.handles": "Controlli di clonazione", undo: "Annulla", redo: "Ripristina", cut: "Taglia", copy: "Copia", paste: "Incolla", "copy.as": "Copia come", "export.as": "Esporta come", "select.all": "Seleziona tutto", "select.none": "Deseleziona tutto", delete: "Elimina", "new.project": "Nuovo progetto", open: "Apri", save: "Salva", "save.as": "Salva come", "upload.media": "Carica contenuti multimediali", "create.page": "Crea nuova pagina", "new.page": "Nuova pagina", "page.name": "Nome pagina", page: "Pagina", duplicate: "Duplica", cancel: "Chiudi", "copy.invite.link": "Copia link invito", "create.multiplayer.project": "Crea progetto multiplayer", "copy.multiplayer.project": "Trasforma in progetto multiplayer", select: "Seleziona", eraser: "Gomma", draw: "Matita", arrow: "Freccia", text: "Casella di testo", sticky: "Post-it", rectangle: "Rettangolo", ellipse: "Ellisse", triangle: "Triangolo", line: "Linea", rotate: "Ruota", "lock.aspect.ratio": "Blocca rapporto lati", "unlock.aspect.ratio": "Sblocca rapporto lati", group: "Raggruppa", ungroup: "Separa", "move.to.back": "Muovi in fondo", "move.backward": "Sposta indietro", "move.forward": "Sposta avanti", "move.to.front": "Muovi in fronte", "reset.angle": "Reimposta angolo", lock: "Blocca", unlock: "Sblocca", "move.to.page": "Trasferisci a pagina", "flip.horizontal": "Ribalta orizzontalmente", "flip.vertical": "Ribalta verticalmente", move: "Sposta", "to.front": "In primo piano", forward: "Sposta avanti", backward: "Sposta indietro", back: "In fondo", language: "Lingua", "dock.position": "Posizione dock", bottom: "In basso", left: "Sinistra", right: "Destra", top: "In Alto" } }, { locale: "ja", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "/", "style.menu.keep.open": "", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: " ", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": "", "zoom.to.selection": "", "zoom.to.fit": "", "zoom.to": "", "preferences.dark.mode": "", "preferences.focus.mode": "", "preferences.debug.mode": "", "preferences.show.grid": "", "preferences.use.cad.selection": "CAD", "preferences.keep.stylemenu.open": "", "preferences.always.show.snaps": "", "preferences.rotate.handles": "", "preferences.binding.handles": "", "preferences.clone.handles": "", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": "", "export.as": "", "select.all": "", "select.none": "", delete: "", "new.project": "", open: "", save: "", "save.as": "", "upload.media": "", "create.page": "", "new.page": "", "page.name": "", duplicate: "", cancel: "", "copy.invite.link": "", "create.multiplayer.project": "", "copy.multiplayer.project": "", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "", "unlock.aspect.ratio": "", group: "", ungroup: "", "move.to.back": "", "move.backward": "", "move.forward": "", "move.to.front": "", "reset.angle": "", lock: "", unlock: "", "move.to.page": "", "flip.horizontal": "", "flip.vertical": "", move: "", "to.front": "", forward: "", backward: "", back: "", language: "" } }, { locale: "ko-kr", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "To", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.content": " ", "zoom.to.selection": "  ", "zoom.to.fit": " ", "zoom.to": "", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": "CAD  ", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "Snap  ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": " ", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": "", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": "  ", "upload.media": " ", "create.page": "  ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "  ", "copy.readonly.link": "   ", "create.multiplayer.project": "   ", "copy.multiplayer.project": "   ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": " ", "unlock.aspect.ratio": "  ", group: "", ungroup: " ", "move.to.back": "  ", "move.backward": " ", "move.forward": " ", "move.to.front": "  ", "reset.angle": " ", lock: "", unlock: " ", "align.distribute": " /  ", "move.to.page": " ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": " ", forward: "", backward: "", back: " ", language: "", "translation.link": " ", "dock.position": " ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": " ", search: "", loading: "{dots}", "export.background": " ", transparent: "", auto: "", light: "", dark: "", github: "Github", twitter: "Twitter", discord: "Discord", image: "", "align.left": " ", "align.center.x": "  ", "align.right": " ", "align.top": " ", "align.center.y": "  ", "align.bottom": " ", "distribute.x": "  ", "distribute.y": "  ", "stretch.x": " ", "stretch.y": " ", "dialog.save.firsttime": "  ?", "dialog.save.again": "   ?", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "", "enter.file.name": "  ", "tldraw-beta": " tldraw " } }, { locale: "my", label: "", messages: { "style.menu.color": "", "style.menu.fill": " ", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": "", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": "", "zoom.to.content": " ", "zoom.to.selection": "  ", "zoom.to.fit": " ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": "CAD   ", "preferences.keep.stylemenu.open": "  ", "preferences.always.show.snaps": "Always Show Snaps", "preferences.rotate.handles": "Rotate Handles", "preferences.binding.handles": "Binding Handles", "preferences.clone.handles": "Clone Handles", undo: " ", redo: "", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": "  ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": " ", "copy.readonly.link": " ", "create.multiplayer.project": "  ", "copy.multiplayer.project": "  ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": " ", "unlock.aspect.ratio": " ", group: "", ungroup: "", "move.to.back": " ", "move.backward": " ", "move.forward": " ", "move.to.front": " ", "reset.angle": " ", lock: "", unlock: "", "align.distribute": " / ", "move.to.page": " ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": "", forward: "", backward: "", back: "", language: "", "translation.link": " ", "dock.position": " ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": "Keyboard shortcuts", search: "", loading: "{dots}", "export.background": " ", transparent: " ", auto: "Auto", light: "", dark: "", github: "Github", twitter: "Twitter", discord: "Discord", image: "", "align.left": " ", "align.center.x": "  ", "align.right": " ", "align.top": " ", "align.center.y": "  ", "align.bottom": " ", "distribute.x": " ", "distribute.y": " ", "stretch.x": " ", "stretch.y": " ", "dialog.save.firsttime": "   ?", "dialog.save.again": "     ?", "dialog.cancel": " ", "dialog.no": "", "dialog.yes": "", "enter.file.name": " ", "tldraw-beta": "tldraw " } }, { locale: "nb-no", label: "Norwegian Bokml", messages: { "style.menu.color": "Farge", "style.menu.fill": "Fyll", "style.menu.dash": "Linje", "style.menu.size": "Strrelse", "style.menu.keep.open": "Hold pen", "style.menu.font": "Teksttype", "style.menu.align": "Juster", styles: "Stiler", "zoom.in": "Zoom inn", "zoom.out": "Zoom ut", to: "til", "menu.file": "Fil", "menu.edit": "Rediger", "menu.view": "Vis", "menu.preferences": "Preferanser", "menu.sign.in": "Logg inn", "menu.sign.out": "Logg ut", "become.a.sponsor": "Bli en sponsor", "zoom.to.selection": "Zoom til valg", "zoom.to.fit": "Zoom for  passe", "zoom.to": "Zoom til", "preferences.dark.mode": "Mrk modus", "preferences.focus.mode": "Fokus modus", "preferences.debug.mode": "Debug modus", "preferences.show.grid": "Vis rutenett", "preferences.use.cad.selection": "Bruk CAD seleksjon", "preferences.keep.stylemenu.open": "Hold stilmeny pen", "preferences.always.show.snaps": "Vis alltid snaps", "preferences.rotate.handles": "Vis roteringshndtak", "preferences.binding.handles": "Vis bindingshndtak", "preferences.clone.handles": "Vis kloningshndtak", undo: "Angre", redo: "Gjr om", cut: "Klipp ut", copy: "Kopier", paste: "Lim inn", "copy.as": "Kopier som", "export.as": "Eksporter som", "select.all": "Velg alle", "select.none": "Velg ingen", delete: "Slett", "new.project": "Nytt prosjekt", open: "pne", save: "Lagre", "save.as": "Lagre som", "upload.media": "Last opp media", "create.page": "Opprett side", "new.page": "Ny side", "page.name": "Sidenavn", duplicate: "Dupliser", cancel: "Avbryt", "copy.invite.link": "Kopier invitasjonslink", "create.multiplayer.project": "Opprett et flerspiller prosjekt", "copy.multiplayer.project": "Kopier til flerspiller prosjekt", select: "Velg", eraser: "Viskelr", draw: "Tegn", arrow: "Pil", text: "Tekst", sticky: "Lapp", rectangle: "Rektangel", ellipse: "Ellipse", triangle: "Trekant", line: "Linje", rotate: "Roter", "lock.aspect.ratio": "Ls strrelsesforhold", "unlock.aspect.ratio": "Ls opp strrelsesforhold", group: "Grupper", ungroup: "Avgrupper", "move.to.back": "Flytt bakerst", "move.backward": "Flytt bakover", "move.forward": "Flytt forover", "move.to.front": "Flytt til front", "reset.angle": "Tilbakestill vinkel", lock: "Ls", unlock: "Ls opp", "move.to.page": "Flytt til side", "flip.horizontal": "Snu horisontalt", "flip.vertical": "Snu vertikalt", move: "Flytt", "to.front": "Foran", forward: "Framover", backward: "Bakover", back: "Bakerst", language: "Sprk" } }, { locale: "ne", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": " ", "zoom.out": " ", to: "", "menu.file": "", "menu.edit": " ", "menu.view": "", "menu.preferences": "", "menu.sign.in": "  ", "menu.sign.out": "  ", "become.a.sponsor": " ", "zoom.to.selection": "  ", "zoom.to.fit": "  ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": "CAD  ", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "  ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": " ", undo: " ", redo: " ", cut: " ", copy: " ", paste: " ", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": "   ", delete: "", "new.project": " ", open: "", save: " ", "save.as": " ", "upload.media": "  ", "create.page": "  ", "new.page": "   ", "page.name": " ", duplicate: " ", cancel: " ", "copy.invite.link": "   ", "create.multiplayer.project": "   ", "copy.multiplayer.project": "   ", select: "", eraser: "", draw: " ", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "   ", "unlock.aspect.ratio": "   ", group: "", ungroup: "  ", "move.to.back": " ", "move.backward": "  ", "move.forward": " ", "move.to.front": "  ", "reset.angle": "  ", lock: " ", unlock: " ", "move.to.page": " ", "flip.horizontal": "  ", "flip.vertical": "  ", move: "", "to.front": " ", forward: "", backward: "", back: " ", language: "" } }, { locale: "nn-no", label: "Norwegian Nynorsk", messages: { "style.menu.color": "Farge", "style.menu.fill": "Fyll", "style.menu.dash": "Line", "style.menu.size": "Storleik", "style.menu.keep.open": "Hald open", "style.menu.font": "Teksttype", "style.menu.align": "Tilpass", styles: "Stilar", "zoom.in": "Zoom inn", "zoom.out": "Zoom ut", to: "til", "menu.file": "Fil", "menu.edit": "Rediger", "menu.view": "Vis", "menu.preferences": "Innstillingar", "menu.sign.in": "Logg inn", "menu.sign.out": "Logg ut", "become.a.sponsor": "Vert sponsor", "zoom.to.content": "Zoom til innhald", "zoom.to.selection": "Zoom til valte element", "zoom.to.fit": "Zoom for  passe", "zoom.to": "Zoom til", "preferences.dark.mode": "Mrkmodus", "preferences.focus.mode": "Fokusmodus", "preferences.debug.mode": "Debugmodus", "preferences.show.grid": "Vis rutenett", "preferences.use.cad.selection": "Bruk CAD-val", "preferences.keep.stylemenu.open": "Hald stilmeny open", "preferences.always.show.snaps": "Vis alltid snaps", "preferences.rotate.handles": "Vis roteringshandtak", "preferences.binding.handles": "Vis bindingshandtak", "preferences.clone.handles": "Vis kloningshandtak", undo: "Angre", redo: "Gjer om", cut: "Klipp ut", copy: "Kopier", paste: "Lim inn", "copy.as": "Kopier som", "export.as": "Eksporter som", "select.all": "Vel alle", "select.none": "Vel ingen", delete: "Slett", "new.project": "Nytt prosjekt", open: "Opne", save: "Lagre", "save.as": "Lagre som", "upload.media": "Last opp media", "create.page": "Opprett side", "new.page": "Ny side", "page.name": "Sidenamn", duplicate: "Dupliser", cancel: "Avbryt", "copy.invite.link": "Kopier invitasjonslenke", "copy.readonly.link": "Kopier invitasjonslenke (skrivebeskytta)", "create.multiplayer.project": "Lag samarbeidsprosjekt", "copy.multiplayer.project": "Kopier til samarbeidsprosjekt", select: "Vel", eraser: "Viskelr", draw: "Teikn", arrow: "Pil", text: "Tekst", sticky: "Lapp", rectangle: "Rektangel", ellipse: "Runding", triangle: "Trekant", line: "Line", rotate: "Roter", "lock.aspect.ratio": "Ls storleiksforhold", "unlock.aspect.ratio": "Ls opp storleiksforhold", group: "Grupper", ungroup: "Avgrupper", "move.to.back": "Flytt bakarst", "move.backward": "Flytt bakover", "move.forward": "Flytt framover", "move.to.front": "Flytt til front", "reset.angle": "Tilbakestill vinkel", lock: "Ls", unlock: "Ls opp", "move.to.page": "Flytt til side", "flip.horizontal": "Snu horisontalt", "flip.vertical": "Snu vertikalt", move: "Flytt", "to.front": "Framme", forward: "Framover", backward: "Bakover", back: "Bakarst", language: "Sprk", "translation.link": "Les meir", "dock.position": "Dokkplassering", bottom: "Nede", left: "Venstre", right: "Hgre", top: "Oppe", page: "Side", "keyboard.shortcuts": "Snggtastar", search: "Sk", loading: "Lastar{dots}", "export.background": "Eksporter bakgrunn", transparent: "Gjennomsiktig", auto: "Auto", light: "Lys", dark: "Mrk", github: "Github", twitter: "Twitter", discord: "Discord", image: "Bilete", "align.left": "Venstrestill", "align.center.x": "Midtstill horisontalt", "align.right": "Hgrestill", "align.top": "Still til toppen", "align.center.y": "Midtstill vertikalt", "align.bottom": "Still til botnen", "distribute.x": "Distribuer horisontalt", "distribute.y": "Distribuer vertikalt", "stretch.x": "Strekk horisontalt", "stretch.y": "Strekk vertikalt", "dialog.save.firsttime": "Vil du lagre det noverande prosjektet ditt?", "dialog.save.again": "Vil du lagre endringane i det noverande prosjektet ditt?", "dialog.cancel": "Avbryt", "dialog.no": "Nei", "dialog.yes": "Ja", "enter.file.name": "Fyll inn filnamn", "tldraw-beta": "Prv den nye tldraw", white: "Kvit", lightGray: "Lys gr", gray: "Gr", black: "Svart", green: "Grn", cyan: "Cyan", blue: "Bk", indigo: "Indigo", violet: "Fiol", red: "Raud", orange: "Oransj", yellow: "Gul", solid: "Heil", dashed: "Stipla", dotted: "Prikka", small: "Liten", medium: "Mellomstor", large: "Stor" } }, { locale: "pl", label: "Polski", messages: { "style.menu.color": "Kolor", "style.menu.fill": "Wypenienie", "style.menu.dash": "Linia", "style.menu.size": "Rozmiar", "style.menu.keep.open": "Zachowaj otwarte", "style.menu.font": "Czcionka", "style.menu.align": "Wyrwnanie", styles: "Style", "zoom.in": "Przybli", "zoom.out": "Oddal", to: "do", "menu.file": "Plik", "menu.edit": "Edycja", "menu.view": "Widok", "menu.preferences": "Preferencje", "menu.sign.in": "Zaloguj", "menu.sign.out": "Wyloguj", "become.a.sponsor": "Zosta sponsorem", "zoom.to.selection": "Przybli do zaznaczenia", "zoom.to.fit": "Wypenij ekran", "zoom.to": "Przybli do", "preferences.dark.mode": "Tryb ciemny", "preferences.focus.mode": "Tryb skupienia", "preferences.debug.mode": "Tryb debugowania", "preferences.show.grid": "Poka siatk", "preferences.use.cad.selection": "Uyj zaznaczania CAD", "preferences.keep.stylemenu.open": "Zachowaj menu styli otwarte", "preferences.always.show.snaps": "Przycigaj obiekty", "preferences.rotate.handles": "Uchwyty obrotu", "preferences.binding.handles": "Uchwyty powizania", "preferences.clone.handles": "Uchwyty klonujce", undo: "Cofnij", redo: "Powtrz", cut: "Wytnij", copy: "Kopiuj", paste: "Wklej", "copy.as": "Kopiuj jako", "export.as": "Eksportuj jako", "select.all": "Zaznacz wszystko", "select.none": "Odznacz wszystko", delete: "Usu", "new.project": "Nowy projekt", open: "Otwrz", save: "Zapisz", "save.as": "Zapisz jako", "upload.media": "Zaaduj multimedia", "create.page": "Utwrz stron", "new.page": "Nowa strona", "page.name": "Nazwa strony", duplicate: "Powiel", cancel: "Anuluj", "copy.invite.link": "Kopiuj link zaproszenia", "create.multiplayer.project": "Stwrz projekt wieloosobowy", "copy.multiplayer.project": "Kopiuj do projektu wieloosobowego", select: "Zaznacz", eraser: "Gumka", draw: "Rysuj", arrow: "Strzaka", text: "Tekst", sticky: "Naklejka", rectangle: "Prostokt", ellipse: "Elipsa", triangle: "Trjkt", line: "Linia", rotate: "Obr", "lock.aspect.ratio": "Zablokuj proporcje", "unlock.aspect.ratio": "Odblokuj proporcje", group: "Grupuj", ungroup: "Rozgrupuj", "move.to.back": "Przenie na ty", "move.backward": "Przesu do tyu", "move.forward": "Przesu do przodu", "move.to.front": "Przenie na przd", "reset.angle": "Resetuj kt", lock: "Zablokuj", unlock: "Odblokuj", "move.to.page": "Przenie na stron", "flip.horizontal": "Odwr w poziomie", "flip.vertical": "Odwr w pionie", move: "Przenie", "to.front": "Na wierzch", forward: "Do przodu", backward: "Do tyu", back: "Na spd", language: "Jzyk", "translation.link": "Czytaj wicej", "dock.position": "Pozycja przybornika", bottom: "D", left: "Lewa", right: "Prawa", top: "Gra", page: "Strona", "keyboard.shortcuts": "Skrty klawiszowe", search: "Szukaj", loading: "adowanie{dots}", "export.background": "Eksportuj to", transparent: "Przezroczyste", auto: "Automatyczny", light: "Jasny", dark: "Ciemny", github: "Github", twitter: "Twitter", discord: "Discord", image: "Obraz", "align.left": "Wyrwnaj do lewej", "align.center.x": "Wycentruj poziomo", "align.right": "Wyrwnaj do prawej", "align.top": "Wyrwnaj do gry", "align.center.y": "Wycentruj pionowo", "align.bottom": "Wyrwnaj do dou", "distribute.x": "Roz poziomo", "distribute.y": "Roz pionowo", "stretch.x": "Rozcignij poziomo", "stretch.y": "Rozcignij pionowo", "dialog.save.firsttime": "Czy chcesz zapisa biecy projekt?", "dialog.save.again": "Czy chcesz zapisa zmiany w biecym projekcie?", "dialog.cancel": "Anuluj", "dialog.no": "Nie", "dialog.yes": "Tak", "enter.file.name": "Podaj nazw pliku", "tldraw-beta": "Wyprbuj nowy tldraw" } }, { locale: "pt", label: "Portugus - Europeu", messages: { "style.menu.color": "Cor", "style.menu.fill": "Preencher", "style.menu.dash": "Trao", "style.menu.size": "Tamanho", "style.menu.keep.open": "Manter aberto", "style.menu.font": "Fonte", "style.menu.align": "Alinhamento", styles: "Estilos", "zoom.in": "Aumentar zoom", "zoom.out": "Diminuir zoom", to: "para", "menu.file": "Ficheiro", "menu.edit": "Editar", "menu.view": "Visualizar", "menu.preferences": "Preferncias", "menu.sign.in": "Entrar", "menu.sign.out": "Sair", "become.a.sponsor": "Torne-se um patrocinador", "zoom.to.selection": "Zoom na seleo", "zoom.to.fit": "Zoom para caber", "zoom.to": "Zoom para", "preferences.dark.mode": "Modo Escuro", "preferences.focus.mode": "Modo Foco", "preferences.debug.mode": "Modo Debug", "preferences.show.grid": "Mostrar Grelha", "preferences.use.cad.selection": "Usar seleo CAD", "preferences.keep.stylemenu.open": "Manter Menu de Estilos Aberto", "preferences.always.show.snaps": "Mostrar Pontos de Ajuste", "preferences.rotate.handles": "Controlo de Rotao", "preferences.binding.handles": "Controlo de Binds", "preferences.clone.handles": "Controlo de Clone", undo: "Desfazer", redo: "Refazer", cut: "Cortar", copy: "Copiar", paste: "Colar", "copy.as": "Copiar como", "export.as": "Exportar como", "select.all": "Selecionar todos", "select.none": "Selecionar nenhum", delete: "Apagar", "new.project": "Novo Projeto", open: "Abrir", save: "Salvar", "save.as": "Salvar Como", "upload.media": "Upload Mdia", "create.page": "Criar Pgina", "new.page": "Nova Pgina", "page.name": "Nome da Pgina", duplicate: "Duplicar", cancel: "Cancelar", "copy.invite.link": "Copiar Link de Convite", "create.multiplayer.project": "Criar um Projeto Multi-Utilizador", "copy.multiplayer.project": "Copiar num Projeto Multi-Utilizador", select: "Selecionar", eraser: "Borracha", draw: "Desenhar", arrow: "Seta", text: "Texto", sticky: "Post-it", rectangle: "Retngulo", ellipse: "Elipse", triangle: "Tringulo", line: "Linha", rotate: "Rodar", "lock.aspect.ratio": "Trancar a Proporo", "unlock.aspect.ratio": "Destrancar a Proporo", group: "Agrupar", ungroup: "Desagrupar", "move.to.back": "Colocar no Fundo", "move.backward": "Mover abaixo", "move.forward": "Mover acima", "move.to.front": "Colocar  Frente", "reset.angle": "Reiniciar ngulo", lock: "Trancar", unlock: "Destrancar", "move.to.page": "Mover para Pgina", "flip.horizontal": "Inverter Horizontalmente", "flip.vertical": "Inverter Verticalmente", move: "Mover", "to.front": "Para Frente", forward: "Avanar", backward: "Recuar", back: "Voltar", language: "Lngua" } }, { locale: "pt-br", label: "Portugus - Brasil", messages: { "style.menu.color": "Cor", "style.menu.fill": "Preencher", "style.menu.dash": "Trao", "style.menu.size": "Tamanho", "style.menu.keep.open": "Manter aberto", "style.menu.font": "Fonte", "style.menu.align": "Alinhamento", styles: "Estilos", "zoom.in": "Aumentar zoom", "zoom.out": "Diminuir zoom", to: "para", "menu.file": "Arquivo", "menu.edit": "Editar", "menu.view": "Visualizar", "menu.preferences": "Preferncias", "menu.sign.in": "Entrar", "menu.sign.out": "Sair", "become.a.sponsor": "Torne-se um patrocinador", "zoom.to.selection": "Zoom para a seleo", "zoom.to.fit": "Zoom para ajuste", "zoom.to": "Zoom para", "preferences.dark.mode": "Modo Escuro", "preferences.focus.mode": "Modo Foco", "preferences.debug.mode": "Modo Debug", "preferences.show.grid": "Mostrar Grade", "preferences.use.cad.selection": "Usar seleo CAD", "preferences.keep.stylemenu.open": "Manter Menu de Estilos Aberto", "preferences.always.show.snaps": "Mostrar Pontos de Ajuste", "preferences.rotate.handles": "Controle de Rotao", "preferences.binding.handles": "Controle de Vnculos", "preferences.clone.handles": "Controle de Clone", undo: "Desfazer", redo: "Refazer", cut: "Cortar", copy: "Copiar", paste: "Colar", "copy.as": "Copiar como", "export.as": "Exportar como", "select.all": "Selecionar todos", "select.none": "Selecionar nenhum", delete: "Deletar", "new.project": "Novo Projeto", open: "Abrir", save: "Salvar", "save.as": "Salvar Como", "upload.media": "Carregar Mdia", page: "Pgina", search: "Procurar", loading: "Carregando{dots}", "export.background": "Exportar Fundo", transparent: "Transparente", auto: "Automtico", light: "Claro", dark: "Escuro", "menu.tools": "Ferramentas", "menu.transform": "Transformar", "zoom.to.content": "Voltar ao Contedo", "translation.link": "Saiba Mais", "copy.readonly.link": "Copiar Link ReadOnly", "align.distribute": "Alinhar / Distribuir", "create.page": "Criar Pgina", "new.page": "Nova Pgina", "page.name": "Nome da Pgina", duplicate: "Duplicar", cancel: "Cancelar", "copy.invite.link": "Copiar Link de Convite", "create.multiplayer.project": "Criar um Projeto Multijogador", "copy.multiplayer.project": "Copiar para Projeto Multijogador", select: "Selecionar", eraser: "Borracha", draw: "Desenhar", arrow: "Seta", text: "Texto", sticky: "Adesivo", rectangle: "Retngulo", ellipse: "Elipse", triangle: "Tringulo", line: "Linha", rotate: "Rotacionar", "lock.aspect.ratio": "Travar Proporo da Tela", "unlock.aspect.ratio": "Destravar Proporo da Tela", group: "Agrupar", ungroup: "Desagrupar", "move.to.back": "Recuar", "move.backward": "Enviar para Trs", "move.forward": "Avanar", "move.to.front": "Trazer para Frente", "reset.angle": "Reiniciar ngulo", lock: "Travar", unlock: "Destravar", "move.to.page": "Mover para Pgina", "flip.horizontal": "Virar Horizontalmente", "flip.vertical": "Virar Verticalmente", move: "Mover", "to.front": "Para Frente", forward: "Avanar", backward: "Recuar", back: "Voltar", language: "Idioma", image: "Imagem", "keyboard.shortcuts": "Atalhos de Teclado", "dock.position": "Posio de Ferramentas", bottom: "Inferior", top: "Superior", right: "Direita", left: "Esquerda", "align.left": "Alinhar  esquerda", "align.center.x": "Alinhar ao centro na horizontal", "align.right": "Alinhar  direita", "align.top": "Alinhas em cima", "align.center.y": "Alinhar ao centro na vertical", "align.bottom": "Alinhar embaixo", "distribute.x": "Distruibuir na horizontal", "distribute.y": "Distruibuir na vertical", "stretch.x": "Esticar na horizontal", "stretch.y": "Esticar na vertical", "dialog.save.firsttime": "Voc deseja salvar seu projeto atual?", "dialog.save.again": "Voc deseja salvar as mudanas ao projeto atual?", "dialog.cancel": "Cancelar", "dialog.no": "No", "dialog.yes": "Sim", "enter.file.name": "Insira o nome do arquivo" } }, { locale: "ru", label: "Russian", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.content": "  ", "zoom.to.selection": "  ", "zoom.to.fit": "   ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": " CAD ", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "  ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": " ", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "  ", "copy.readonly.link": "    ", "create.multiplayer.project": "  ", "copy.multiplayer.project": "   ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "  ", "unlock.aspect.ratio": "  ", group: "", ungroup: "", "move.to.back": " ", "move.backward": "   ", "move.forward": " ", "move.to.front": "   ", "reset.angle": " ", lock: "", unlock: "", "align.distribute": " / ", "move.to.page": "  ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": "  ", forward: "", backward: "  ", back: "", language: "", "translation.link": "", "dock.position": "  ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": " ", search: "", loading: "", "export.background": " ", transparent: "", auto: "", light: "", dark: "", image: "", "align.left": "   ", "align.center.x": "   ", "align.right": "   ", "align.top": "   ", "align.center.y": "   ", "align.bottom": "   ", "distribute.x": " ", "distribute.y": " ", "stretch.x": " ", "stretch.y": " ", share: "", "copy.current.page.link": "    ", "copy.project.link": "   ", "data.too.big.encoded": "  ,     .     !", "dialog.save.firsttime": "  ?", "dialog.save.again": "    ?", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "", "enter.file.name": "  " } }, { locale: "sv", label: "Svenska", messages: { "style.menu.color": "Frg", "style.menu.fill": "Ifylld", "style.menu.dash": "Streck", "style.menu.size": "Storlek", "style.menu.keep.open": "Hll stilmenyn ppen", "style.menu.font": "Typsnitt", "style.menu.align": "Justera", styles: "Utseende", "zoom.in": "Zooma in", "zoom.out": "Zooma ut", to: "Till", "menu.tools": "Verktyg", "menu.transform": "Transform", "menu.file": "Arkiv", "menu.edit": "Redigera", "menu.view": "Innehll", "menu.preferences": "Instllningar", "menu.sign.in": "Logga in", "menu.sign.out": "Logga ut", "become.a.sponsor": "Bli en sponsor", "zoom.to.content": "Anpassa zoom till innehll", "zoom.to.selection": "Anpassa zoom till urval", "zoom.to.fit": "Anpassa zoom till skrm", "zoom.to": "Zooma till", "preferences.dark.mode": "Mrkt lge", "preferences.focus.mode": "Fokuslge", "preferences.debug.mode": "Debuglge", "preferences.show.grid": "Visa rutnt", "preferences.use.cad.selection": "Vlj som i CAD-mjukvara", "preferences.keep.stylemenu.open": "Hll stilmenyn ppen", "preferences.always.show.snaps": "Visa alltid fstpunkter", "preferences.rotate.handles": "Rotationshandtag", "preferences.binding.handles": "Bindningshandtag", "preferences.clone.handles": "Kloningshandtag", undo: "ngra", redo: "Gr om", cut: "Klipp ut", copy: "Kopiera", paste: "Klistra in", "copy.as": "Kopiera som", "export.as": "Exportera till", "select.all": "Vlj alla", "select.none": "Vlj ingen", delete: "Radera", "new.project": "Nytt projekt", open: "ppna", save: "Spara", "save.as": "Spara som", "upload.media": "Ladda upp media", "create.page": "Skapa sida", "new.page": "Ny sida", "page.name": "Sidnamn", duplicate: "Duplicera", cancel: "Avbryt", "copy.invite.link": "Kopiera lnk med redigeringsrttigheter", "copy.readonly.link": "Kopiera lnk med lsrttigheter", "create.multiplayer.project": "Skapa ett Multiplayer-projekt", "copy.multiplayer.project": "Kopiera till Multiplayer-project", select: "Vlj", eraser: "Radera", draw: "Rita", arrow: "Pil", text: "Text", sticky: "Klisterlapp", rectangle: "Rektangel", ellipse: "Ellips", triangle: "Triangel", line: "Linje", rotate: "Rotera", "lock.aspect.ratio": "Ls storleksfrhllande", "unlock.aspect.ratio": "Ls upp storleksfrhllande", group: "Gruppera", ungroup: "Avgruppera", "move.to.back": "Placera lngst bak", "move.backward": "Flytta bakt", "move.forward": "Flytta framt", "move.to.front": "Placera lngst fram", "reset.angle": "terstll vinkel", lock: "Ls", unlock: "Ls upp", "align.distribute": "Justera / Placera", "move.to.page": "Flytta till sida", "flip.horizontal": "Vnd horisontellt", "flip.vertical": "Vnd vertikalt", move: "Flytta", "to.front": "Till lngst fram", forward: "Framt", backward: "Bakt", back: "Till lngst bak", language: "Sprk", "translation.link": "Mer information", "dock.position": "Dockningsposition", bottom: "Botten", left: "Vnster", right: "Hger", top: "Topp", page: "Sida", "keyboard.shortcuts": "Tangentbordsgenvgar", search: "Sk", loading: "Laddar{dots}", "export.background": "Exportbakgrund", transparent: "Transparent", auto: "Auto", light: "Ljus", dark: "Mrk", github: "Github", twitter: "Twitter", discord: "Discord", image: "Bild" } }, { locale: "te", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": " ", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": " ", "zoom.out": " ", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.content": " ", "zoom.to.selection": "  ", "zoom.to.fit": " ", "zoom.to": "", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": "CAD ", "preferences.keep.stylemenu.open": "  ", "preferences.always.show.snaps": "  ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": " ", undo: " ", redo: " ", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "  ", "copy.readonly.link": "  ", "create.multiplayer.project": "  ", "copy.multiplayer.project": "  ", select: "", eraser: "Eraser", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "  ", "unlock.aspect.ratio": "  ", group: " ", ungroup: " ", "move.to.back": " ", "move.backward": " ", "move.forward": " ", "move.to.front": " ", "reset.angle": " ", lock: " ", unlock: " ", "align.distribute": " /", "move.to.page": " ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": "", forward: "", backward: "", back: "", language: "", "translation.link": "  ", "dock.position": " ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": " ", search: "", loading: "Loading{dots}", "export.background": " ", transparent: " ", auto: "", light: "", dark: "", github: "Github", twitter: "Twitter", discord: "Discord", image: "", "align.left": " ", "align.center.x": "  ", "align.right": " ", "align.top": " ", "align.center.y": "  ", "align.bottom": " ", "distribute.x": " ", "distribute.y": " ", "stretch.x": " ", "stretch.y": " ", "dialog.save.firsttime": "    ?", "dialog.save.again": "    ?", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "", "enter.file.name": "  " } }, { locale: "tr", label: "Trke", messages: { "style.menu.color": "Renk", "style.menu.fill": "Doldur", "style.menu.dash": "izgi", "style.menu.size": "Boyut", "style.menu.keep.open": "Ak Tut", "style.menu.font": "Yaz Tipi", "style.menu.align": "Hizala", styles: "Stiller", "zoom.in": "Yaknlatr", "zoom.out": "Uzaklatr", to: "", "menu.file": "Dosya", "menu.edit": "Dzenle", "menu.view": "Grnt", "menu.preferences": "Tercihler", "menu.sign.in": "Giri Yap", "menu.sign.out": "Oturumu Kapat", "become.a.sponsor": "Sponsor Ol", "zoom.to.selection": "Seime Yaknlatr", "zoom.to.fit": "Sdrmak iin Yaknlatr", "zoom.to": "Yaknlatr", "preferences.dark.mode": "Karanlk Mod", "preferences.focus.mode": "Odak Modu", "preferences.debug.mode": "Debug Modu", "preferences.show.grid": "Izgaray Gster", "preferences.use.cad.selection": "CAD Seimi Kullan", "preferences.keep.stylemenu.open": "Stil Mensn Ak Tut", "preferences.always.show.snaps": "Hiza izgilerini Hep Gster", "preferences.rotate.handles": "Rotasyon Kontrolcleri", "preferences.binding.handles": "Balama Kontrolcleri", "preferences.clone.handles": "Klon Kontrolcleri", undo: "Geri Al", redo: "Yinele", cut: "Kes", copy: "Kopyala", paste: "Yaptr", "copy.as": "Olarak Kopyala", "export.as": "Olarak Dar Aktar", "select.all": "Hepsini Se", "select.none": "Hibirini Seme", delete: "Sil", "new.project": "Yeni Proje", open: "A", save: "Kaydet", "save.as": "Farkl Kaydet", "upload.media": "Medya Ykle", "create.page": "Sayfa Olutur", "new.page": "Yeni Sayfa", "page.name": "Sayfa smi", duplicate: "Kopya Olutur", cancel: "ptal", "copy.invite.link": "Davet Linkini Kopyala", "create.multiplayer.project": "ok Oyunculu Proje Olutur", "copy.multiplayer.project": "ok Oyunculu Projeye Kopyala", select: "Se", eraser: "Silgi", draw: "izim", arrow: "Ok", text: "Yaz", sticky: "Yapkan", rectangle: "Dikdrtgen", ellipse: "Elips", triangle: "gen", line: "izgi", rotate: "Dndr", "lock.aspect.ratio": "En Boy Orann Kilitle", "unlock.aspect.ratio": "En Boy Oran Kilidini A", group: "Grupla", ungroup: "Gruplamay Kaldr", "move.to.back": "Arkaya Ta", "move.backward": "En Arkaya Ta", "move.forward": "En ne Ta", "move.to.front": "ne Ta", "reset.angle": "Ay Sfrla", lock: "Kilitle", unlock: "Kilidini A", "move.to.page": "Sayfaya Ta", "flip.horizontal": "Yatay evir", "flip.vertical": "Dikey evir", move: "Ta", "to.front": "ne", forward: "En ne", backward: "En Arkaya", back: "Arkaya", language: "Dil" } }, { locale: "uk", label: "Ukrainian", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": " ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.selection": "  ", "zoom.to.fit": "   ", "zoom.to": " ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": " ", "preferences.use.cad.selection": " CAD ", "preferences.keep.stylemenu.open": "   ", "preferences.always.show.snaps": "  '", "preferences.rotate.handles": " ", "preferences.binding.handles": " '", "preferences.clone.handles": " ", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "   ", "create.multiplayer.project": "  ", "copy.multiplayer.project": "   ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: " ", rotate: "", "lock.aspect.ratio": "  ", "unlock.aspect.ratio": "   ", group: "", ungroup: " ", "move.to.back": " ", "move.backward": "   ", "move.forward": " ", "move.to.front": "   ", "reset.angle": " ", lock: "", unlock: " ", "move.to.page": "  ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": "  ", forward: " ", backward: "  ", back: "", language: "" } }, { locale: "zh-ch", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": "", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", search: "", "become.a.sponsor": "", "zoom.to.selection": "", "zoom.to.fit": "", "zoom.to": "", "zoom.to.content": "", "preferences.dark.mode": "", "preferences.focus.mode": "", "preferences.debug.mode": "", "preferences.show.grid": "", "preferences.use.cad.selection": " CAD ", "preferences.keep.stylemenu.open": "", "preferences.always.show.snaps": "", "preferences.rotate.handles": "", "preferences.binding.handles": "", "preferences.clone.handles": "", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": "", "export.as": "", "select.all": "", "select.none": "", delete: "", "new.project": "", open: "", save: "", "save.as": "", "upload.media": "", "create.page": "", "new.page": "", "page.name": "", duplicate: "", cancel: "", "copy.invite.link": "", "create.multiplayer.project": "", "copy.multiplayer.project": "", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "", "unlock.aspect.ratio": "", group: "", ungroup: "", "move.to.back": "", "move.backward": "", "move.forward": "", "move.to.front": "", "reset.angle": "", lock: "", unlock: "", "move.to.page": "", "flip.horizontal": "", "flip.vertical": "", move: "", "to.front": "", forward: "", backward: "", back: "", language: "", "keyboard.shortcuts": "", "translation.link": "", page: "", "dock.position": "", bottom: "", left: "", right: "", top: "", "export.background": "", transparent: "", auto: "", light: "", dark: "", "copy.readonly.link": "", image: "", "align.distribute": " / ", "dialog.save.firsttime": "", "dialog.save.again": "", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "" } }, { locale: "zh-tw", label: " ()", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": "", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": "", "zoom.to.selection": "", "zoom.to.fit": "", "zoom.to": "", "preferences.dark.mode": "", "preferences.focus.mode": "", "preferences.debug.mode": "", "preferences.show.grid": "", "preferences.use.cad.selection": " CAD ", "preferences.keep.stylemenu.open": "", "preferences.always.show.snaps": "", "preferences.rotate.handles": "", "preferences.binding.handles": "", "preferences.clone.handles": "", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": "", "export.as": "", "select.all": "", "select.none": "", delete: "", "new.project": "", open: "", save: "", "save.as": "", "upload.media": "", "create.page": "", "new.page": "", "page.name": "", duplicate: "", cancel: "", "copy.invite.link": "", "copy.readonly.link": "", "create.multiplayer.project": "", "copy.multiplayer.project": "", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "", "unlock.aspect.ratio": "", group: "", ungroup: "", "move.to.back": "", "move.backward": "", "move.forward": "", "move.to.front": "", "reset.angle": "", lock: "", unlock: "", "move.to.page": "", "flip.horizontal": "", "flip.vertical": "", move: "", "to.front": "", forward: "", backward: "", back: "", language: "", "translation.link": "", "dock.position": "", bottom: "", left: "", right: "", top: "", page: "" } }, { locale: "th", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": "", "style.menu.size": "", "style.menu.keep.open": "", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": "", "zoom.out": "", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": "", "menu.sign.out": "", "become.a.sponsor": "", "zoom.to.content": "", "zoom.to.selection": "", "zoom.to.fit": "", "zoom.to": "", "preferences.dark.mode": "", "preferences.focus.mode": "", "preferences.debug.mode": "", "preferences.show.grid": "", "preferences.use.cad.selection": " CAD", "preferences.keep.stylemenu.open": "", "preferences.always.show.snaps": "", "preferences.rotate.handles": "", "preferences.binding.handles": "", "preferences.clone.handles": "", undo: "", redo: "", cut: "", copy: "", paste: "", "copy.as": "", "export.as": "", "select.all": "", "select.none": "", delete: "", "new.project": "", open: "", save: "", "save.as": "", "upload.media": "", "create.page": "", "new.page": "", "page.name": "", duplicate: "", cancel: "", "copy.invite.link": "", "copy.readonly.link": "", "create.multiplayer.project": "", "copy.multiplayer.project": "", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "", "unlock.aspect.ratio": "", group: "", ungroup: "", "move.to.back": "", "move.backward": "", "move.forward": "", "move.to.front": "", "reset.angle": "", lock: "", unlock: "", "align.distribute": " / ", "move.to.page": "", "flip.horizontal": "", "flip.vertical": "", move: "", "to.front": "", forward: "", backward: "", back: "", language: "", "translation.link": "", "dock.position": "", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": "", search: "", loading: "{dots}", "export.background": "", transparent: "", auto: "", light: "", dark: "", github: "Github", twitter: "Twitter", discord: "Discord", image: "", "align.left": "", "align.center.x": "", "align.right": "", "align.top": "", "align.center.y": "", "align.bottom": "", "distribute.x": "", "distribute.y": "", "stretch.x": "", "stretch.y": "", "dialog.save.firsttime": "?", "dialog.save.again": "?", "dialog.cancel": "", "dialog.no": "", "dialog.yes": "", "enter.file.name": "" } }, { locale: "ku", label: "", messages: { "style.menu.color": "", "style.menu.fill": "", "style.menu.dash": " ", "style.menu.size": "", "style.menu.keep.open": "  ", "style.menu.font": "", "style.menu.align": "", styles: "", "zoom.in": " ", "zoom.out": " ", to: "", "menu.tools": "", "menu.transform": "", "menu.file": "", "menu.edit": "", "menu.view": "", "menu.preferences": "", "menu.sign.in": " ", "menu.sign.out": "", "become.a.sponsor": " ", "zoom.to.content": "   ", "zoom.to.selection": "   ", "zoom.to.fit": "     ", "zoom.to": "  ", "preferences.dark.mode": " ", "preferences.focus.mode": " ", "preferences.debug.mode": " ", "preferences.show.grid": "  ", "preferences.use.cad.selection": " CAD ", "preferences.keep.stylemenu.open": "    ", "preferences.always.show.snaps": "    ", "preferences.rotate.handles": " ", "preferences.binding.handles": " ", "preferences.clone.handles": "  ", undo: " ", redo: " ", cut: "", copy: " ", paste: " ", "copy.as": " ", "export.as": " ", "select.all": " ", "select.none": " ", delete: "", "new.project": " ", open: "", save: "", "save.as": " ", "upload.media": " ", "create.page": " ", "new.page": " ", "page.name": " ", duplicate: "", cancel: "", "copy.invite.link": "   ", "copy.readonly.link": "    ", "create.multiplayer.project": "   ", "copy.multiplayer.project": "     ", select: "", eraser: "", draw: "", arrow: "", text: "", sticky: "", rectangle: "", ellipse: "", triangle: "", line: "", rotate: "", "lock.aspect.ratio": "  ", "unlock.aspect.ratio": "  ", group: "", ungroup: " ", "move.to.back": "  ", "move.backward": " ", "move.forward": " ", "move.to.front": "  ", "reset.angle": " ", lock: "", unlock: " ", "move.to.page": "  ", "flip.horizontal": " ", "flip.vertical": " ", move: "", "to.front": " ", forward: "", backward: "", back: "", language: "", "translation.link": " ", "dock.position": " ", bottom: "", left: "", right: "", top: "", page: "", "keyboard.shortcuts": " ", search: "", loading: "", "export.background": " ", transparent: "", auto: "", light: "", dark: "" } }]; gC.sort(((e, t) => e.locale < t.locale ? -1 : 1)); var vC = A.createContext({}), yC = () => { let e = A.useContext(vC); if (!e) throw new Error("useCtx must be inside a Provider with a value"); return e }, bC = A.forwardRef(((e, t) => { var n = e, { onSelect: r, onClick: i, onDoubleClick: o, variant: a, children: s, isToolLocked: l = !1, disabled: c = !1, isActive: u = !1, onKeyDown: d, id: p } = n, h = SE(n, ["onSelect", "onClick", "onDoubleClick", "variant", "children", "isToolLocked", "disabled", "isActive", "onKeyDown", "id"]); return A.createElement(CC, EE({ ref: t, isActive: u, variant: a, onClick: i, disabled: c, onPointerDown: r, onDoubleClick: o, onKeyDown: d, bp: OE, id: p }, h), A.createElement(EC, null, s), l && A.createElement(SC, null)) })); function wC(e) { var t = e, { label: n, kbd: r, variant: i, isLocked: o } = t, a = SE(t, ["label", "kbd", "variant", "isLocked"]); let s = pC(), l = A.useCallback((() => { s.toggleToolLock() }), []), c = A.useCallback((e => { " " === e.key && s.isForcePanning && e.preventDefault() }), []); return A.createElement(NE, { label: n[0].toUpperCase() + n.slice(1), kbd: r }, A.createElement(bC, CE(EE({}, a), { variant: i, isToolLocked: o && a.isActive, onDoubleClick: l, onKeyDown: c, "aria-label": n[0].toUpperCase() + n.slice(1) }))) } var EC = AE("div", { position: "relative", height: "100%", width: "100%", backgroundColor: "$panel", borderRadius: "$2", margin: "0", display: "flex", alignItems: "center", justifyContent: "center", fontFamily: "$ui", color: "inherit", userSelect: "none", WebkitUserSelect: "none", boxSizing: "border-box", border: "1px solid transparent", "-webkit-tap-highlight-color": "transparent", "tap-highlight-color": "transparent" }), CC = AE("button", { position: "relative", color: "$text", fontSize: "$0", background: "none", margin: "0", padding: "$2", display: "flex", alignItems: "center", justifyContent: "center", outline: "none", cursor: "pointer", pointerEvents: "all", height: "40px", width: "40px", border: "1px solid $panel", "-webkit-tap-highlight-color": "transparent", "tap-highlight-color": "transparent", [`&:disabled ${EC}`]: { opacity: .618 }, variants: { variant: { primary: { marginTop: "0" }, icon: { [`& ${EC}`]: { display: "grid", "& > *": { gridRow: 1, gridColumn: 1 } } }, text: { width: "auto", [`& ${EC}`]: { fontSize: "$1", padding: "0 $3", gap: "$3" } }, circle: { padding: 0, height: 32, width: 32, border: "none", [`& ${EC}`]: { border: "1px solid $panelContrast", borderRadius: "100%", boxShadow: "$panel" }, [`& ${EC} > svg`]: { width: 14, height: 14 } } }, isActive: { true: {}, false: {} }, bp: { mobile: { padding: 0 }, small: {} } }, compoundVariants: [{ variant: "primary", bp: "mobile", css: { height: 40, width: 36, [`& ${EC} > svg`]: { width: 16, height: 16 } } }, { variant: "primary", bp: "small", css: { height: "40px", width: "40px", [`& ${EC} > svg`]: { width: 20, height: 20 } } }, { isActive: !0, css: { [`${EC}`]: { backgroundColor: "$selected", color: "$selectedContrast" } } }, { isActive: !1, bp: "small", css: { [`&:hover:not(:disabled) ${EC}`]: { backgroundColor: "$hover" }, [`&:focus:not(:disabled) ${EC}`]: { backgroundColor: "$hover" } } }] }), SC = AE("div", { position: "absolute", width: 10, height: 10, backgroundColor: "$selected", borderRadius: "100%", bottom: -2, border: "2px solid $panel", zIndex: 100 }), kC = e => e.document.pageStates[e.appState.currentPageId].selectedIds.length, xC = e => e.settings.isDebugMode, AC = e => e.document.pageStates[e.appState.currentPageId].selectedIds.some((t => void 0 !== e.document.pages[e.appState.currentPageId].shapes[t].children)), IC = e => e.stopPropagation(), PC = A.memo((function () { let e = pC(), t = Qp(), n = e.useStore(kC), r = e.useStore(xC), i = e.useStore(AC), o = A.useCallback((() => { e.flipHorizontal() }), [e]), a = A.useCallback((() => { e.flipVertical() }), [e]), s = A.useCallback((() => { e.duplicate() }), [e]), l = A.useCallback((() => { e.toggleLocked() }), [e]), c = A.useCallback((() => { e.group() }), [e]), u = A.useCallback((() => { e.moveToBack() }), [e]), d = A.useCallback((() => { e.moveBackward() }), [e]), p = A.useCallback((() => { e.moveForward() }), [e]), h = A.useCallback((() => { e.moveToFront() }), [e]), f = A.useCallback((() => { e.delete() }), [e]), m = A.useCallback((() => { e.cut() }), [e]), g = A.useCallback((() => { e.copy() }), [e]), v = A.useCallback((() => { e.paste() }), [e]), y = A.useCallback((() => { e.copyImage("svg", { scale: 1, quality: 1, transparentBackground: !1 }) }), [e]), b = A.useCallback((() => { e.copyImage("png", { scale: 2, quality: 1, transparentBackground: !0 }) }), [e]), w = A.useCallback((() => { e.undo() }), [e]), E = A.useCallback((() => { e.redo() }), [e]), C = A.useCallback((() => xE(this, null, (function* () { e.exportImage("png", { scale: 2, quality: 1 }) }))), [e]), S = A.useCallback((() => xE(this, null, (function* () { e.exportImage("jpeg", { scale: 2, quality: 1 }) }))), [e]), k = A.useCallback((() => xE(this, null, (function* () { e.exportImage("webp", { scale: 2, quality: 1 }) }))), [e]), x = A.useCallback((() => xE(this, null, (function* () { e.exportImage("svg", { scale: 1, quality: 1 }) }))), [e]), I = A.useCallback((() => xE(this, null, (function* () { e.copyJson() }))), [e]), P = A.useCallback((() => xE(this, null, (function* () { e.exportJson() }))), [e]), M = n > 0, T = n > 1, R = n > 2; return A.createElement(A.Fragment, null, M ? A.createElement(A.Fragment, null, A.createElement(zC, { onClick: s, kbd: "#D", id: "TD-ContextMenu-Duplicate" }, A.createElement($p, { id: "duplicate" })), A.createElement(zC, { onClick: o, kbd: "H", id: "TD-ContextMenu-Flip_Horizontal" }, A.createElement($p, { id: "flip.horizontal" })), A.createElement(zC, { onClick: a, kbd: "V", id: "TD-ContextMenu-Flip_Vertical" }, A.createElement($p, { id: "flip.vertical" })), A.createElement(zC, { onClick: l, kbd: "#L", id: "TD-ContextMenu- Lock_Unlock" }, A.createElement($p, { id: "lock" }), " / ", A.createElement($p, { id: "unlock" })), (T || i) && A.createElement(ME, null), T && A.createElement(zC, { onClick: c, kbd: "#G", id: "TD-ContextMenu-Group" }, A.createElement($p, { id: "group" })), i && A.createElement(zC, { onClick: c, kbd: "#G", id: "TD-ContextMenu-Ungroup" }, A.createElement($p, { id: "ungroup" })), A.createElement(ME, null), A.createElement(LC, { label: t.formatMessage({ id: "move" }), id: "TD-ContextMenu-Move" }, A.createElement(zC, { onClick: h, kbd: "]", id: "TD-ContextMenu-Move-To_Front" }, A.createElement($p, { id: "to.front" })), A.createElement(zC, { onClick: p, kbd: "]", id: "TD-ContextMenu-Move-Forward" }, A.createElement($p, { id: "forward" })), A.createElement(zC, { onClick: d, kbd: "[", id: "TD-ContextMenu-Move-Backward" }, A.createElement($p, { id: "backward" })), A.createElement(zC, { onClick: u, kbd: "[", id: "TD-ContextMenu-Move-To_Back" }, A.createElement($p, { id: "back" }))), A.createElement(DC, null), T && A.createElement(MC, { hasTwoOrMore: T, hasThreeOrMore: R }), A.createElement(ME, null), A.createElement(zC, { onClick: m, kbd: "#X", id: "TD-ContextMenu-Cut" }, A.createElement($p, { id: "cut" })), A.createElement(zC, { onClick: g, kbd: "#C", id: "TD-ContextMenu-Copy" }, A.createElement($p, { id: "copy" })), A.createElement(zC, { onClick: v, kbd: "#V", id: "TD-ContextMenu-Paste" }, A.createElement($p, { id: "paste" })), A.createElement(ME, null), A.createElement(LC, { label: `${t.formatMessage({ id: "copy.as" })}...`, size: "small", id: "TD-ContextMenu-Copy-As" }, A.createElement(zC, { onClick: y, id: "TD-ContextMenu-Copy-as-SVG" }, "SVG"), A.createElement(zC, { onClick: b, id: "TD-ContextMenu-Copy-As-PNG" }, "PNG"), r && A.createElement(zC, { onClick: I, id: "TD-ContextMenu-Copy_as_JSON" }, "JSON")), A.createElement(LC, { label: `${t.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-ContextMenu-Export" }, A.createElement(zC, { onClick: x, id: "TD-ContextMenu-Export-SVG" }, "SVG"), A.createElement(zC, { onClick: C, id: "TD-ContextMenu-Export-PNG" }, "PNG"), A.createElement(zC, { onClick: S, id: "TD-ContextMenu-Export-JPG" }, "JPG"), A.createElement(zC, { onClick: k, id: "TD-ContextMenu-Export-WEBP" }, "WEBP"), r && A.createElement(zC, { onClick: P, id: "TD-ContextMenu-Export-JSON" }, "JSON")), A.createElement(ME, null), A.createElement(zC, { onClick: f, kbd: "", id: "TD-ContextMenu-Delete" }, A.createElement($p, { id: "delete" }))) : A.createElement(A.Fragment, null, A.createElement(zC, { onClick: v, kbd: "#V", id: "TD-ContextMenu-Paste" }, A.createElement($p, { id: "paste" })), A.createElement(zC, { onClick: w, kbd: "#Z", id: "TD-ContextMenu-Undo" }, A.createElement($p, { id: "undo" })), A.createElement(zC, { onClick: E, kbd: "#Z", id: "TD-ContextMenu-Redo" }, A.createElement($p, { id: "redo" })), A.createElement(LC, { label: `${t.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-ContextMenu-Export" }, A.createElement(zC, { onClick: x, id: "TD-ContextMenu-Export-SVG" }, "SVG"), A.createElement(zC, { onClick: C, id: "TD-ContextMenu-Export-PNG" }, "PNG"), A.createElement(zC, { onClick: S, id: "TD-ContextMenu-Export-JPG" }, "JPG"), A.createElement(zC, { onClick: k, id: "TD-ContextMenu-Export-WEBP" }, "WEBP"), r && A.createElement(zC, { onClick: P, id: "TD-ContextMenu-Export-JSON" }, "JSON")))) })); function MC({ hasThreeOrMore: e }) { let t = pC(), n = A.useCallback((() => { t.align("top") }), [t]), r = A.useCallback((() => { t.align("centerVertical") }), [t]), i = A.useCallback((() => { t.align("bottom") }), [t]), o = A.useCallback((() => { t.stretch("vertical") }), [t]), a = A.useCallback((() => { t.distribute("vertical") }), [t]), s = A.useCallback((() => { t.align("left") }), [t]), l = A.useCallback((() => { t.align("centerHorizontal") }), [t]), c = A.useCallback((() => { t.align("right") }), [t]), u = A.useCallback((() => { t.stretch("horizontal") }), [t]), d = A.useCallback((() => { t.distribute("horizontal") }), [t]), p = fC(); return A.createElement(nd, null, A.createElement(HC, { id: "TD-ContextMenu-Align-Distribute-Trigger" }, A.createElement($p, { id: "align.distribute" })), A.createElement(ed, { container: p.current }, A.createElement(id, { asChild: !0, sideOffset: 4, alignOffset: -2 }, A.createElement(TC, { numberOfSelected: e ? "threeOrMore" : "twoOrMore" }, A.createElement(FC, { onClick: s, id: "TD-ContextMenu-Align_Distribute-AlignLeft" }, A.createElement(hd, null)), A.createElement(FC, { onClick: l, id: "TD-ContextMenu-Align_Distribute-AlignCenterHorizontal" }, A.createElement(cd, null)), A.createElement(FC, { onClick: c, id: "TD-ContextMenu-Align_Distribute-AlignRight" }, A.createElement(md, null)), A.createElement(FC, { onClick: u, id: "TD-ContextMenu-Align_Distribute-StretchHorizontal" }, A.createElement(Dp, null)), e && A.createElement(FC, { onClick: d, id: "TD-ContextMenu-Align_Distribute-SpaceEvenlyHorizontal" }, A.createElement(Ip, null)), A.createElement(FC, { onClick: n, id: "TD-ContextMenu-Align_Distribute-AlignTop" }, A.createElement(vd, null)), A.createElement(FC, { onClick: r, id: "TD-ContextMenu-Align_Distribute-AlignCenterVertical" }, A.createElement(dd, null)), A.createElement(FC, { onClick: i, id: "TD-ContextMenu-Align_Distribute-AlignBottom" }, A.createElement(sd, null)), A.createElement(FC, { onClick: o, id: "TD-ContextMenu-Align_Distribute-StretchVertical" }, A.createElement(Op, null)), e && A.createElement(FC, { onClick: a, id: "TD-ContextMenu-Align_Distribute-SpaceEvenlyVertical" }, A.createElement(Mp, null)), A.createElement(OC, { offset: 13 }))))) } var TC = AE(TE, { display: "grid", variants: { numberOfSelected: { threeOrMore: { gridTemplateColumns: "repeat(5, auto)" }, twoOrMore: { gridTemplateColumns: "repeat(4, auto)" } } } }), RC = e => e.appState.currentPageId, BC = e => e.document.pages; function DC() { let e = pC(), t = e.useStore(RC), n = e.useStore(BC), r = Object.values(n).sort(((e, t) => (e.childIndex || 0) - (t.childIndex || 0))).filter((e => e.id !== t)), i = fC(); return 0 === r.length ? null : A.createElement(nd, null, A.createElement(HC, null, A.createElement($p, { id: "move.to.page" })), A.createElement(ed, { container: i.current }, A.createElement(id, { sideOffset: 4, alignOffset: -2, asChild: !0 }, A.createElement(TE, null, r.map((({ id: n, name: r }, i) => A.createElement(zC, { key: n, disabled: n === t, onClick: () => e.moveToPage(n) }, r || `Page ${i}`))), A.createElement(OC, { offset: 13 }))))) } function LC({ children: e, label: t, size: n, id: r }) { let i = fC(); return A.createElement(nd, null, A.createElement(HC, null, t), A.createElement(ed, { container: i.current }, A.createElement(id, { sideOffset: 4, alignOffset: -2, asChild: !0 }, A.createElement(TE, { size: n }, e, A.createElement(OC, { offset: 13 }))))) } var OC = AE(Qu, { fill: "$panel" }); function FC(e) { var t = e, { onSelect: n } = t, r = SE(t, ["onSelect"]); return A.createElement(_u, { dir: "ltr", onSelect: n, asChild: !0 }, A.createElement(bC, EE({}, r))) } var zC = e => { var t = e, { id: n } = t, r = SE(t, ["id"]); return A.createElement(_u, { asChild: !0, id: n }, A.createElement(FE, EE({}, r))) }, HC = e => { var t = e, { id: n } = t, r = SE(t, ["id"]); return A.createElement(rd, { asChild: !0, id: n }, A.createElement(FE, EE({ hasArrow: !0 }, r))) }, NC = A.memo((({ onBlur: e, children: t }) => { let n = fC(); return A.createElement(Ju, { dir: "ltr" }, A.createElement($u, { dir: "ltr" }, t), A.createElement(ed, { container: n.current }, A.createElement(td, { onEscapeKeyDown: IC, tabIndex: -1, onBlur: e, asChild: !0 }, A.createElement(TE, { id: "TD-ContextMenu" }, A.createElement(PC, null))))) })); function jC({ error: e, resetErrorBoundary: t }) { let n = pC(); return A.createElement(UC, null, A.createElement(VC, null, A.createElement("div", null, "We've encountered an error!"), A.createElement("pre", null, A.createElement("code", null, e.message)), A.createElement(KC, null, A.createElement(FE, { onClick: () => { let t = document.createElement("textarea"); t.value = e.message, document.body.appendChild(t), t.select(), document.execCommand("copy"), t.remove() } }, "Copy Error"), A.createElement(FE, { onClick: () => { window.location.reload(), t() } }, "Refresh Page")), A.createElement(ME, null), A.createElement("p", null, "Keep getting this error?", " ", A.createElement("a", { onClick: () => { n.saveProjectAs() }, title: "Download your project" }, "Download your project"), " ", "as a backup and then", " ", A.createElement("a", { onClick: () => { n.resetDocument(), t() }, title: "Reset the document" }, "reset the document"), "."))) } var UC = AE("div", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", backgroundColor: "$canvas" }), VC = AE("div", { backgroundColor: "$panel", border: "1px solid $panelContrast", padding: "$5", borderRadius: 8, boxShadow: "$panel", maxWidth: 320, color: "$text", fontFamily: "$ui", fontSize: "$2", textAlign: "center", display: "flex", flexDirection: "column", gap: "$3", "& > pre": { marginTop: "$3", marginBottom: "$3", textAlign: "left", whiteSpace: "pre-wrap", backgroundColor: "$hover", padding: "$4", borderRadius: "$2", fontFamily: '"Menlo", "Monaco", monospace', fontWeight: 500 }, "& p": { fontFamily: "$body", lineHeight: 1.7, padding: "$5", margin: 0 }, "& a": { color: "$text", cursor: "pointer", textDecoration: "underline" }, "& hr": { marginLeft: "-$5", marginRight: "-$5" } }), KC = AE("div", { display: "flex", "& > button > div": { justifyContent: "center", textAlign: "center" } }), WC = AE("button", { position: "relative", height: "32px", width: "32px", backgroundColor: "$panel", borderRadius: "4px", padding: "0", margin: "0", outline: "none", border: "none", pointerEvents: "all", fontSize: "$0", color: "$text", cursor: "pointer", display: "grid", alignItems: "center", justifyContent: "center", "& > *": { gridRow: 1, gridColumn: 1 }, "&:disabled": { opacity: "0.5" }, "& > span": { width: "100%", height: "100%", display: "flex", alignItems: "center" }, variants: { bp: { mobile: { backgroundColor: "transparent" }, small: { "&:hover:not(:disabled)": { backgroundColor: "$hover" } } }, size: { small: { height: 32, width: 32, "& svg:nth-of-type(1)": { height: "16px", width: "16px" } }, medium: { height: 44, width: 44, "& svg:nth-of-type(1)": { height: "18px", width: "18px" } }, large: { height: 44, width: 44, "& svg:nth-of-type(1)": { height: "20px", width: "20px" } } }, isActive: { true: { color: "$selected" } } } }); function YC({ onSelect: e }) { return A.createElement(GC, null, A.createElement(WC, { onClick: e }, A.createElement(Yd, null))) } var GC = AE("div", { opacity: 1, zIndex: 100, backgroundColor: "transparent", "& svg": { color: "$text" }, "&:hover svg": { color: "$text" } }), ZC = e => e.appState.isLoading; function XC() { let e = pC().useStore(ZC); return A.createElement(_C, { hidden: !e }, A.createElement($p, { id: "loading", values: { dots: "..." } })) } var _C = AE("div", { position: "absolute", top: 0, left: "50%", transform: "translate(-50%, 0)", borderBottomLeftRadius: "12px", borderBottomRightRadius: "12px", padding: "8px 16px", fontFamily: "var(--fonts-ui)", fontSize: "var(--fontSizes-1)", boxShadow: "var(--shadows-panel)", backgroundColor: "white", zIndex: 200, pointerEvents: "none", "& > div > *": { pointerEvents: "all" }, variants: { transform: { hidden: { transform: "translate(-50%, 100%)" }, visible: { transform: "translate(-50%, 0%)" } } } }), QC = AE(bb, { marginBottom: 20, color: "$text", fontSize: "$2", lineHeight: 1.5, textAlign: "center", maxWidth: "62%", minWidth: 0, alignSelf: "center" }), qC = pb, JC = function ({ children: e, onClose: t, container: n }) { return A.createElement(fb, { container: n }, A.createElement(rS, null), A.createElement(iS, { onKeyDown: e => { "Escape" === e.key && (null == t || t()) } }, e)) }, $C = QC, eS = vb, tS = yb, nS = ({ container: e }) => { let { setDialogState: t, dialogState: n, onCancel: r, onNo: i, onYes: o } = yC(), a = Qp(), s = { saveFirstTime: a.formatMessage({ id: "dialog.save.firsttime" }), saveAgain: a.formatMessage({ id: "dialog.save.again" }) }; return A.createElement(qC, { open: null !== n }, A.createElement(JC, { onClose: () => t(null), container: e }, n && A.createElement($C, null, s[n]), A.createElement("div", { style: { width: "100%", gap: "$6", display: "flex", justifyContent: "space-between" } }, r && A.createElement(tS, { asChild: !0 }, A.createElement(oS, { css: { color: "$text" }, onClick: () => { r(), t(null) } }, A.createElement($p, { id: "dialog.cancel" }))), A.createElement("div", { style: { flexShrink: 0 } }, i && A.createElement(eS, { asChild: !0 }, A.createElement(oS, { onClick: () => { i(), t(null) } }, A.createElement($p, { id: "dialog.no" }))), o && A.createElement(eS, { asChild: !0 }, A.createElement(oS, { css: { backgroundColor: "#2F80ED", color: "White" }, onClick: () => { o(), t(null) } }, A.createElement($p, { id: "dialog.yes" }))))))) }, rS = AE(mb, { position: "fixed", inset: 0, backgroundColor: "rgba(0, 0, 0, .15)", pointerEvents: "all" }), iS = (AE(mb, { backgroundColor: "rgba(0, 0, 0, .15)", position: "absolute", pointerEvents: "all", inset: 0 }), AE(gb, { position: "fixed", font: "$ui", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "max-content", padding: "$3", pointerEvents: "all", backgroundColor: "$panel", borderRadius: "$3", display: "flex", flexDirection: "column", justifyContent: "center", fontFamily: "$ui", border: "1px solid $panelContrast", boxShadow: "$panel" })), oS = AE("button", { all: "unset", display: "inline-flex", alignItems: "center", justifyContent: "center", borderRadius: "$2", padding: "0 15px", fontSize: "$1", lineHeight: 1, fontWeight: "normal", height: 36, color: "$text", cursor: "pointer", minWidth: 48 }), aS = A.forwardRef(((e, t) => { var n = e, { icon: r } = n, i = SE(n, ["icon"]); return A.createElement(sS, null, A.createElement(lS, CE(EE({}, i), { ref: t })), r ? A.createElement(cS, null, r) : null) })), sS = AE("div", { position: "relative", width: "100%", height: "min-content" }), lS = AE("input", { color: "$text", border: "none", textAlign: "left", width: "100%", paddingLeft: "$3", paddingRight: "$6", backgroundColor: "$background", height: "32px", outline: "none", fontFamily: "$ui", fontSize: "$1", "&:focus": { backgroundColor: "$hover" }, borderRadius: "$2" }), cS = AE(LE, { top: 0, right: 0, position: "absolute", paddingLeft: "$3", paddingRight: "$3", pointerEvents: "none", color: "$text" }), uS = ({ isOpen: e, onClose: t }) => { let n = pC(), r = fC(), i = Qp(), [o, a] = A.useState(n.document.name), s = A.useCallback((e => { let t = e.target.value.trimStart(); a(t) }), []); function l(e) { e.stopPropagation() } let c = A.useCallback((e => { switch (e.key) { case "Enter": n.saveProjectAs(o), t(); break; case "Escape": t() } }), []); return A.createElement(pb, { open: e }, A.createElement(fb, { container: r.current }, A.createElement(pS, { onPointerDown: t }), A.createElement(dS, { dir: "ltr", onKeyDown: l, onKeyUp: l }, A.createElement(fS, { placeholder: i.formatMessage({ id: "enter.file.name" }), value: o, onChange: s, onKeyDown: c, icon: A.createElement(hp, null) }), A.createElement(hS, null, A.createElement(vb, { asChild: !0 }, A.createElement(oS, { onClick: t }, A.createElement($p, { id: "cancel" }))), A.createElement(vb, { asChild: !0 }, A.createElement(oS, { css: { backgroundColor: "#2F80ED", color: "White" }, onClick: () => { let e = o.trim().replace(/\.tldr$/, ""); n.saveProjectAs(e), t() } }, A.createElement($p, { id: "save" }))))))) }, dS = AE(gb, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", minWidth: 300, maxWidth: "fit-content", maxHeight: "85vh", marginTop: "-5vh", pointerEvents: "all", backgroundColor: "$panel", padding: "$3", borderRadius: "$2", font: "$ui", zIndex: 999999, "&:focus": { outline: "none" } }), pS = AE(mb, { backgroundColor: "rgba(0, 0, 0, .15)", position: "absolute", pointerEvents: "all", inset: 0, zIndex: 999998 }), hS = AE("div", { width: "100%", display: "flex", alignItems: "center", gap: 8, justifyContent: "flex-end", marginTop: 10 }), fS = AE(aS, { background: "$hover" }); function mS(e) { var t = e, { onSelect: n, id: r } = t, i = SE(t, ["onSelect", "id"]); return A.createElement(Af, { dir: "ltr", asChild: !0, onSelect: n, id: r }, A.createElement(FE, EE({}, i))) } var gS = e => e.preventDefault(); function vS({ checked: e, disabled: t = !1, variant: n, onCheckedChange: r, kbd: i, id: o, ariaLabel: a, children: s }) { return A.createElement(If, { dir: "ltr", onSelect: gS, onCheckedChange: r, checked: e, disabled: t, asChild: !0, id: o, "aria-label": a }, A.createElement(FE, { kbd: i, variant: n, hasIndicator: !0 }, s)) } var yS = e => e.stopPropagation(); function bS({ sideOffset: e = 4, alignOffset: t = 0, children: n, align: r, variant: i, id: o, overflow: a = !1, side: s = "bottom" }) { let l = fC(); return A.createElement(kf, { container: l.current, dir: "ltr" }, A.createElement(xf, { align: r, alignOffset: t, sideOffset: e, onEscapeKeyDown: yS, asChild: !0, id: o, side: s }, A.createElement(wS, { variant: i, overflow: a }, n))) } var wS = AE(TE, { width: "fit-content", height: "fit-content", minWidth: 0, maxHeight: "100vh", overflowY: "auto", overflowX: "hidden", "&::webkit-scrollbar": { display: "none" }, "-ms-overflow-style": "none", scrollbarWidth: "none", variants: { variant: { horizontal: { flexDirection: "row" }, menu: { minWidth: 128 } }, overflow: { true: { maxHeight: "60vh" } } } }), ES = (AE(Rf, { backgroundColor: "$hover", height: 1, marginTop: "$2", marginRight: "-$2", marginBottom: "$2", marginLeft: "-$2" }), AE(Mf, { height: "32px", width: "32px", backgroundColor: "$panel", borderRadius: "4px", padding: "0", margin: "0", display: "flex", alignItems: "center", justifyContent: "center", outline: "none", border: "none", pointerEvents: "all", cursor: "pointer", variants: { isActive: { true: { backgroundColor: "$selected", color: "white" }, false: {} }, bp: { mobile: {}, small: {} } }, compoundVariants: [{ isActive: !1, bp: "small", css: { "&:focus": { backgroundColor: "$hover" }, "&:hover:not(:disabled)": { backgroundColor: "$hover" } } }] })); function CS({ children: e, size: t, overflow: n = !1, disabled: r = !1, label: i, id: o }) { return A.createElement(Df, { key: o }, A.createElement(Lf, { dir: "ltr", asChild: !0 }, A.createElement(FE, { disabled: r, hasArrow: !0 }, i)), A.createElement(Of, { asChild: !0, sideOffset: 4, alignOffset: -4 }, A.createElement(TE, { size: t, overflow: n }, e, A.createElement(Bf, { offset: 13 })))) } function SS(e) { var t = e, { id: n, children: r } = t, i = SE(t, ["id", "children"]); return A.createElement(Sf, { asChild: !0, id: n }, A.createElement(bC, EE({}, i), r)) } var kS = e => e.settings.dockPosition, xS = e => e.document.pageStates[e.appState.currentPageId].selectedIds.length, AS = e => { let t = e.document.pages[e.appState.currentPageId], { selectedIds: n } = e.document.pageStates[e.appState.currentPageId]; return n.every((e => t.shapes[e].isLocked)) }, IS = e => { let t = e.document.pages[e.appState.currentPageId], { selectedIds: n } = e.document.pageStates[e.appState.currentPageId]; return n.every((e => t.shapes[e].isAspectRatioLocked)) }, PS = e => { let t = e.document.pages[e.appState.currentPageId], n = e.document.pageStates[e.appState.currentPageId].selectedIds.map((e => t.shapes[e])); return n.every((t => void 0 !== t.children || t.parentId === n[0].parentId && n[0].parentId !== e.appState.currentPageId)) }, MS = e => { let { selectedIds: t } = e.document.pageStates[e.appState.currentPageId]; return t.length > 0 }, TS = e => { let { selectedIds: t } = e.document.pageStates[e.appState.currentPageId]; return t.length > 1 }; function RS() { let e = pC(), t = Qp(), n = e.useStore(AS), r = e.useStore(IS), i = e.useStore(PS), o = e.useStore(MS), a = e.useStore(TS), s = e.useStore(xS), l = e.useStore(kS), c = s > 1, u = s > 2, d = A.useCallback((() => { e.rotate() }), [e]), p = A.useCallback((() => { e.duplicate() }), [e]), h = A.useCallback((() => { e.toggleLocked() }), [e]), f = A.useCallback((() => { e.toggleAspectRatioLocked() }), [e]), m = A.useCallback((() => { e.group() }), [e]), g = A.useCallback((() => { e.moveToBack() }), [e]), v = A.useCallback((() => { e.moveBackward() }), [e]), y = A.useCallback((() => { e.moveForward() }), [e]), b = A.useCallback((() => { e.moveToFront() }), [e]), w = A.useCallback((() => { e.setShapeProps({ rotation: 0 }) }), [e]), E = A.useCallback((() => { e.align("top") }), [e]), C = A.useCallback((() => { e.align("centerVertical") }), [e]), S = A.useCallback((() => { e.align("bottom") }), [e]), k = A.useCallback((() => { e.stretch("vertical") }), [e]), x = A.useCallback((() => { e.distribute("vertical") }), [e]), I = A.useCallback((() => { e.align("left") }), [e]), P = A.useCallback((() => { e.align("centerHorizontal") }), [e]), M = A.useCallback((() => { e.align("right") }), [e]), T = A.useCallback((() => { e.stretch("horizontal") }), [e]), R = A.useCallback((() => { e.distribute("horizontal") }), [e]), B = A.useCallback((t => { e.setMenuOpen(t) }), [e]), D = "bottom" === l || "top" === l ? "top" : l; return A.createElement(Cf, { dir: "ltr", onOpenChange: B }, A.createElement(Sf, { dir: "ltr", asChild: !0, id: "TD-Tools-Dots" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "shape.options" }), variant: "circle" }, A.createElement(Zd, null))), A.createElement(bS, { sideOffset: 16, side: D }, A.createElement(A.Fragment, null, A.createElement(BS, null, A.createElement(NE, { label: t.formatMessage({ id: "duplicate" }), kbd: "#D", id: "TD-Tools-Copy" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "duplicate" }), disabled: !o, onClick: p }, A.createElement(Nd, null))), A.createElement(NE, { label: t.formatMessage({ id: "rotate" }), id: "TD-Tools-Rotate" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "rotate" }), disabled: !o, onClick: d }, A.createElement(xp, null))), A.createElement(NE, { label: t.formatMessage({ id: n ? "unlock" : "lock" }), kbd: "#L", id: "TD-Tools-Lock" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: n ? "unlock" : "lock" }), disabled: !o, onClick: h }, n ? A.createElement(sp, null) : A.createElement(cp, null))), A.createElement(NE, { label: t.formatMessage({ id: r ? "unlock.aspect.ratio" : "lock.aspect.ratio" }), id: "TD-Tools-AspectRatio" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: r ? "unlock.aspect.ratio" : "lock.aspect.ratio" }), disabled: !o, onClick: f }, r ? A.createElement(Id, null) : A.createElement(Md, null))), A.createElement(NE, { label: t.formatMessage({ id: "group" }), kbd: "#G", id: "TD-Tools-Group" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "group" }), disabled: !o || !i && !a, onClick: m }, A.createElement($d, null)))), A.createElement(BS, null, A.createElement(NE, { label: t.formatMessage({ id: "move.to.back" }), kbd: "#[", id: "TD-Tools-PinBottom" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "move.to.back" }), disabled: !o, onClick: g }, A.createElement(vp, null))), A.createElement(NE, { label: t.formatMessage({ id: "move.backward" }), kbd: "#[", id: "TD-Tools-ArrowDown" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "move.backward" }), disabled: !o, onClick: v }, A.createElement(Ed, null))), A.createElement(NE, { label: t.formatMessage({ id: "move.forward" }), kbd: "#]", id: "TD-Tools-ArrowUp" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "move.forward" }), disabled: !o, onClick: y }, A.createElement(xd, null))), A.createElement(NE, { label: t.formatMessage({ id: "move.to.front" }), kbd: "#]", id: "TD-Tools-PinTop" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "move.to.front" }), disabled: !o, onClick: b }, A.createElement(bp, null))), A.createElement(NE, { label: t.formatMessage({ id: "reset.angle" }), id: "TD-Tools-ResetAngle" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "reset.angle" }), disabled: !o, onClick: w }, A.createElement(bd, null)))), A.createElement(ME, null), A.createElement(BS, null, A.createElement(NE, { label: t.formatMessage({ id: "align.left" }), id: "TD-Tools-AlignLeft" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "align.left" }), disabled: !c, onClick: I }, A.createElement(hd, null))), A.createElement(NE, { label: t.formatMessage({ id: "align.center.x" }), id: "TD-Tools-AlignCenterHorizontal" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "align.center.x" }), disabled: !c, onClick: P }, A.createElement(cd, null))), A.createElement(NE, { label: t.formatMessage({ id: "align.right" }), id: "TD-Tools-AlignRight" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "align.right" }), disabled: !c, onClick: M }, A.createElement(md, null))), A.createElement(NE, { label: t.formatMessage({ id: "stretch.x" }), id: "TD-Tools-StretchHorizontal" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "stretch.x" }), disabled: !c, onClick: T }, A.createElement(Dp, null))), A.createElement(NE, { label: t.formatMessage({ id: "distribute.x" }), id: "TD-Tools-SpaceEvenlyHorizontal" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "distribute.x" }), disabled: !u, onClick: R }, A.createElement(Ip, null)))), A.createElement(BS, null, A.createElement(NE, { label: t.formatMessage({ id: "align.top" }), id: "TD-Tools-AlignTop" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "align.top" }), disabled: !c, onClick: E }, A.createElement(vd, null))), A.createElement(NE, { label: t.formatMessage({ id: "align.center.y" }), id: "TD-Tools-AlignCenterVertical" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "align.center.y" }), disabled: !c, onClick: C }, A.createElement(dd, null))), A.createElement(NE, { label: t.formatMessage({ id: "align.bottom" }), id: "TD-Tools-AlignBottom" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "align.bottom" }), disabled: !c, onClick: S }, A.createElement(sd, null))), A.createElement(NE, { label: t.formatMessage({ id: "stretch.y" }), id: "TD-Tools-StretchVertical" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "stretch.y" }), disabled: !c, onClick: k }, A.createElement(Op, null))), A.createElement(NE, { label: t.formatMessage({ id: "distribute.y" }), id: "TD-Tools-SpaceEvenlyVertical" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "distribute.y" }), disabled: !u, onClick: x }, A.createElement(Mp, null))))))) } var BS = AE("div", { position: "relative", display: "flex", width: "100%", background: "none", border: "none", cursor: "pointer", outline: "none", alignItems: "center", justifyContent: "flex-start", padding: 0 }), DS = e => e.appState.isEmptyCanvas && Object.keys(e.document.pages[e.appState.currentPageId].shapes).length > 0, LS = e => e.settings.isDebugMode, OS = e => e.settings.dockPosition, FS = A.memo((function () { let e = pC(), t = e.useStore(DS), n = e.useStore(OS), r = e.useStore(LS), i = { bottom: "bottom" === n && r ? 120 : "bottom" === n ? 80 : r ? 60 : 20, left: "50%", transform: "translate(-50%,0)" }; return t ? A.createElement(zS, { id: "TD-Tools-Back_to_content", style: EE({}, i) }, A.createElement(FE, { onClick: e.zoomToContent }, A.createElement($p, { id: "zoom.to.content" }))) : null })), zS = AE(TE, { pointerEvents: "all", width: "fit-content", minWidth: 0, position: "fixed", bottom: 0 }); function HS(e) { let t = e, { size: n = 16 } = t, r = SE(t, ["size"]); return A.createElement("svg", EE({ width: 24, height: 24 }, r), A.createElement("circle", { cx: 12, cy: 12, r: n / 2 })) } function NS(e) { return A.createElement("svg", EE({ width: 18, height: 18, viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, e), A.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 4.656a.5.5 0 01.5-.5h9.7a.5.5 0 010 1H2.5a.5.5 0 01-.5-.5z" }), A.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.272 3a.578.578 0 00-.578.578v.578h3.311v-.578A.578.578 0 008.428 3H6.272zm3.733 1.156v-.578A1.578 1.578 0 008.428 2H6.272a1.578 1.578 0 00-1.578 1.578v.578H3.578a.5.5 0 00-.5.5V12.2a1.578 1.578 0 001.577 1.578h5.39a1.578 1.578 0 001.577-1.578V4.656a.5.5 0 00-.5-.5h-1.117zm-5.927 1V12.2a.578.578 0 00.577.578h5.39a.578.578 0 00.577-.578V5.156H4.078z" }), A.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.272 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5zM8.428 6.85a.5.5 0 01.5.5v3.233a.5.5 0 11-1 0V7.35a.5.5 0 01.5-.5z" })) } function jS(e) { var t = e, { flipHorizontal: n } = t, r = SE(t, ["flipHorizontal"]); return A.createElement("svg", EE({ width: 24, height: 24, viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", style: { transform: n ? "scale(-1, 1)" : "scale(1, 1)" } }, r), A.createElement("path", { d: "M10.6707 8.5081C10.6707 10.1923 9.3004 11.5625 7.61631 11.5625H6.5351C6.35593 11.5625 6.21074 11.4173 6.21074 11.2382V11.13C6.21074 10.9508 6.35591 10.8057 6.5351 10.8057H7.61631C8.88313 10.8057 9.91387 9.77492 9.91387 8.5081C9.91387 7.24128 8.88313 6.21054 7.61631 6.21054H5.62155L6.99534 7.58433C7.14289 7.73183 7.14289 7.97195 6.99534 8.11944C6.85216 8.26251 6.60298 8.2623 6.46013 8.11944L4.44045 6.09971C4.36898 6.02824 4.32959 5.93321 4.32959 5.8321C4.32959 5.73106 4.36898 5.63598 4.44045 5.56454L6.46024 3.54472C6.60309 3.40176 6.85248 3.40176 6.99535 3.54472C7.14291 3.69218 7.14291 3.93234 6.99535 4.07979L5.62156 5.45368H7.61631C9.3004 5.45368 10.6707 6.82393 10.6707 8.5081Z" })) } function US() { return A.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("path", { d: "M1.72838 9.33987L8.84935 2.34732C9.23874 1.96494 9.86279 1.96539 10.2516 2.34831L13.5636 5.60975C13.9655 6.00555 13.9607 6.65526 13.553 7.04507L8.13212 12.2278C7.94604 12.4057 7.69851 12.505 7.44107 12.505L6.06722 12.505L3.83772 12.505C3.5673 12.505 3.30842 12.3954 3.12009 12.2014L1.7114 10.7498C1.32837 10.3551 1.33596 9.72521 1.72838 9.33987Z", stroke: "currentColor" }), A.createElement("line", { x1: "6.01807", y1: "12.5", x2: "10.7959", y2: "12.5", stroke: "currentColor", strokeLinecap: "round" }), A.createElement("line", { x1: "5.50834", y1: "5.74606", x2: "10.1984", y2: "10.4361", stroke: "currentColor" })) } function VS() { let e = pC(), t = Qp(), n = A.useCallback((() => { e.delete() }), [e]), r = e.useStore((e => "idle" === e.appState.status && e.document.pageStates[e.appState.currentPageId].selectedIds.length > 0)); return A.createElement(NE, { label: t.formatMessage({ id: "delete" }), kbd: "", id: "TD-Delete" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "delete" }), variant: "circle", disabled: !r, onSelect: n }, A.createElement(NS, null))) } var KS = e => e.settings.language, WS = () => { let e = pC(), t = e.useStore(KS), n = A.useCallback((t => { e.setSetting("language", t) }), [e]); return A.createElement(bS, { variant: "menu", overflow: !0, id: "language-menu", side: "left", sideOffset: 8 }, gC.map((({ locale: e, label: r }) => A.createElement(vS, { key: e, checked: t === e, onCheckedChange: () => n(e), id: `TD-MenuItem-Language-${e}` }, r))), A.createElement(ME, null), A.createElement("a", { href: "https://github.com/tldraw/tldraw/blob/main/guides/translation.md", target: "_blank", rel: "nofollow" }, A.createElement(mS, { id: "TD-MenuItem-Translation-Link" }, A.createElement($p, { id: "translation.link" }), A.createElement(LE, null, A.createElement(_d, null))))) }; function YS({ onOpenChange: e }) { let t = Qp(), n = fC(), r = { Tools: [{ label: t.formatMessage({ id: "select" }), kbd: "1" }, { label: t.formatMessage({ id: "draw" }), kbd: "2" }, { label: t.formatMessage({ id: "eraser" }), kbd: "3" }, { label: t.formatMessage({ id: "rectangle" }), kbd: "4" }, { label: t.formatMessage({ id: "ellipse" }), kbd: "5" }, { label: t.formatMessage({ id: "triangle" }), kbd: "6" }, { label: t.formatMessage({ id: "line" }), kbd: "7" }, { label: t.formatMessage({ id: "arrow" }), kbd: "8" }, { label: t.formatMessage({ id: "text" }), kbd: "9" }, { label: t.formatMessage({ id: "sticky" }), kbd: "0" }], View: [{ label: t.formatMessage({ id: "zoom.in" }), kbd: "#+" }, { label: t.formatMessage({ id: "zoom.out" }), kbd: "#-" }, { label: `${t.formatMessage({ id: "zoom.to" })} 100%`, kbd: "+0" }, { label: t.formatMessage({ id: "zoom.to.fit" }), kbd: "+1" }, { label: t.formatMessage({ id: "zoom.to.selection" }), kbd: "+2" }, { label: t.formatMessage({ id: "preferences.dark.mode" }), kbd: "#D" }, { label: t.formatMessage({ id: "preferences.focus.mode" }), kbd: "#." }, { label: t.formatMessage({ id: "preferences.show.grid" }), kbd: "#G" }], Transform: [{ label: t.formatMessage({ id: "flip.horizontal" }), kbd: "H" }, { label: t.formatMessage({ id: "flip.vertical" }), kbd: "V" }, { label: `${t.formatMessage({ id: "lock" })} / ${t.formatMessage({ id: "unlock" })}`, kbd: "#L" }, { label: `${t.formatMessage({ id: "move" })} ${t.formatMessage({ id: "to.front" })}`, kbd: "]" }, { label: `${t.formatMessage({ id: "move" })} ${t.formatMessage({ id: "forward" })}`, kbd: "]" }, { label: `${t.formatMessage({ id: "move" })} ${t.formatMessage({ id: "backward" })}`, kbd: "[" }, { label: `${t.formatMessage({ id: "move" })} ${t.formatMessage({ id: "back" })}`, kbd: "[" }], File: [{ label: t.formatMessage({ id: "new.project" }), kbd: "#N" }, { label: t.formatMessage({ id: "open" }), kbd: "#O" }, { label: t.formatMessage({ id: "save" }), kbd: "#S" }, { label: t.formatMessage({ id: "save.as" }), kbd: "#S" }, { label: t.formatMessage({ id: "upload.media" }), kbd: "#U" }], Edit: [{ label: t.formatMessage({ id: "undo" }), kbd: "#Z" }, { label: t.formatMessage({ id: "redo" }), kbd: "#Z" }, { label: t.formatMessage({ id: "cut" }), kbd: "#X" }, { label: t.formatMessage({ id: "copy" }), kbd: "#C" }, { label: t.formatMessage({ id: "paste" }), kbd: "#V" }, { label: t.formatMessage({ id: "select.all" }), kbd: "#A" }, { label: t.formatMessage({ id: "delete" }), kbd: "" }, { label: t.formatMessage({ id: "duplicate" }), kbd: "#D" }] }; return A.createElement(Zy, { onOpenChange: e }, A.createElement(Xy, { asChild: !0 }, A.createElement(FE, { id: "TD-HelpItem-Keyboard", variant: "wide" }, A.createElement($p, { id: "keyboard.shortcuts" }))), A.createElement(_y, { container: n.current }, A.createElement(JS, null), A.createElement(QS, null, A.createElement(ek, null, A.createElement($p, { id: "keyboard.shortcuts" }), A.createElement(eb, { asChild: !0 }, A.createElement($S, null, A.createElement(Ud, null)))), A.createElement(qS, { bp: OE }, Object.entries(r).map((([e, t]) => A.createElement(ZS, { key: e }, A.createElement(GS, null, A.createElement($p, { id: `menu.${e.toLocaleLowerCase()}` })), A.createElement(XS, null, t.map((e => A.createElement(_S, { key: e.label }, e.label, A.createElement(BE, { variant: "menu" }, e.kbd)))))))))))) } var GS = AE("h3", { fontSize: "$2", color: "$text", fontFamily: "$ui", margin: 0, paddingBottom: "$5" }), ZS = AE("div", { breakInside: "avoid", paddingBottom: 24 }), XS = AE("ul", { listStyleType: "none", width: "100%", padding: 0, margin: 0 }), _S = AE("li", { display: "flex", alignItems: "center", justifyContent: "space-between", height: 32, minHeight: 32, width: "100%", outline: "none", color: "$text", fontFamily: "$ui", fontWeight: 400, fontSize: "$1", borderRadius: 4, userSelect: "none", WebkitUserSelect: "none", margin: 0, padding: "0 0" }), QS = AE(qy, { borderRadius: 6, boxShadow: "hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px", position: "fixed", top: "50%", left: "50%", transform: "translate(-50%, -50%)", width: "fit-content", maxWidth: "90vw", maxHeight: "74vh", overflowY: "auto", padding: 25, zIndex: 9999, pointerEvents: "all", background: "$panel", "&:focus": { outline: "none" } }), qS = AE("div", { maxWidth: "100%", width: "fit-content", height: "fit-content", overflowY: "auto", columnGap: 64, variants: { bp: { mobile: { columns: 1, [`& ${ZS}`]: { minWidth: "0px" } }, small: { columns: 2, [`& ${ZS}`]: { minWidth: "200px" } }, medium: { columns: 3 }, large: { columns: 3 } } } }), JS = AE(Qy, { backgroundColor: "$overlay", position: "fixed", inset: 0, zIndex: 9998 }), $S = AE(WC, { fontFamily: "inherit", borderRadius: "100%", height: 25, width: 25, display: "inline-flex", alignItems: "center", justifyContent: "center", color: "$text", cursor: "pointer", "&:hover": { backgroundColor: "$hover" } }), ek = AE(Jy, { fontFamily: "$body", fontSize: "$3", color: "$text", paddingBottom: 32, display: "flex", alignItems: "center", justifyContent: "space-between", margin: 0 }), tk = e => e.settings.isDebugMode, nk = e => e.settings.dockPosition; function rk() { let e = pC(), t = e.useStore(tk), n = e.useStore(nk), [r, i] = A.useState(!1); return A.createElement(Mw, null, A.createElement(ck, { dir: "ltr", debug: t, side: n, bp: OE }, A.createElement(Rw, { dir: "ltr", asChild: !0 }, A.createElement(sk, null, A.createElement(Sp, null)))), A.createElement(Bw, { dir: "ltr", align: "end", side: "top", alignOffset: 10, sideOffset: 8, asChild: !0 }, A.createElement(lk, { style: { visibility: r ? "hidden" : "visible" } }, A.createElement(ik, null), A.createElement(YS, { onOpenChange: i }), A.createElement(ME, null), A.createElement(ak, null)))) } var ik = () => A.createElement(Cf, { dir: "ltr" }, A.createElement(Sf, { asChild: !0 }, A.createElement(FE, { variant: "wide", hasArrow: !0 }, A.createElement($p, { id: "language" }))), A.createElement(WS, null)), ok = [{ id: "tldraw-beta", icon: _d, url: "https://beta.tldraw.com" }, { id: "github", icon: qd, url: "https://github.com/tldraw/tldraw" }, { id: "twitter", icon: Zp, url: "https://twitter.com/tldraw" }, { id: "discord", icon: function () { return A.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", fill: "currentColor", viewBox: "0 0 16 16" }, A.createElement("path", { d: "M13.545 2.907a13.227 13.227 0 0 0-3.257-1.011.05.05 0 0 0-.052.025c-.141.25-.297.577-.406.833a12.19 12.19 0 0 0-3.658 0 8.258 8.258 0 0 0-.412-.833.051.051 0 0 0-.052-.025c-1.125.194-2.22.534-3.257 1.011a.041.041 0 0 0-.021.018C.356 6.024-.213 9.047.066 12.032c.001.014.01.028.021.037a13.276 13.276 0 0 0 3.995 2.02.05.05 0 0 0 .056-.019c.308-.42.582-.863.818-1.329a.05.05 0 0 0-.01-.059.051.051 0 0 0-.018-.011 8.875 8.875 0 0 1-1.248-.595.05.05 0 0 1-.02-.066.051.051 0 0 1 .015-.019c.084-.063.168-.129.248-.195a.05.05 0 0 1 .051-.007c2.619 1.196 5.454 1.196 8.041 0a.052.052 0 0 1 .053.007c.08.066.164.132.248.195a.051.051 0 0 1-.004.085 8.254 8.254 0 0 1-1.249.594.05.05 0 0 0-.03.03.052.052 0 0 0 .003.041c.24.465.515.909.817 1.329a.05.05 0 0 0 .056.019 13.235 13.235 0 0 0 4.001-2.02.049.049 0 0 0 .021-.037c.334-3.451-.559-6.449-2.366-9.106a.034.034 0 0 0-.02-.019Zm-8.198 7.307c-.789 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.45.73 1.438 1.613 0 .888-.637 1.612-1.438 1.612Zm5.316 0c-.788 0-1.438-.724-1.438-1.612 0-.889.637-1.613 1.438-1.613.807 0 1.451.73 1.438 1.613 0 .888-.631 1.612-1.438 1.612Z" })) }, url: "https://discord.gg/SBBEVCA4PG" }, { id: "become.a.sponsor", icon: rp, url: "https://github.com/sponsors/steveruizok" }], ak = () => A.createElement(A.Fragment, null, ok.map((e => A.createElement("a", { key: e.id, href: e.url, target: "_blank", rel: "nofollow" }, A.createElement(FE, { id: `TD-Link-${e.id}`, variant: "wide" }, A.createElement($p, { id: e.id }), A.createElement(LE, null, A.createElement(e.icon, null))))))), sk = AE("button", { width: 32, height: 32, borderRadius: "100%", display: "flex", padding: 0, justifyContent: "center", alignItems: "center", outline: "none", backgroundColor: "$panel", cursor: "pointer", boxShadow: "$panel", border: "1px solid $panelContrast", color: "$text", "& svg": { height: 12, width: 12 } }), lk = AE(TE, { width: "fit-content", height: "fit-content", minWidth: 200, maxHeight: 380, overflowY: "auto", "& *": { boxSizing: "border-box" }, "& a": { outline: "none" }, variants: { variant: { horizontal: { flexDirection: "row" }, menu: { minWidth: 128 } } } }), ck = AE(Tw, { position: "absolute", zIndex: 999, right: 10, bottom: 10, width: 32, height: 32, variants: { debug: { true: {}, false: {} }, bp: { mobile: { bottom: 64 }, small: { bottom: 20 }, medium: {}, large: {} }, side: { top: {}, left: {}, right: {}, bottom: {} } }, compoundVariants: [{ debug: !0, css: { bottom: 50 } }, { bp: "mobile", side: "bottom", debug: !0, css: { bottom: 104 } }, { bp: "small", side: "bottom", debug: !0, css: { bottom: 60 } }, { bp: "small", side: "bottom", debug: !0, css: { bottom: 60 } }] }), uk = AE("div", { backgroundColor: "$panel", display: "flex", alignItems: "center", flexDirection: "row", boxShadow: "$panel", padding: "$2", border: "1px solid $panelContrast", gap: 0, overflow: "hidden", variants: { side: { center: { borderRadius: 9 }, left: { padding: 0, borderTop: 0, borderLeft: 0, borderTopRightRadius: 0, borderBottomRightRadius: 9, borderBottomLeftRadius: 0 }, right: { padding: 0, borderTop: 0, borderRight: 0, borderTopLeftRadius: 0, borderBottomLeftRadius: 9, borderBottomRightRadius: 0 } } }, "& hr": { height: 10, width: "100%", backgroundColor: "red", border: "none" } }), dk = ["rectangle", "ellipse", "triangle", "line"], pk = { rectangle: A.createElement(Rp, null), ellipse: A.createElement(Od, null), triangle: A.createElement(_p, null), line: A.createElement((function () { return A.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("path", { d: "M3.64645 11.3536C3.45118 11.1583 3.45118 10.8417 3.64645 10.6465L11.1464 3.14645C11.3417 2.95118 11.6583 2.95118 11.8536 3.14645C12.0488 3.34171 12.0488 3.65829 11.8536 3.85355L4.35355 11.3536C4.15829 11.5488 3.84171 11.5488 3.64645 11.3536Z" })) }), null) }, hk = e => e.settings.dockPosition, fk = A.memo((function ({ activeTool: e, isToolLocked: t }) { let n = pC(), r = Qp(), i = n.useStore(hk), [o, a] = A.useState("rectangle"); A.useEffect((() => { dk.includes(e) && o !== e && a(e) }), [e]); let s = A.useCallback((() => { n.selectTool(o) }), [e, n]), l = A.useCallback((() => { n.toggleToolLock() }), [n]), c = A.useCallback((e => { " " === e.key && n.shiftKey && e.preventDefault() }), []), u = dk.includes(e), d = "bottom" === i || "top" === i ? "top" : i, p = "bottom" === i || "top" === i ? "row" : "column"; return A.createElement(Cf, { dir: "ltr", onOpenChange: s }, A.createElement(Sf, { dir: "ltr", asChild: !0, id: "TD-PrimaryTools-Shapes" }, A.createElement(bC, { disabled: u && n.shiftKey, variant: "primary", onDoubleClick: l, isToolLocked: u && t, isActive: u, onKeyDown: c, "aria-label": r.formatMessage({ id: "shapes" }) }, pk[o])), A.createElement(xf, { asChild: !0, side: d, sideOffset: 12 }, A.createElement(uk, { side: "center", style: { flexDirection: p } }, dk.map(((e, t) => A.createElement(NE, { key: e, label: r.formatMessage({ id: e }), kbd: (4 + t).toString(), id: `TD-PrimaryTools-Shapes-${e}` }, A.createElement(Af, { asChild: !0 }, A.createElement(bC, { "aria-label": r.formatMessage({ id: e }), variant: "primary", onClick: () => { n.selectTool(e), a(e) } }, pk[e])))))))) })), mk = e => e.appState.activeTool, gk = e => e.appState.isToolLocked, vk = e => e.settings.dockPosition, yk = A.memo((function () { let e = pC(), t = Qp(), n = e.useStore(mk), r = e.useStore(gk), i = e.useStore(vk), o = A.useCallback((() => { e.selectTool("select") }), [e]), a = A.useCallback((() => { e.selectTool("erase") }), [e]), s = A.useCallback((() => { e.selectTool("draw") }), [e]), l = A.useCallback((() => { e.selectTool("arrow") }), [e]), c = A.useCallback((() => { e.selectTool("text") }), [e]), u = A.useCallback((() => { e.selectTool("sticky") }), [e]), d = A.useCallback((() => xE(this, null, (function* () { e.openAsset() }))), [e]); return A.createElement(bk, { side: "center", id: "TD-PrimaryTools", style: { flexDirection: "bottom" === i || "top" === i ? "row" : "column" }, bp: OE }, A.createElement(wC, { kbd: "1", label: t.formatMessage({ id: "select" }), onClick: o, isActive: "select" === n, variant: "primary", id: "TD-PrimaryTools-CursorArrow" }, A.createElement(Kd, null)), A.createElement(wC, { kbd: "2", label: t.formatMessage({ id: "draw" }), onClick: s, isActive: "draw" === n, variant: "primary", id: "TD-PrimaryTools-Pencil" }, A.createElement(hp, null)), A.createElement(wC, { kbd: "3", label: t.formatMessage({ id: "eraser" }), onClick: a, isActive: "erase" === n, variant: "primary", id: "TD-PrimaryTools-Eraser" }, A.createElement(US, null)), A.createElement(fk, { activeTool: n, isToolLocked: r }), A.createElement(wC, { kbd: "8", label: t.formatMessage({ id: "arrow" }), onClick: l, isLocked: r, variant: "primary", isActive: "arrow" === n, id: "TD-PrimaryTools-ArrowTopRight" }, A.createElement(Sd, null)), A.createElement(wC, { kbd: "9", label: t.formatMessage({ id: "text" }), onClick: c, isLocked: r, variant: "primary", isActive: "text" === n, id: "TD-PrimaryTools-Text" }, A.createElement(zp, null)), A.createElement(wC, { kbd: "0", label: t.formatMessage({ id: "sticky" }), onClick: u, isActive: "sticky" === n, variant: "primary", id: "TD-PrimaryTools-Pencil2" }, A.createElement(mp, null)), A.createElement(wC, { label: t.formatMessage({ id: "image" }), onClick: d, id: "TD-PrimaryTools-Image", variant: "primary" }, A.createElement(op, null))) })), bk = AE(uk, { variants: { bp: { mobile: { padding: "$0", borderRadius: "10px" }, small: { padding: "$2" } } } }), wk = e => e.appState.status, Ek = e => e.appState.activeTool; function Ck() { let e = pC(), t = e.useStore(wk), n = e.useStore(Ek); return A.createElement(Sk, { bp: OE, id: "TD-StatusBar" }, A.createElement(kk, null, n, " | ", t)) } var Sk = AE("div", { height: 40, userSelect: "none", WebkitUserSelect: "none", borderTop: "1px solid $panelContrast", gridArea: "status", display: "flex", color: "$text", justifyContent: "space-between", alignItems: "center", backgroundColor: "$panel", gap: 8, fontFamily: "$ui", fontSize: "$0", padding: "0 16px", variants: { bp: { small: { fontSize: "$1" } } } }), kk = AE("div", { whiteSpace: "nowrap", overflow: "hidden" }), xk = e => e.settings.isDebugMode, Ak = e => e.settings.dockPosition, Ik = A.memo((function ({ onBlur: e }) { let t = pC(), n = t.useStore(Ak), r = t.useStore(xk); return A.createElement(A.Fragment, null, A.createElement(Pk, { side: n, onBlur: e, bp: OE, debug: r }, A.createElement(Mk, { id: "TD-Tools" }, A.createElement(FS, null), A.createElement(Rk, { orientation: "bottom" === n || "top" === n ? "horizontal" : "vertical" }, A.createElement(RS, null), A.createElement(yk, null), A.createElement(VS, null)))), A.createElement(rk, null), r && A.createElement(Tk, null, A.createElement(Ck, null))) })), Pk = AE("div", { position: "absolute", width: "100%", minWidth: 0, maxWidth: "100%", height: 64, gap: "$4", display: "flex", justifyContent: "center", alignItems: "center", zIndex: 200, overflow: "hidden", pointerEvents: "none", "& > div > *": { pointerEvents: "all" }, variants: { debug: { true: {}, false: {} }, bp: { mobile: {}, small: {}, medium: {}, large: {} }, side: { top: { width: "100%", height: 64, left: 0, right: 0, top: 45 }, right: { width: 64, height: "100%", top: 0, right: 0 }, bottom: { width: "100%", left: 0, right: 0, bottom: 4 }, left: { width: 64, height: "100%", left: 0 } } }, compoundVariants: [{ side: "top", bp: "large", css: { top: 0 } }, { side: "bottom", debug: !0, css: { bottom: 44 } }] }), Mk = AE("div", { display: "flex", width: "fit-content", height: "fit-content", alignItems: "center", justifyContent: "center", flexDirection: "column", gap: "$4" }), Tk = AE("div", { position: "absolute", bottom: "0px", left: "0px", right: "0px", height: "40px", width: "100%", maxWidth: "100%" }), Rk = AE("div", { position: "relative", display: "flex", alignItems: "center", height: "fit-content", gap: "$3", variants: { orientation: { horizontal: { flexDirection: "row" }, vertical: { flexDirection: "column" } } } }), Bk = e => e.settings, Dk = ["bottom", "left", "right", "top"]; function Lk() { let e = pC(), t = Qp(), n = e.useStore(Bk), r = A.useCallback((() => { e.setSetting("isDebugMode", (e => !e)) }), [e]), i = A.useCallback((() => { e.setSetting("isDarkMode", (e => !e)) }), [e]), o = A.useCallback((() => { e.setSetting("isFocusMode", (e => !e)) }), [e]), a = A.useCallback((() => { e.setSetting("showGrid", (e => !e)) }), [e]), s = A.useCallback((() => { e.setSetting("keepStyleMenuOpen", (e => !e)) }), [e]), l = A.useCallback((() => { e.setSetting("isCadSelectMode", (e => !e)) }), [e]), c = A.useCallback((t => { e.setSetting("dockPosition", t) }), [e]), u = A.useCallback((t => { e.setSetting("exportBackground", t) }), [e]); return A.createElement(CS, { label: t.formatMessage({ id: "menu.preferences" }), id: "TD-MenuItem-Preferences" }, A.createElement(vS, { checked: n.isDarkMode, onCheckedChange: i, kbd: "#D", id: "TD-MenuItem-Preferences-Dark_Mode", ariaLabel: t.formatMessage({ id: "preferences.dark.mode" }) }, A.createElement($p, { id: "preferences.dark.mode" })), A.createElement(vS, { checked: n.isFocusMode, onCheckedChange: o, kbd: "#.", id: "TD-MenuItem-Preferences-Focus_Mode", ariaLabel: t.formatMessage({ id: "preferences.focus.mode" }) }, A.createElement($p, { id: "preferences.focus.mode" })), A.createElement(vS, { checked: n.isDebugMode, onCheckedChange: r, id: "TD-MenuItem-Preferences-Debug_Mode", ariaLabel: t.formatMessage({ id: "preferences.debug.mode" }) }, A.createElement($p, { id: "preferences.debug.mode" })), A.createElement(ME, null), A.createElement(vS, { checked: n.showGrid, onCheckedChange: a, kbd: "#G", id: "TD-MenuItem-Preferences-Grid", ariaLabel: t.formatMessage({ id: "preferences.show.grid" }) }, A.createElement($p, { id: "preferences.show.grid" })), A.createElement(vS, { checked: n.isCadSelectMode, onCheckedChange: l, id: "TD-MenuItem-Preferences-Cad_Selection", ariaLabel: t.formatMessage({ id: "preferences.use.cad.selection" }) }, A.createElement($p, { id: "preferences.use.cad.selection" })), A.createElement(vS, { checked: n.keepStyleMenuOpen, onCheckedChange: s, id: "TD-MenuItem-Preferences-Style_menu", ariaLabel: t.formatMessage({ id: "preferences.keep.stylemenu.open" }) }, A.createElement($p, { id: "preferences.keep.stylemenu.open" })), A.createElement(CS, { label: t.formatMessage({ id: "dock.position" }) }, Dk.map((e => A.createElement(vS, { key: e, checked: n.dockPosition === e, onCheckedChange: () => c(e), id: `TD-MenuItem-DockPosition-${e}`, ariaLabel: `DockPosition-${e}` }, A.createElement(Ok, null, A.createElement($p, { id: e })))))), A.createElement(CS, { label: t.formatMessage({ id: "export.background" }) }, Object.values(cC).map((e => A.createElement(vS, { key: e, checked: n.exportBackground === e, onCheckedChange: () => u(e), id: `TD-MenuItem-ExportBackground-${e}`, ariaLabel: `ExportBackground-${e}` }, A.createElement(Ok, null, A.createElement($p, { id: e }))))))) } var Ok = AE("span", { textTransform: "capitalize" }), Fk = e => e.document.pageStates[e.appState.currentPageId].selectedIds.length, zk = e => e.appState.disableAssets, Hk = A.memo((function ({ readOnly: e }) { let t = pC(), n = Qp(), [r, i] = A.useState(!1), o = t.useStore(Fk), a = t.useStore(zk), [s, l] = A.useState(0); A.useEffect((() => l(1)), []); let { onNewProject: c, onOpenProject: u, onSaveProject: d, onSaveProjectAs: p } = KE(), h = A.useCallback((() => { Dw ? t.saveProjectAs() : i(!0) }), [t]), f = A.useCallback((() => { t.delete() }), [t]), m = A.useCallback((() => { t.copyImage("svg", { scale: 1, quality: 1, transparentBackground: !1 }) }), [t]), g = A.useCallback((() => { t.copyImage("png", { scale: 2, quality: 1, transparentBackground: !0 }) }), [t]), v = A.useCallback((() => xE(this, null, (function* () { t.exportImage("png", { scale: 2, quality: 1 }) }))), [t]), y = A.useCallback((() => xE(this, null, (function* () { t.exportImage("jpeg", { scale: 2, quality: 1 }) }))), [t]), b = A.useCallback((() => xE(this, null, (function* () { t.exportImage("webp", { scale: 2, quality: 1 }) }))), [t]), w = A.useCallback((() => xE(this, null, (function* () { t.exportImage("svg", { scale: 2, quality: 1 }) }))), [t]), E = A.useCallback((() => xE(this, null, (function* () { t.copyJson() }))), [t]), C = A.useCallback((() => xE(this, null, (function* () { t.exportJson() }))), [t]), S = A.useCallback((() => { t.cut() }), [t]), k = A.useCallback((() => { t.copy() }), [t]), x = A.useCallback((() => { t.paste() }), [t]), I = A.useCallback((() => { t.selectAll() }), [t]), P = A.useCallback((() => { t.selectNone() }), [t]), M = A.useCallback((() => { t.openAsset() }), [t]), T = A.useCallback((() => { t.zoomTo(1) }), [t]), R = t.callbacks.onNewProject || t.callbacks.onOpenProject || t.callbacks.onSaveProject || t.callbacks.onSaveProjectAs || t.callbacks.onExport, B = o > 0; return A.createElement(A.Fragment, null, A.createElement(Cf, { dir: "ltr" }, A.createElement(SS, { id: "TD-MenuIcon" }, A.createElement(tp, null)), A.createElement(bS, { variant: "menu", id: "TD-Menu", side: "bottom", align: "start", sideOffset: 4, alignOffset: 4 }, R && A.createElement(CS, { label: `${n.formatMessage({ id: "menu.file" })}...`, id: "TD-MenuItem-File" }, t.callbacks.onNewProject && A.createElement(mS, { onClick: c, kbd: "#N", id: "TD-MenuItem-File-New_Project" }, A.createElement($p, { id: "new.project" })), t.callbacks.onOpenProject && A.createElement(mS, { onClick: u, kbd: "#O", id: "TD-MenuItem-File-Open" }, A.createElement($p, { id: "open" }), "..."), t.callbacks.onSaveProject && A.createElement(mS, { onClick: d, kbd: "#S", id: "TD-MenuItem-File-Save" }, A.createElement($p, { id: "save" })), t.callbacks.onSaveProjectAs && A.createElement(mS, { onClick: h, kbd: "#S", id: "TD-MenuItem-File-Save_As" }, A.createElement($p, { id: "save.as" }), "..."), A.createElement(CS, { label: `${n.formatMessage({ id: "export.as" })}...`, size: "small", id: "TD-MenuItem-Export" }, A.createElement(mS, { onClick: w, id: "TD-MenuItem-Export-SVG" }, "SVG"), A.createElement(mS, { onClick: v, id: "TD-MenuItem-Export-PNG" }, "PNG"), A.createElement(mS, { onClick: y, id: "TD-MenuItem-Export-JPG" }, "JPG"), A.createElement(mS, { onClick: b, id: "TD-MenuItem-Export-WEBP" }, "WEBP"), A.createElement(mS, { onClick: C, id: "TD-MenuItem-Export-JSON" }, "JSON")), !a && A.createElement(A.Fragment, null, A.createElement(ME, null), A.createElement(mS, { onClick: M, kbd: "#U", id: "TD-MenuItem-File-Upload_Media" }, A.createElement($p, { id: "upload.media" })))), A.createElement(CS, { label: `${n.formatMessage({ id: "menu.edit" })}...`, id: "TD-MenuItem-Edit" }, A.createElement(mS, { onSelect: gS, onClick: t.undo, disabled: e, kbd: "#Z", id: "TD-MenuItem-Edit-Undo" }, A.createElement($p, { id: "undo" })), A.createElement(mS, { onSelect: gS, onClick: t.redo, disabled: e, kbd: "#Z", id: "TD-MenuItem-Edit-Redo" }, A.createElement($p, { id: "redo" })), A.createElement(ME, null), A.createElement(mS, { onSelect: gS, disabled: !B || e, onClick: S, kbd: "#X", id: "TD-MenuItem-Edit-Cut" }, A.createElement($p, { id: "cut" })), A.createElement(mS, { onSelect: gS, disabled: !B, onClick: k, kbd: "#C", id: "TD-MenuItem-Edit-Copy" }, A.createElement($p, { id: "copy" })), A.createElement(mS, { onSelect: gS, onClick: x, kbd: "#V", id: "TD-MenuItem-Edit-Paste" }, A.createElement($p, { id: "paste" })), A.createElement(ME, null), A.createElement(CS, { label: `${n.formatMessage({ id: "copy.as" })}...`, size: "small", id: "TD-MenuItem-Copy-As" }, A.createElement(mS, { onClick: m, id: "TD-MenuItem-Copy-as-SVG" }, "SVG"), A.createElement(mS, { onClick: g, id: "TD-MenuItem-Copy-As-PNG" }, "PNG"), A.createElement(mS, { onClick: E, id: "TD-MenuItem-Copy_as_JSON" }, "JSON")), A.createElement(ME, null), A.createElement(mS, { onSelect: gS, onClick: I, kbd: "#A", id: "TD-MenuItem-Select_All" }, A.createElement($p, { id: "select.all" })), A.createElement(mS, { onSelect: gS, disabled: !B, onClick: P, id: "TD-MenuItem-Select_None" }, A.createElement($p, { id: "select.none" })), A.createElement(ME, null), A.createElement(mS, { onSelect: f, disabled: !B, kbd: "", id: "TD-MenuItem-Delete" }, A.createElement($p, { id: "delete" }))), A.createElement(CS, { label: n.formatMessage({ id: "menu.view" }), id: "TD-MenuItem-Edit" }, A.createElement(mS, { onSelect: gS, onClick: t.zoomIn, kbd: "#+", id: "TD-MenuItem-View-ZoomIn" }, A.createElement($p, { id: "zoom.in" })), A.createElement(mS, { onSelect: gS, onClick: t.zoomOut, kbd: "#-", id: "TD-MenuItem-View-ZoomOut" }, A.createElement($p, { id: "zoom.out" })), A.createElement(mS, { onSelect: gS, onClick: T, kbd: "+0", id: "TD-MenuItem-View-ZoomTo100" }, A.createElement($p, { id: "zoom.to" }), " 100%"), A.createElement(mS, { onSelect: gS, onClick: t.zoomToFit, kbd: "+1", id: "TD-MenuItem-View-ZoomToFit" }, A.createElement($p, { id: "zoom.to.fit" })), A.createElement(mS, { onSelect: gS, onClick: t.zoomToSelection, kbd: "+2", id: "TD-MenuItem-View-ZoomToSelection" }, A.createElement($p, { id: "zoom.to.selection" }))), A.createElement(ME, null), A.createElement(Lk, null))), A.createElement(uS, { isOpen: r, onClose: () => i(!1) })) })); function Nk() { return A.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor", fillRule: "evenodd", clipRule: "evenodd" }, A.createElement("path", { d: "M1.36482 4.71089C1.36482 3.21371 2.57853 2 4.07572 2C5.5729 2 6.78661 3.21371 6.78661 4.71089C6.78661 5.76842 6.18106 6.68452 5.29779 7.13136C5.80465 7.24611 6.26407 7.44186 6.66028 7.73182C7.18674 8.11711 7.57215 8.64722 7.81073 9.30983C7.81452 9.30606 7.81832 9.3023 7.82212 9.29855C8.30448 8.82317 8.91325 8.52463 9.60905 8.37275C8.68812 7.922 8.05394 6.97569 8.05394 5.88126C8.05394 4.35017 9.29513 3.10898 10.8262 3.10898C12.3573 3.10898 13.5985 4.35017 13.5985 5.88126C13.5985 6.97561 12.9644 7.92186 12.0436 8.37265C12.7396 8.52449 13.3486 8.82306 13.831 9.29854C14.5795 10.0361 14.9481 11.1249 14.9481 12.5176C14.9481 12.7799 14.7354 12.9926 14.473 12.9926C14.2107 12.9926 13.9981 12.7799 13.9981 12.5175C13.9981 11.2848 13.6738 10.4774 13.1642 9.97518C12.6532 9.4716 11.8802 9.20024 10.8266 9.20024C9.77294 9.20024 8.99993 9.4716 8.48896 9.97518C7.97939 10.4774 7.65513 11.2848 7.65513 12.5176C7.65513 12.7799 7.44247 12.9926 7.18013 12.9926C6.9178 12.9926 6.70513 12.7799 6.70513 12.5176C6.70513 11.6734 6.84053 10.941 7.11384 10.3307C7.0922 10.2895 7.0763 10.2444 7.06737 10.1962C6.91739 9.38749 6.57392 8.84586 6.09923 8.49845C5.61626 8.14499 4.94481 7.95427 4.07574 7.95427C3.05232 7.95427 2.30368 8.21784 1.80952 8.70485C1.31675 9.19047 1.00176 9.97257 1.00176 11.1702C1.00176 11.4326 0.789093 11.6452 0.526758 11.6452C0.264423 11.6452 0.0517578 11.4326 0.0517578 11.1702C0.0517578 9.81263 0.411052 8.74925 1.14268 8.02821C1.60624 7.57137 2.18892 7.28191 2.85378 7.13142C1.97043 6.68461 1.36482 5.76848 1.36482 4.71089ZM4.07572 2.95C3.1032 2.95 2.31482 3.73838 2.31482 4.71089C2.31482 5.68341 3.1032 6.47178 4.07572 6.47178C5.04823 6.47178 5.83661 5.68341 5.83661 4.71089C5.83661 3.73838 5.04823 2.95 4.07572 2.95ZM10.8262 4.05898C9.8198 4.05898 9.00394 4.87484 9.00394 5.88126C9.00394 6.88768 9.8198 7.70355 10.8262 7.70355C11.8326 7.70355 12.6485 6.88768 12.6485 5.88126C12.6485 4.87484 11.8326 4.05898 10.8262 4.05898Z" })) } var jk = "-0.03em", Uk = [.5, .5], Vk = (Math.PI, ".tldr"), Kk = { linear: e => e, easeInQuad: e => e * e, easeOutQuad: e => e * (2 - e), easeInOutQuad: e => e < .5 ? 2 * e * e : (4 - 2 * e) * e - 1, easeInCubic: e => e * e * e, easeOutCubic: e => --e * e * e + 1, easeInOutCubic: e => e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1, easeInQuart: e => e * e * e * e, easeOutQuart: e => 1 - --e * e * e * e, easeInOutQuart: e => e < .5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e, easeInQuint: e => e * e * e * e * e, easeOutQuint: e => 1 + --e * e * e * e * e, easeInOutQuint: e => e < .5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e, easeInSine: e => 1 - Math.cos(e * Math.PI / 2), easeOutSine: e => Math.sin(e * Math.PI / 2), easeInOutSine: e => -(Math.cos(Math.PI * e) - 1) / 2, easeInExpo: e => e <= 0 ? 0 : Math.pow(2, 10 * e - 10), easeOutExpo: e => e >= 1 ? 1 : 1 - Math.pow(2, -10 * e), easeInOutExpo: e => e <= 0 ? 0 : e >= 1 ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2 }, Wk = ["#EC5E41", "#F2555A", "#F04F88", "#E34BA9", "#BD54C6", "#9D5BD2", "#7B66DC", "#02B1CC", "#11B3A3", "#39B178", "#55B467", "#FF802B"], Yk = "undefined" != typeof Window && /^((?!chrome|android).)*safari/i.test(navigator.userAgent), Gk = "undefined" != typeof Window && /linux/i.test(navigator.userAgent), Zk = [".png", ".svg", ".jpg", ".jpeg", ".gif"], Xk = Yk ? [] : [".mp4", ".webm"]; function _k(e) { if (null === e) return e; if (e instanceof Date) return new Date(e.getTime()); if ("object" == typeof e) { if ("function" == typeof e[Symbol.iterator]) { let t = []; if (e.length > 0) for (let n of e) t.push(_k(n)); return t } { let t = Object.keys(e), n = {}; if (t.length > 0) for (let r of t) n[r] = _k(e[r]); return n } } return e } function Qk(e, t) { let n = Zt.getFromCache(t, e, (() => { let [t, n] = e.size; return { minX: 0, maxX: t, minY: 0, maxY: n, width: t, height: n } })); return Zt.translateBounds(n, e.point) } var qk, Jk = { start: "left", middle: "center", end: "right", justify: "justify" }; function $k(e = "start") { return Jk[e] } "undefined" != typeof window && (qk = function () { var e; null == (e = document.getElementById("__textLabelMeasure")) || e.remove(); let t = document.createElement("pre"); return t.id = "__textLabelMeasure", Object.assign(t.style, { whiteSpace: "pre", width: "auto", border: "1px solid transparent", padding: "4px", margin: "0px", letterSpacing: jk, opacity: "0", position: "absolute", top: "-500px", left: "0px", zIndex: "9999", pointerEvents: "none", userSelect: "none", "-webkit-user-select": "none", alignmentBaseline: "mathematical", dominantBaseline: "mathematical" }), t.tabIndex = -1, document.body.appendChild(t), t }()); var ex = "", tx = "", nx = [0, 0]; function rx(e, t) { if (!e) return [16, 32]; if (!qk) return [10, 10]; if (qk.parent || document.body.appendChild(qk), e === ex && t === tx) return nx; ex = e, tx = t, qk.textContent = e, qk.style.font = t; let n = qk.offsetWidth || 1, r = qk.offsetHeight || 1; return nx = [n, r] } var ix = new RegExp(`${[32, 160, 4961, 65792, 65793, 4153, 4241].map((e => String.fromCodePoint(e))).join("|")}`); function ox(e, t, n, r, i, o = !1) { let a = "normal", s = jk, l = function (e) { let t = document.createElement("div"); t.style.setProperty("position", "absolute"), t.style.setProperty("top", "-9999px"), t.style.setProperty("left", "-9999px"), t.style.setProperty("width", e.width + "px"), t.style.setProperty("height", "min-content"), t.style.setProperty("font-size", e.fontSize + "px"), t.style.setProperty("font-family", e.fontFamily), t.style.setProperty("font-weight", e.fontWeight), t.style.setProperty("line-height", e.lineHeight * e.fontSize + "px"), t.style.setProperty("letter-spacing", e.letterSpacing), t.style.setProperty("text-align", e.textAlign), document.body.appendChild(t); let n = e.text.split(ix).flatMap((e => e.replace("\n", " \n"))).join(" ").split(" "); t.innerText = n[0]; let r = t.offsetHeight, i = [n[0]], o = [i]; for (let e = 1; e < n.length; e++) { let a = n[e]; t.innerText += " " + a; let s = t.offsetHeight; s > r && (r = s, i = [], o.push(i)), i.push(a) } return t.remove(), o.map((e => e.join(" "))) }({ text: e, wrap: o, width: i, fontSize: t, fontWeight: a, fontFamily: n, fontStyle: "normal", textAlign: "left", letterSpacing: jk, lineHeight: 1 }), c = document.createElementNS("http://www.w3.org/2000/svg", "text"); c.setAttribute("font-size", t + "px"), c.setAttribute("font-family", n), c.setAttribute("font-weight", a), c.setAttribute("line-height", 1 * t + "px"), c.setAttribute("letter-spacing", s), c.setAttribute("text-align", null != r ? r : "left"), c.setAttribute("dominant-baseline", "mathematical"), c.setAttribute("alignment-baseline", "mathematical"); let u = l.map(((e, n) => { let r = document.createElementNS("http://www.w3.org/2000/svg", "tspan"); return r.textContent = e + "\n", r.setAttribute("y", 1 * t * (n + .5) + "px"), c.appendChild(r), r })); switch (r) { case "middle": c.setAttribute("text-align", "center"), c.setAttribute("text-anchor", "middle"), u.forEach((e => e.setAttribute("x", i / 2 + ""))); break; case "end": c.setAttribute("text-align", "right"), c.setAttribute("text-anchor", "end"), u.forEach((e => e.setAttribute("x", -4 + i + ""))); break; default: c.setAttribute("text-align", "left"), c.setAttribute("text-anchor", "start"), u.forEach((e => e.setAttribute("x", "4"))) }return c } function ax({ id: e, bounds: t, labelSize: n, offset: r, scale: i = 1 }) { return A.createElement("defs", null, A.createElement("mask", { id: e + "_clip" }, A.createElement("rect", { x: -100, y: -100, width: t.width + 200, height: t.height + 200, fill: "white" }), A.createElement("rect", { x: t.width / 2 - n[0] / 2 * i + ((null == r ? void 0 : r[0]) || 0), y: t.height / 2 - n[1] / 2 * i + ((null == r ? void 0 : r[1]) || 0), width: n[0] * i, height: n[1] * i, rx: 4 * i, ry: 4 * i, fill: "black", opacity: Math.max(i, .8) }))) } var sx = 2 * Math.PI, lx = class { static inwardEdgeNormal(e) { let t = B.sub(e[1], e[0]), n = B.len2(t); return [-t[0] / n, t[1] / n] } static outwardEdgeNormal(e) { return B.neg(lx.inwardEdgeNormal(e)) } static isReflexVertex(e, t) { let n = e.length, r = e[(t + n - 1) % n], i = e[t], o = e[(t + 1) % n]; return lx.leftSide(r, o, i) < 0 } static getEdges(e) { return e.map(((t, n) => [t, e[(n + 1) % e.length]])) } static edgesIntersection([e, t], [n, r]) { let i = (r[1] - n[1]) * (t[0] - e[0]) - (r[0] - n[0]) * (t[1] - e[1]); if (0 == i) return null; let o = ((r[0] - n[0]) * (e[1] - n[1]) - (r[1] - n[1]) * (e[0] - n[0])) / i, a = ((t[0] - e[0]) * (e[1] - n[1]) - (t[1] - e[1]) * (e[0] - n[0])) / i; return o < 0 || a < 0 || o > 1 || a > 1 ? null : [e[0] + o * (t[0] - e[0]), e[1] + o * (t[1] - e[1])] } static appendArc(e, t, n, r, i, o = !1) { let a = [...e], s = Math.atan2(r[1] - t[1], r[0] - t[0]), l = Math.atan2(i[1] - t[1], i[0] - t[0]); s < 0 && (s += sx), l < 0 && (l += sx); let c = s > l ? s - l : s + sx - l, u = (o ? -c : sx - c) / 5; a.push(r); for (let e = 1; e < 5; ++e) { let r = s + u * e; a.push([t[0] + Math.cos(r) * n, t[1] + Math.sin(r) * n]) } return a.push(i), a } static createOffsetEdge(e, t) { return e.map((e => B.add(e, t))) } static getOffsetPolygon(e, t = 0) { let n = lx.getEdges(e), r = n.map((e => lx.createOffsetEdge(e, B.mul(lx.outwardEdgeNormal(e), t)))), i = []; for (let e = 0; e < r.length; e++) { let o = r[e], a = r[(e + r.length - 1) % r.length], s = lx.edgesIntersection(a, o); s ? i.push(s) : lx.appendArc(i, n[e][0], t, a[1], o[0], !1) } return i } static createPaddingPolygon(e, t = 0) { let n = e.map((e => lx.createOffsetEdge(e, lx.inwardEdgeNormal(e)))), r = []; for (let i = 0; i < n.length; i++) { let o = n[i], a = n[(i + n.length - 1) % n.length], s = lx.edgesIntersection(a, o); s ? r.push(s) : lx.appendArc(r, e[i][0], t, a[1], o[0], !0) } return r } }; kE(lx, "leftSide", B.isLeft); var cx = "#fafafa", ux = "#343d45", dx = { white: "#f0f1f3", lightGray: "#c6cbd1", gray: "#788492", black: "#1d1d1d", green: "#36b24d", cyan: "#0e98ad", blue: "#1c7ed6", indigo: "#4263eb", violet: "#7746f1", red: "#ff2133", orange: "#ff9433", yellow: "#ffc936" }, px = { light: CE(EE({}, Object.fromEntries(Object.entries(dx).map((([e, t]) => [e, Zt.lerpColor(t, cx, .45)])))), { white: "#ffffff", black: "#3d3d3d" }), dark: CE(EE({}, Object.fromEntries(Object.entries(dx).map((([e, t]) => [e, Zt.lerpColor(Zt.lerpColor(t, "#999999", .3), ux, .4)])))), { white: "#1d1d1d", black: "#bbbbbb" }) }, hx = { light: CE(EE({}, dx), { white: "#1d1d1d" }), dark: CE(EE({}, Object.fromEntries(Object.entries(dx).map((([e, t]) => [e, Zt.lerpColor(t, ux, .1)])))), { white: "#cecece", black: "#cecece" }) }, fx = { light: CE(EE({}, Object.fromEntries(Object.entries(dx).map((([e, t]) => [e, Zt.lerpColor(t, cx, .82)])))), { white: "#fefefe" }), dark: CE(EE({}, Object.fromEntries(Object.entries(dx).map((([e, t]) => [e, Zt.lerpColor(t, ux, .82)])))), { white: "rgb(30,33,37)", black: "#1e1e1f" }) }, mx = { small: 2, medium: 3.5, large: 5 }, gx = { small: 28, medium: 48, large: 96, auto: "auto" }, vx = { script: '"Caveat Brush"', sans: '"Source Sans Pro"', serif: '"Crimson Pro"', mono: '"Source Code Pro"' }, yx = { script: 1, sans: 1, serif: 1, mono: 1 }, bx = { small: 24, medium: 36, large: 48, auto: "auto" }; function wx(e, t = "script") { return gx[e] * yx[t] } function Ex(e = "script") { return vx[e] } function Cx(e) { return bx[e] } function Sx(e) { let t = wx(e.size, e.font), n = Ex(e.font), { scale: r = 1 } = e; return `${t * r}px/1 ${n}` } function kx(e, t = !1) { let { color: n } = e, r = t ? "dark" : "light", i = "white" === n || "black" === n ? "yellow" : n; return { fill: px[r][i], stroke: hx[r][i], color: t ? "#1d1d1d" : "#0d0d0d" } } function xx(e, t) { let { color: n, size: r, isFilled: i } = e, o = function (e) { return mx[e] }(r), a = t ? "dark" : "light"; return { stroke: hx[a][n], fill: i ? fx[a][n] : "none", strokeWidth: o } } var Ax = { color: "black", size: "small", isFilled: !1, dash: "draw", scale: 1 }, Ix = CE(EE({}, Ax), { font: "script", textAlign: "middle" }), Px = class { static insertTextFirefox(e, t) { e.setRangeText(t, e.selectionStart || 0, e.selectionEnd || 0, "end"), e.dispatchEvent(new InputEvent("input", { data: t, inputType: "insertText", isComposing: !1 })) } static insert(e, t) { let n = e.ownerDocument, r = n.activeElement; r !== e && e.focus(), n.execCommand("insertText", !1, t) || Px.insertTextFirefox(e, t), r === n.body ? e.blur() : r instanceof HTMLElement && r !== e && r.focus() } static set(e, t) { e.select(), Px.insert(e, t) } static getSelection(e) { let { selectionStart: t, selectionEnd: n } = e; return e.value.slice(t || void 0, n || void 0) } static wrapSelection(e, t, n) { let { selectionStart: r, selectionEnd: i } = e, o = Px.getSelection(e); Px.insert(e, t + o + (null != n ? n : t)), e.selectionStart = (r || 0) + t.length, e.selectionEnd = (i || 0) + t.length } static replace(e, t, n) { let r = 0; e.value.replace(t, ((...t) => { let i = r + t[t.length - 2], o = t[0].length; e.selectionStart = i, e.selectionEnd = i + o; let a = "string" == typeof n ? n : n(...t); return Px.insert(e, a), e.selectionStart = i, r += a.length - o, a })) } static findLineEnd(e, t) { let n = e.lastIndexOf("\n", t - 1) + 1; return "\t" !== e.charAt(n) ? t : n + 1 } static indent(e) { var t; let { selectionStart: n, selectionEnd: r, value: i } = e, o = i.slice(n, r), a = null == (t = /\n/g.exec(o)) ? void 0 : t.length; if (a && a > 0) { let t = i.lastIndexOf("\n", n - 1) + 1, o = e.value.slice(t, r - 1), a = o.replace(/^|\n/g, "$&  "), s = a.length - o.length; e.setSelectionRange(t, r - 1), Px.insert(e, a), e.setSelectionRange(n + 1, r + s) } else Px.insert(e, "  ") } static unindent(e) { let { selectionStart: t, selectionEnd: n, value: r } = e, i = r.lastIndexOf("\n", t - 1) + 1, o = Px.findLineEnd(r, n), a = e.value.slice(i, o), s = a.replace(/(^|\n)(\t| {1,2})/g, "$1"), l = a.length - s.length; e.setSelectionRange(i, o), Px.insert(e, s); let c = /\t| {1,2}/.exec(r.slice(i, t)), u = c ? c[0].length : 0, d = t - u; e.setSelectionRange(t - u, Math.max(d, n - l)) } }, Mx = A.memo((function ({ font: e, text: t, color: n, offsetX: r = 0, offsetY: i = 0, scale: o = 1, isEditing: a = !1, onBlur: s, onChange: l }) { let c = A.useRef(null), u = A.useRef(!1), d = A.useCallback((e => { l(ZA.normalizeText(e.currentTarget.value)) }), [l]), p = A.useCallback((e => { if ("Escape" === e.key) return e.preventDefault(), e.stopPropagation(), void (null == s || s()); if ("Tab" !== e.key || 0 !== t.length) { if ("Meta" === e.key || e.metaKey) { if ("z" === e.key && e.metaKey) return e.shiftKey ? document.execCommand("redo", !1) : document.execCommand("undo", !1), e.stopPropagation(), void e.preventDefault() } else e.stopPropagation(); (e.metaKey || e.ctrlKey) && "=" === e.key && e.preventDefault(), "Tab" === e.key && (e.preventDefault(), e.shiftKey ? Px.unindent(e.currentTarget) : Px.indent(e.currentTarget), null == l || l(ZA.normalizeText(e.currentTarget.value))) } else e.preventDefault() }), [l]), h = A.useCallback((e => { e.currentTarget.setSelectionRange(0, 0), null == s || s() }), [s]), f = A.useCallback((e => { !a || !u.current || document.activeElement === e.currentTarget && e.currentTarget.select() }), [a]), m = A.useCallback((e => { a && e.stopPropagation() }), [a]), g = A.useRef(a); A.useEffect((() => { a ? (g.current = !0, requestAnimationFrame((() => { u.current = !0; let e = c.current; e && (e.focus(), e.select()) }))) : g.current && (null == s || s(), g.current = !1) }), [a, s]); let v = A.useRef(null); return A.useLayoutEffect((() => { let n = v.current; if (!n) return; let a = rx(t, e); n.style.transform = `scale(${o}, ${o}) translate(${r}px, ${i}px)`, n.style.width = a[0] + 1 + "px", n.style.height = a[1] + 1 + "px" }), [t, e, i, r, o]), A.createElement(Tx, null, A.createElement(Bx, { ref: v, hasText: !!t, isEditing: a, style: { font: e, color: n } }, a ? A.createElement(Dx, { ref: c, style: { font: e, color: n }, name: "text", tabIndex: -1, autoComplete: "false", autoCapitalize: "false", autoCorrect: "false", autoSave: "false", autoFocus: !0, placeholder: "", spellCheck: "true", wrap: "off", dir: "auto", datatype: "wysiwyg", defaultValue: t, color: n, onFocus: f, onChange: d, onKeyDown: p, onBlur: h, onPointerDown: m, onContextMenu: yS, onCopy: yS, onPaste: yS, onCut: yS }) : t, "")) })), Tx = AE("div", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", display: "flex", alignItems: "center", justifyContent: "center", pointerEvents: "none", userSelect: "none", variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: .3 } } } }), Rx = { whiteSpace: "pre-wrap", overflowWrap: "break-word", letterSpacing: jk }, Bx = AE("div", EE({ position: "absolute", padding: "4px", zIndex: 1, minHeight: 1, minWidth: 1, lineHeight: 1, outline: 0, fontWeight: "500", textAlign: "center", backfaceVisibility: "hidden", userSelect: "none", WebkitUserSelect: "none", WebkitTouchCallout: "none", variants: { hasText: { false: { pointerEvents: "none" }, true: { pointerEvents: "all" } }, isEditing: { false: { userSelect: "none" }, true: { background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text" } } } }, Rx)), Dx = AE("textarea", CE(EE({ position: "absolute", top: 0, left: 0, zIndex: 1, width: "100%", height: "100%", border: "none", padding: "4px", resize: "none", textAlign: "inherit", minHeight: "inherit", minWidth: "inherit", lineHeight: "inherit", outline: 0, fontWeight: "inherit", overflow: "hidden", backfaceVisibility: "hidden", display: "inline-block", pointerEvents: "all", background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text", fontSmooth: "always", WebkitFontSmoothing: "subpixel-antialiased", MozOsxFontSmoothing: "auto" }, Rx), { "&:focus": { outline: "none", border: "none" } })); function Lx(e, t, { initialShape: n, transformOrigin: r, scaleX: i, scaleY: o }) { return e.rotation || n.isAspectRatioLocked ? { size: B.toFixed(B.mul(n.size, Math.min(Math.abs(i), Math.abs(o)))), point: B.toFixed([t.minX + (t.width - e.size[0]) * (i < 0 ? 1 - r[0] : r[0]), t.minY + (t.height - e.size[1]) * (o < 0 ? 1 - r[1] : r[1])]), rotation: i < 0 && o >= 0 || o < 0 && i >= 0 ? n.rotation ? -n.rotation : 0 : n.rotation } : { point: B.toFixed([t.minX, t.minY]), size: B.toFixed([t.width, t.height]) } } function Ox(e, t) { return { size: B.toFixed([t.width, t.height]), point: B.toFixed([t.minX, t.minY]) } } var Fx = class extends Gn { constructor() { super(...arguments), kE(this, "canBind", !1), kE(this, "canEdit", !1), kE(this, "canClone", !1), kE(this, "isAspectRatioLocked", !1), kE(this, "hideResizeHandles", !1), kE(this, "bindingDistance", 16), kE(this, "hitTestPoint", ((e, t) => Zt.pointInBounds(t, this.getRotatedBounds(e)))), kE(this, "hitTestLineSegment", ((e, t, n) => { let r = Zt.getBoundsFromPoints([t, n]), i = this.getBounds(e); return Zt.boundsContain(i, r) || e.rotation ? Ct(t, n, Zt.getRotatedCorners(this.getBounds(e))).didIntersect : Et(t, n, this.getBounds(e)).length > 0 })), kE(this, "create", (e => (this.refMap.set(e.id, A.createRef()), this.getShape(e)))), kE(this, "getCenter", (e => Zt.getBoundsCenter(this.getBounds(e)))), kE(this, "getExpandedBounds", (e => Zt.expandBounds(this.getBounds(e), this.bindingDistance))), kE(this, "getBindingPoint", ((e, t, n, r, i, o) => { let a = this.getBounds(e), s = this.getExpandedBounds(e); if (!Zt.pointInBounds(n, s)) return; let l = vt(r, i, s).filter((e => e.didIntersect)).map((e => e.points[0])); if (!l.length) return; let c, u, d = this.getCenter(e), p = l.sort(((e, t) => R.dist(t, r) - R.dist(e, r)))[0], h = R.med(n, p); o ? (c = R.dist(n, d) < 8 ? d : n, u = 0) : (c = R.distanceToLineSegment(n, h, d) < 8 ? d : h, u = Zt.pointInBounds(n, a) ? this.bindingDistance : Math.max(this.bindingDistance, Zt.getBoundsSides(a).map((e => R.distanceToLineSegment(e[1][0], e[1][1], n))).sort(((e, t) => e - t))[0])); let f = R.divV(R.sub(c, [s.minX, s.minY]), [s.width, s.height]); return { point: R.clampV(f, 0, 1), distance: u } })), kE(this, "mutate", ((e, t) => t)), kE(this, "transform", ((e, t, n) => CE(EE({}, e), { point: [t.minX, t.minY] }))), kE(this, "transformSingle", ((e, t, n) => this.transform(e, t, n))), kE(this, "updateChildren"), kE(this, "onChildrenChange"), kE(this, "onHandleChange"), kE(this, "onRightPointHandle"), kE(this, "onDoubleClickHandle"), kE(this, "onDoubleClickBoundsHandle"), kE(this, "onSessionComplete"), kE(this, "getSvgElement", ((e, t) => { var n, r, i, o, a; let s = null == (n = document.getElementById(e.id + "_svg")) ? void 0 : n.cloneNode(!0); if (s) { if (null != (o = null == (i = null == (r = e.label) ? void 0 : r.trim()) ? void 0 : i.length) && o) { let n = e, r = document.createElementNS("http://www.w3.org/2000/svg", "g"), i = Sx(e.style), o = rx(e.label, i), l = wx(e.style.size, e.style.font) * (null != (a = e.style.scale) ? a : 1), c = Ex(e.style.font).slice(1, -1), u = ox(n.label, l, c, "middle", o[0], !1), d = this.getBounds(e); return u.setAttribute("transform", `translate(${d.width / 2 - o[0] / 2}, ${d.height / 2 - o[1] / 2})`), u.setAttribute("fill", xx(e.style, t).stroke), u.setAttribute("transform-origin", "center center"), r.setAttribute("text-align", "center"), r.setAttribute("text-anchor", "middle"), r.appendChild(s), r.appendChild(u), r } return s } })) } }; function zx(e, t) { let { start: n, end: r } = e, i = B.dist(n.point, r.point), o = B.med(n.point, r.point), a = i / 2 * t, s = B.uni(B.vec(n.point, r.point)); return B.toFixed(Math.abs(a) < 10 ? o : B.add(o, B.mul(B.per(s), a))) } function Hx(e, t, n) { return Zt.circleFromThreePoints(e, n, t) } function Nx(e, t, n, r, i) { let o = function (e, t, n, r) { let i = n[0] - e[0], o = n[1] - e[1], a = Math.sqrt(i * i + o * o), s = (a * a - r * r + t * t) / (2 * a), l = Math.sqrt(t * t - s * s); return i /= a, o /= a, ht("intersection", [e[0] + i * s - o * l, e[1] + o * s + i * l], [e[0] + i * s + o * l, e[1] + o * s - i * l]) }(e, .618 * t, n, r).points; if (!o) return ZA.warn("Could not find an intersection for the arrow head."), { left: e, right: e }; let a = i ? o[0] : o[1]; return { left: a ? B.nudge(B.rotWith(a, e, Math.PI / 6), e, -.382 * t) : e, right: a ? B.nudge(B.rotWith(a, e, -Math.PI / 6), e, -.382 * t) : e } } function jx(e, t, n) { let r = function (e, t, n, r) { return bt(n, r, e, t) }(e, n, e, t).points; if (!r) return ZA.warn("Could not find an intersection for the arrow head."), { left: e, right: e }; let i = r[0]; return { left: i ? B.rotWith(i, e, Math.PI / 6) : e, right: i ? B.rotWith(i, e, -Math.PI / 6) : e } } function Ux(e, t, n, r, i) { let { left: o, right: a } = Nx(e, t, n, r, i); return `M ${o} L ${e} ${a}` } function Vx(e, t, n) { let { left: r, right: i } = jx(e, t, n); return `M ${r} L ${e} ${i}` } function Kx(e, t, n, r, i, o) { let { strokeWidth: a } = xx(e, !1), s = B.dist(t, r), l = Math.min(s / 3, 8 * a), c = []; if (B.dist(n, B.toFixed(B.med(t, r))) < 1) c.push(`M ${t} L ${r}`), i && c.push(Vx(t, r, l)), o && c.push(Vx(r, t, l)); else { let e = Hx(t, n, r), a = [e[0], e[1]], s = e[2], u = Yx(a, s, t, r); c.push(`M ${t} A ${s} ${s} 0 0 ${u > 0 ? "1" : "0"} ${r}`), i && c.push(Ux(t, l, a, s, u < 0)), o && c.push(Ux(r, l, a, s, u >= 0)) } return c.join(" ") } function Wx(e, t, n) { if (B.dist2(t, B.med(e, n)) <= 4) return [e, n]; let r = [], i = Hx(e, t, n), o = [i[0], i[1]], a = i[2], s = B.angle(o, e), l = B.angle(o, n); for (let e = 0; e < 20; e++) { let t = e / 19, n = Zt.lerpAngles(s, l, t); r.push(B.nudgeAtAngle(o, n, a)) } return r } function Yx(e, t, n, r) { let i = Zt.getSweep(e, n, r); return t * (2 * Math.PI) * (i / (2 * Math.PI)) } function Gx({ left: e, middle: t, right: n, stroke: r, strokeWidth: i }) { return A.createElement("g", null, A.createElement("path", { className: "tl-stroke-hitarea", d: `M ${e} L ${t} ${n}` }), A.createElement("path", { d: `M ${e} L ${t} ${n}`, fill: "none", stroke: r, strokeWidth: i, strokeLinecap: "round", strokeLinejoin: "round", pointerEvents: "none" })) } var Zx = A.memo((function ({ id: e, style: t, start: n, bend: r, end: i, arrowBend: o, decorationStart: a, decorationEnd: s, isDraw: l, isDarkMode: c }) { let u = B.dist(n, i); if (u < 2) return null; let d = xx(t, c), { strokeWidth: p } = d, h = 1 + 1.618 * p, f = Hx(n, r, i), m = [f[0], f[1]], g = f[2], v = Yx(m, g, n, i), y = Zt.rng(e), b = Kk[y() > 0 ? "easeInOutSine" : "easeInOutCubic"], w = l ? function (e, t, n, r, i, o, a, s, l, c) { let u = Zt.rng(e), d = xx(t).strokeWidth, p = i ? B.rotWith(n, a, d / l) : n, h = o ? B.rotWith(r, a, -d / l) : r, f = B.angle(a, p), m = B.angle(a, h), g = [], v = 8 + Math.floor(Math.abs(l) / 20 * 1 + u() / 2); for (let e = 0; e < v; e++) { let t = c(e / v), n = Zt.lerpAngles(f, m, t); g.push(B.toFixed(B.nudgeAtAngle(a, n, s))) } let y = rt([p, ...g, h], { size: 1 + d, thinning: .618 + .2 * u(), easing: Kk.easeOutQuad, simulatePressure: !1, streamline: 0, last: !0 }); return Zt.getSvgPathFromStroke(y) }(e, t, n, i, a, s, m, g, v, b) : function (e, t, n, r) { return ["M", e[0], e[1], "A", n[2], n[2], 0, 0, r < 0 ? 0 : 1, t[0], t[1]].join(" ") }(n, i, f, o), { strokeDasharray: E, strokeDashoffset: C } = Zt.getPerfectDashProps(Math.abs(v), h, t.dash, 2, !1), S = Math.min(u / 3, 8 * p), k = a ? Nx(n, S, m, g, v < 0) : null, x = s ? Nx(i, S, m, g, v >= 0) : null; return A.createElement(A.Fragment, null, A.createElement("path", { className: "tl-stroke-hitarea", d: w }), A.createElement("path", { d: w, fill: l ? d.stroke : "none", stroke: d.stroke, strokeWidth: l ? 0 : h, strokeDasharray: E, strokeDashoffset: C, strokeLinecap: "round", strokeLinejoin: "round", pointerEvents: "none" }), k && A.createElement(Gx, { left: k.left, middle: n, right: k.right, stroke: d.stroke, strokeWidth: h }), x && A.createElement(Gx, { left: x.left, middle: i, right: x.right, stroke: d.stroke, strokeWidth: h })) })), Xx = A.memo((function ({ id: e, style: t, start: n, end: r, decorationStart: i, decorationEnd: o, isDraw: a, isDarkMode: s }) { let l = B.dist(n, r); if (l < 2) return null; let c = xx(t, s), { strokeWidth: u } = c, d = 1 + 1.618 * u, p = a ? function (e, t, n, r, i, o) { let a = Zt.rng(e), s = xx(t).strokeWidth, l = i ? B.nudge(n, r, s) : n, c = o ? B.nudge(r, n, s) : r, u = rt([l, c], { size: s, thinning: .618 + .2 * a(), easing: Kk.easeOutQuad, simulatePressure: !0, streamline: 0, last: !0 }); return Zt.getSvgPathFromStroke(u) }(e, t, n, r, i, o) : "M" + B.toFixed(n) + "L" + B.toFixed(r), { strokeDasharray: h, strokeDashoffset: f } = Zt.getPerfectDashProps(l, 1.618 * u, t.dash, 2, !1), m = Math.min(l / 3, 8 * u), g = i ? jx(n, r, m) : null, v = o ? jx(r, n, m) : null; return A.createElement(A.Fragment, null, A.createElement("path", { className: "tl-stroke-hitarea", d: p }), A.createElement("path", { d: p, fill: c.stroke, stroke: c.stroke, strokeWidth: a ? d / 2 : d, strokeDasharray: h, strokeDashoffset: f, strokeLinecap: "round", strokeLinejoin: "round", pointerEvents: "stroke" }), g && A.createElement(Gx, { left: g.left, middle: n, right: g.right, stroke: c.stroke, strokeWidth: d }), v && A.createElement(Gx, { left: v.left, middle: r, right: v.right, stroke: c.stroke, strokeWidth: d })) })), _x = AE("div", { width: "100%", height: "100%" }), Qx = { easing: e => Math.sin(e * Math.PI / 2), simulatePressure: !0 }, qx = { easing: e => e * e, simulatePressure: !1 }; function Jx(e) { let t = xx(e.style); return CE(EE({ size: 1 + 1.5 * t.strokeWidth, thinning: .65, streamline: .65, smoothing: .65 }, .5 === e.points[1][2] ? Qx : qx), { last: e.isComplete }) } function $x(e, t) { return nt(e.points, t) } function eA(e) { let { points: t } = e; if (t.length < 2) return "M 0 0 L 0 0"; let n = $x(e, Jx(e)), r = t[t.length - 1]; return B.isEqual(n[0].point, r) || n.push({ point: r }), Zt.getSvgPathFromStrokePoints(n) } var tA = A.memo((function ({ radius: e, style: t, isSelected: n, isDarkMode: r }) { let { stroke: i, strokeWidth: o, fill: a } = xx(t, r), s = 1 + 1.618 * o, l = Math.max(0, e[0] - s / 2), c = Math.max(0, e[1] - s / 2), u = Zt.perimeterOfEllipse(l, c), { strokeDasharray: d, strokeDashoffset: p } = Zt.getPerfectDashProps(u < 64 ? 2 * u : u, 1.618 * o, t.dash, 4); return A.createElement(A.Fragment, null, A.createElement("ellipse", { className: t.isFilled || n ? "tl-fill-hitarea" : "tl-stroke-hitarea", cx: e[0], cy: e[1], rx: e[0], ry: e[1] }), A.createElement("ellipse", { cx: e[0], cy: e[1], rx: l, ry: c, fill: a, stroke: i, strokeWidth: s, strokeDasharray: d, strokeDashoffset: p, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round" })) })); function nA(e, t, n) { let { strokeWidth: r } = xx(n), i = Zt.rng(e), o = t[0] + i() * r * 2, a = t[1] + i() * r * 2, s = Zt.perimeterOfEllipse(o, a), l = [], c = Math.PI + Math.PI * i(), u = Math.abs(i()), d = Math.max(16, s / 10); for (let e = 0; e < d; e++) { let n = Kk.easeInOutSine(e / (d + 1)), r = 2 * c + Math.PI * (2 + u) * n, s = Math.cos(r), p = Math.sin(r); l.push([o * s + t[0], a * p + t[1], n + .5 + i() / 2]) } return nt(l, { size: 1 + 2 * r, thinning: .618, end: { taper: s / 8 }, start: { taper: s / 12 }, streamline: 0, simulatePressure: !0 }) } function rA(e, t, n) { return Zt.getSvgPathFromStrokePoints(nA(e, t, n)) } var iA = A.memo((function ({ id: e, radius: t, style: n, isSelected: r, isDarkMode: i }) { let { stroke: o, strokeWidth: a, fill: s } = xx(n, i), l = function (e, t, n) { let { strokeWidth: r } = xx(n), i = Zt.rng(e), o = t[0] + i() * r * 2, a = t[1] + i() * r * 2, s = Zt.perimeterOfEllipse(o, a); return Zt.getSvgPathFromStroke(tt(nA(e, t, n), { size: 2 + 2 * r, thinning: .618, end: { taper: s / 8 }, start: { taper: s / 12 }, streamline: 0, simulatePressure: !0 })) }(e, t, n); return A.createElement(A.Fragment, null, A.createElement("ellipse", { className: n.isFilled || r ? "tl-fill-hitarea" : "tl-stroke-hitarea", cx: t[0], cy: t[1], rx: t[0], ry: t[1] }), n.isFilled && A.createElement("path", { d: rA(e, t, n), stroke: "none", fill: s, pointerEvents: "none" }), A.createElement("path", { d: l, fill: o, stroke: o, strokeWidth: a, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round" })) })), oA = AE("div", { width: "100%", height: "100%" }), aA = AE("g", { strokeWidth: "calc(1.5px * var(--tl-scale))", strokeDasharray: "calc(1px * var(--tl-scale)), calc(3px * var(--tl-scale))" }), sA = Qh("div", { pointerEvents: "all", position: "relative", fontFamily: "sans-serif", fontSize: "2em", height: "100%", width: "100%", borderRadius: "3px", perspective: "800px", overflow: "hidden", p: { userSelect: "none" }, img: { userSelect: "none" }, variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: .3 } }, isFilled: { true: {}, false: {} }, isDarkMode: { true: {}, false: {} } }, compoundVariants: [{ isFilled: !0, isDarkMode: !0, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)" } }, { isFilled: !0, isDarkMode: !1, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)" } }] }), lA = Qh("img", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", maxWidth: "100%", minWidth: "100%", pointerEvents: "none", objectFit: "cover", userSelect: "none", borderRadius: 2 }); function cA({ strokeWidth: e, size: t }) { return A.createElement("rect", { className: "tl-binding-indicator", x: e, y: e, width: Math.max(0, t[0] - e / 2), height: Math.max(0, t[1] - e / 2), strokeWidth: 32 }) } var uA = A.memo((function ({ id: e, style: t, size: n, isSelected: r, isDarkMode: i }) { let { stroke: o, strokeWidth: a, fill: s } = xx(t, i), l = 1 + 1.618 * a, c = Math.max(0, n[0] - l / 2), u = Math.max(0, n[1] - l / 2), d = [[[l / 2, l / 2], [c, l / 2], c - l / 2], [[c, l / 2], [c, u], u - l / 2], [[c, u], [l / 2, u], c - l / 2], [[l / 2, u], [l / 2, l / 2], u - l / 2]].map((([n, r, i], o) => { let { strokeDasharray: s, strokeDashoffset: l } = Zt.getPerfectDashProps(i, 1.618 * a, t.dash); return A.createElement("line", { key: e + "_" + o, x1: n[0], y1: n[1], x2: r[0], y2: r[1], strokeDasharray: s, strokeDashoffset: l }) })); return A.createElement(A.Fragment, null, A.createElement("rect", { className: r || t.isFilled ? "tl-fill-hitarea" : "tl-stroke-hitarea", x: l / 2, y: l / 2, width: c, height: u, strokeWidth: 16 }), t.isFilled && A.createElement("rect", { x: l / 2, y: l / 2, width: c, height: u, fill: s, pointerEvents: "none" }), A.createElement("g", { pointerEvents: "none", stroke: o, strokeWidth: l, strokeLinecap: "round" }, d)) })); function dA(e, t, n) { let { points: r } = function (e, t, n) { let r = xx(t), i = Zt.rng(e), o = r.strokeWidth, a = Math.max(0, n[0]), s = Math.max(0, n[1]), l = Array.from(Array(4)).map((() => [i() * o * .75, i() * o * .75])), c = B.add([o / 2, o / 2], l[0]), u = B.add([a - o / 2, o / 2], l[1]), d = B.add([a - o / 2, s - o / 2], l[2]), p = B.add([o / 2, s - o / 2], l[3]), h = Math.round(Math.abs(2 * i() * 4)), f = Math.min(a / 4, 2 * o), m = Math.min(s / 4, 2 * o), g = Math.max(8, Math.floor(a / 16)), v = Math.max(8, Math.floor(s / 16)), y = Zt.rotateArray([B.pointsBetween(B.add(c, [f, 0]), B.sub(u, [f, 0]), g), B.pointsBetween(B.add(u, [0, m]), B.sub(d, [0, m]), v), B.pointsBetween(B.sub(d, [f, 0]), B.add(p, [f, 0]), g), B.pointsBetween(B.sub(p, [0, m]), B.add(c, [0, m]), v)], h); return { points: [...y.flat(), ...y[0]].slice(5, Math.floor((h % 2 == 0 ? g : v) / -2) + 3) } }(e, t, n), { strokeWidth: i } = xx(t); return { points: r, options: { size: i, thinning: .65, streamline: .3, smoothing: 1, simulatePressure: !1, last: !0 } } } function pA(e, t, n) { let { points: r, options: i } = dA(e, t, n); return Zt.getSvgPathFromStrokePoints(nt(r, i)) } var hA, fA = A.memo((function ({ id: e, style: t, size: n, isSelected: r, isDarkMode: i }) { let { isFilled: o } = t, { stroke: a, strokeWidth: s, fill: l } = xx(t, i), c = function (e, t, n) { let { points: r, options: i } = dA(e, t, n), o = rt(r, i); return Zt.getSvgPathFromStroke(o) }(e, t, n), u = pA(e, t, n); return A.createElement(A.Fragment, null, A.createElement("path", { className: t.isFilled || r ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: u }), o && A.createElement("path", { d: u, fill: l, pointerEvents: "none" }), A.createElement("path", { d: c, fill: a, stroke: a, strokeWidth: s, pointerEvents: "none" })) })), mA = AE("div", { width: "100%", height: "100%" }), gA = 16, vA = AE("div", { pointerEvents: "all", position: "relative", backgroundColor: "rgba(255, 220, 100)", fontFamily: "sans-serif", height: "100%", width: "100%", padding: "16px", borderRadius: "3px", perspective: "800px", variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: .3 } }, isDarkMode: { true: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)" }, false: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)" } } } }), yA = { whiteSpace: "pre-wrap", overflowWrap: "break-word", letterSpacing: jk }, bA = AE("div", EE({ position: "absolute", top: gA, left: gA, width: "calc(100% - 32px)", height: "fit-content", font: "inherit", pointerEvents: "none", userSelect: "none", variants: { isEditing: { true: { opacity: 1 }, false: { opacity: 1 } }, alignment: { start: { textAlign: "left" }, middle: { textAlign: "center" }, end: { textAlign: "right" }, justify: { textAlign: "justify" } } } }, yA)), wA = AE("textarea", CE(EE({ width: "100%", height: "100%", border: "none", overflow: "hidden", background: "none", outline: "none", textAlign: "left", font: "inherit", padding: 0, color: "transparent", verticalAlign: "top", resize: "none", caretColor: "black" }, yA), { variants: { alignment: { start: { textAlign: "left" }, middle: { textAlign: "center" }, end: { textAlign: "right" }, justify: { textAlign: "justify" } } }, "&:focus": { outline: "none", border: "none" } })); "undefined" != typeof window && (hA = function () { var e; null == (e = document.getElementById("__textMeasure")) || e.remove(); let t = document.createElement("pre"); return t.id = "__textMeasure", Object.assign(t.style, { whiteSpace: "pre", width: "auto", border: "1px solid transparent", padding: "4px", margin: "0px", letterSpacing: jk, opacity: "0", position: "absolute", top: "-500px", left: "0px", zIndex: "9999", pointerEvents: "none", userSelect: "none", alignmentBaseline: "mathematical", dominantBaseline: "mathematical" }), t.tabIndex = -1, document.body.appendChild(t), t }()); var EA = AE("div", { width: "100%", height: "100%", variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: .3 } }, isEditing: { false: { pointerEvents: "all", userSelect: "all" }, true: { pointerEvents: "none", userSelect: "none" } } } }), CA = { whiteSpace: "pre-wrap", overflowWrap: "break-word" }, SA = AE("div", EE({ position: "absolute", width: "100%", height: "100%", padding: "4px", zIndex: 1, minHeight: 1, minWidth: 1, lineHeight: 1, letterSpacing: jk, outline: 0, fontWeight: "500", backfaceVisibility: "hidden", userSelect: "none", pointerEvents: "none", WebkitUserSelect: "none", WebkitTouchCallout: "none", isEditing: { false: {}, true: { pointerEvents: "all", background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text" } } }, CA)), kA = AE("textarea", CE(EE({ position: "absolute", top: 0, left: 0, zIndex: 1, width: "100%", height: "100%", border: "none", padding: "4px", resize: "none", textAlign: "inherit", minHeight: "inherit", minWidth: "inherit", lineHeight: "inherit", letterSpacing: "inherit", outline: 0, fontWeight: "inherit", overflow: "hidden", backfaceVisibility: "hidden", display: "inline-block", pointerEvents: "all", background: "$boundsBg", userSelect: "text", WebkitUserSelect: "text" }, CA), { "&:focus": { outline: "none", border: "none" } })); function xA(e, t = 0, n = 0) { let [r, i] = e, o = [[r / 2, 0], [r, i], [0, i]]; return t && (o = function (e, t) { if (e.length < 3) throw Error("Polygon must have at least 3 points"); let n = e.length; return e.map(((t, r) => [t, e[(r + 1) % n]])).map((([e, n]) => { let r = B.mul(B.per(B.uni(B.sub(n, e))), t); return [B.add(e, r), B.add(n, r)] })).map(((e, t, n) => { let r = function (e, t) { let n = R.slope(e[0], e[1]), r = R.slope(t[0], t[1]); if (n === r) return; if (Number.isNaN(n) && !Number.isNaN(r)) return [e[0][0], (e[0][0] - t[0][0]) * r + t[0][1]]; if (Number.isNaN(r) && !Number.isNaN(n)) return [t[0][0], (t[0][0] - e[0][0]) * n + e[0][1]]; let i = (n * e[0][0] - r * t[0][0] + t[0][1] - e[0][1]) / (n - r); return [i, r * (i - t[0][0]) + t[0][1]] }(e, n[(t + 1) % n.length]); if (void 0 === r) throw Error("Expected an intersection"); return r })) }(o, t)), n && (o = o.map((e => B.rotWith(e, [r / 2, i / 2], n)))), o } function AA(e) { let [t, n] = e, r = [[t / 2, 0], [t, n], [0, n]]; return [(r[0][0] + r[1][0] + r[2][0]) / 3, (r[0][1] + r[1][1] + r[2][1]) / 3] } function IA(e, t, n) { let { strokeWidth: r } = xx(n), { points: i } = function (e, t, n) { let [r, i] = t, o = Zt.rng(e), a = Array.from(Array(3)).map((() => [o() * n * .75, o() * n * .75])), s = [B.add([r / 2, 0], a[0]), B.add([r, i], a[1]), B.add([0, i], a[2])], l = Math.round(Math.abs(2 * o() * 3)), c = Zt.rotateArray([B.pointsBetween(s[0], s[1], 32), B.pointsBetween(s[1], s[2], 32), B.pointsBetween(s[2], s[0], 32)], l); return { points: [...c.flat(), ...c[0]] } }(e, t, r); return { points: i, options: { size: r, thinning: .65, streamline: .3, smoothing: 1, simulatePressure: !1, last: !0 } } } var PA = A.memo((function ({ id: e, size: t, style: n, isSelected: r, isDarkMode: i }) { let { stroke: o, strokeWidth: a, fill: s } = xx(n, i), l = 1 + 1.618 * a, c = xA(t), u = Zt.pointsToLineSegments(c, !0).map((([t, r], i) => { let { strokeDasharray: s, strokeDashoffset: c } = Zt.getPerfectDashProps(B.dist(t, r), 1.618 * a, n.dash); return A.createElement("line", { key: e + "_" + i, x1: t[0], y1: t[1], x2: r[0], y2: r[1], stroke: o, strokeWidth: l, strokeLinecap: "round", strokeDasharray: s, strokeDashoffset: c }) })), d = c.join(); return A.createElement(A.Fragment, null, A.createElement("polygon", { className: n.isFilled || r ? "tl-fill-hitarea" : "tl-stroke-hitarea", points: d }), n.isFilled && A.createElement("polygon", { fill: s, points: d, pointerEvents: "none" }), A.createElement("g", { pointerEvents: "stroke" }, u)) })), MA = A.memo((function ({ id: e, size: t, style: n, isSelected: r, isDarkMode: i }) { let { stroke: o, strokeWidth: a, fill: s } = xx(n, i), l = function (e, t, n) { let { points: r, options: i } = IA(e, t, n), o = rt(r, i); return Zt.getSvgPathFromStroke(o) }(e, t, n), c = function (e, t, n) { let { points: r, options: i } = IA(e, t, n); return Zt.getSvgPathFromStrokePoints(nt(r, i)) }(e, t, n); return A.createElement(A.Fragment, null, A.createElement("path", { className: n.isFilled || r ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: c }), n.isFilled && A.createElement("path", { d: c, fill: s, pointerEvents: "none" }), A.createElement("path", { d: l, fill: o, stroke: o, strokeWidth: a, pointerEvents: "none" })) })); function TA({ size: e }) { let t = xA(e).join(); return A.createElement("polygon", { className: "tl-binding-indicator", points: t, strokeWidth: 32 }) } var RA = AE("div", { width: "100%", height: "100%" }), BA = Qh("div", { pointerEvents: "all", position: "relative", fontFamily: "sans-serif", fontSize: "2em", height: "100%", width: "100%", borderRadius: "3px", perspective: "800px", overflow: "hidden", p: { userSelect: "none" }, img: { userSelect: "none" }, variants: { isGhost: { false: { opacity: 1 }, true: { transition: "opacity .2s", opacity: .3 } }, isFilled: { true: {}, false: {} }, isDarkMode: { true: {}, false: {} } }, compoundVariants: [{ isFilled: !0, isDarkMode: !0, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.3), 1px 1px 4px rgba(0,0,0,.3), 1px 1px 2px rgba(0,0,0,.3)" } }, { isFilled: !0, isDarkMode: !1, css: { boxShadow: "2px 3px 12px -2px rgba(0,0,0,.2), 1px 1px 4px rgba(0,0,0,.16),  1px 1px 2px rgba(0,0,0,.16)" } }] }), DA = Qh("video", { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", maxWidth: "100%", minWidth: "100%", pointerEvents: "none", objectFit: "cover", userSelect: "none", borderRadius: 2 }), LA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "rectangle"), kE(this, "canBind", !0), kE(this, "canClone", !0), kE(this, "canEdit", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "rectangle", name: "Rectangle", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: Ax, label: "", labelPoint: [.5, .5] }, e))), kE(this, "Component", Fx.Component((({ shape: e, isEditing: t, isBinding: n, isSelected: r, isGhost: i, meta: o, bounds: a, events: s, onShapeBlur: l, onShapeChange: c }, u) => { let { id: d, size: p, style: h, label: f = "", labelPoint: m = Uk } = e, g = Sx(h), v = xx(h, o.isDarkMode), y = "draw" === h.dash ? fA : uA, b = A.useCallback((e => null == c ? void 0 : c({ id: d, label: e })), [c]); return A.createElement(mA, EE({ ref: u }, s), A.createElement(Mx, { isEditing: t, onChange: b, onBlur: l, font: g, text: f, color: v.stroke, offsetX: (m[0] - .5) * a.width, offsetY: (m[1] - .5) * a.height }), A.createElement(gn, { id: e.id + "_svg", opacity: i ? .3 : 1 }, n && A.createElement(cA, { strokeWidth: v.strokeWidth, size: p }), A.createElement(y, { id: d, style: h, size: p, isSelected: r, isDarkMode: o.isDarkMode }))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { id: t, style: n, size: r } = e, i = xx(n, !1).strokeWidth; return "draw" === n.dash ? A.createElement("path", { d: pA(t, n, r) }) : A.createElement("rect", { x: i, y: i, rx: 1, ry: 1, width: Math.max(1, r[0] - 2 * i), height: Math.max(1, r[1] - 2 * i) }) }))), kE(this, "getBounds", (e => Qk(e, this.boundsCache))), kE(this, "shouldRender", ((e, t) => t.size !== e.size || t.style !== e.style || t.label !== e.label)), kE(this, "transform", Lx), kE(this, "transformSingle", Ox) } }, OA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "triangle"), kE(this, "canBind", !0), kE(this, "canClone", !0), kE(this, "canEdit", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "triangle", name: "Triangle", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: Ax, label: "", labelPoint: [.5, .5] }, e))), kE(this, "Component", Fx.Component((({ shape: e, bounds: t, isBinding: n, isEditing: r, isSelected: i, isGhost: o, meta: a, events: s, onShapeChange: l, onShapeBlur: c }, u) => { let { id: d, label: p = "", size: h, style: f, labelPoint: m = Uk } = e, g = Sx(f), v = xx(f, a.isDarkMode), y = "draw" === f.dash ? MA : PA, b = A.useCallback((e => null == l ? void 0 : l({ id: d, label: e })), [l]), w = A.useMemo((() => { let e = B.div(h, 2); return .72 * (AA(h)[1] - e[1]) }), [h]); return A.createElement(RA, EE({ ref: u }, s), A.createElement(Mx, { font: g, text: p, color: v.stroke, offsetX: (m[0] - .5) * t.width, offsetY: w + (m[1] - .5) * t.height, isEditing: r, onChange: b, onBlur: c }), A.createElement(gn, { id: e.id + "_svg", opacity: o ? .3 : 1 }, n && A.createElement(TA, { size: h }), A.createElement(y, { id: d, style: f, size: h, isSelected: i, isDarkMode: a.isDarkMode }))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { size: t } = e; return A.createElement("polygon", { points: xA(t).join() }) }))), kE(this, "shouldRender", ((e, t) => t.size !== e.size || t.style !== e.style || t.label !== e.label)), kE(this, "getBounds", (e => Qk(e, this.boundsCache))), kE(this, "getExpandedBounds", (e => Zt.getBoundsFromPoints(xA(e.size, this.bindingDistance).map((t => B.add(t, e.point)))))), kE(this, "hitTestLineSegment", ((e, t, n) => Ct(t, n, this.getPoints(e)).didIntersect)), kE(this, "hitTestBounds", ((e, t) => Zt.boundsContained(this.getBounds(e), t) || function (e, t) { return It(t, e) }(t, this.getPoints(e)).length > 0)), kE(this, "getBindingPoint", ((e, t, n, r, i, o) => { let a = this.getExpandedBounds(e); if (!Zt.pointInBounds(n, a)) return; let s = xA(e.size).map((t => B.add(t, e.point))), l = xA(e.size, this.bindingDistance).map((t => B.add(t, e.point))), c = Zt.pointsToLineSegments(s, !0).map((([e, t]) => B.distanceToLineSegment(e, t, n))).sort(((e, t) => e - t))[0]; if (!(Zt.pointInPolygon(n, l) || c < this.bindingDistance)) return; let u = Zt.pointsToLineSegments(l.concat([l[0]])).map((e => mt(r, i, e[0], e[1]))).filter((e => e.didIntersect)).flatMap((e => e.points)); if (!u.length) return; let d, p, h = B.add(AA(e.size), e.point), f = u.sort(((e, t) => B.dist(t, r) - B.dist(e, r)))[0], m = B.med(n, f); o ? (d = B.dist(n, h) < 8 ? h : n, p = 0) : (d = B.distanceToLineSegment(n, m, h) < 8 ? h : m, p = Zt.pointInPolygon(n, s) ? this.bindingDistance : Math.max(this.bindingDistance, c)); let g = B.divV(B.sub(d, [a.minX, a.minY]), [a.width, a.height]); return { point: B.clampV(g, 0, 1), distance: p } })), kE(this, "transform", Lx), kE(this, "transformSingle", Ox) } getPoints(e) { let { rotation: t = 0, point: [n, r], size: [i, o] } = e; return [[n + i / 2, r], [n, r + o], [n + i, r + o]].map((n => B.rotWith(n, this.getCenter(e), t))) } }, FA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "ellipse"), kE(this, "canBind", !0), kE(this, "canClone", !0), kE(this, "canEdit", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "ellipse", name: "Ellipse", parentId: "page", childIndex: 1, point: [0, 0], radius: [1, 1], rotation: 0, style: Ax, label: "", labelPoint: [.5, .5] }, e))), kE(this, "Component", Fx.Component((({ shape: e, isGhost: t, isSelected: n, isBinding: r, isEditing: i, meta: o, bounds: a, events: s, onShapeChange: l, onShapeBlur: c }, u) => { let { id: d, radius: p, style: h, label: f = "", labelPoint: m = Uk } = e, g = Sx(e.style), v = xx(h, o.isDarkMode), y = 1 + 1.618 * v.strokeWidth, b = Math.max(0, p[0] - y / 2), w = Math.max(0, p[1] - y / 2), E = "draw" === h.dash ? iA : tA, C = A.useCallback((e => null == l ? void 0 : l({ id: d, label: e })), [l]); return A.createElement(oA, EE({ ref: u }, s), A.createElement(Mx, { isEditing: i, onChange: C, onBlur: c, font: g, text: f, color: v.stroke, offsetX: (m[0] - .5) * a.width, offsetY: (m[1] - .5) * a.height }), A.createElement(gn, { id: e.id + "_svg", opacity: t ? .3 : 1 }, r && A.createElement("ellipse", { className: "tl-binding-indicator", cx: p[0], cy: p[1], rx: b, ry: w, strokeWidth: this.bindingDistance }), A.createElement(E, { id: d, radius: p, style: h, isSelected: n, isDarkMode: o.isDarkMode }))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { id: t, radius: n, style: r } = e, i = 1 + 1.618 * xx(r).strokeWidth, o = Math.max(0, n[0] - i / 2), a = Math.max(0, n[1] - i / 2); return "draw" === r.dash ? A.createElement("path", { d: rA(t, n, r) }) : A.createElement("ellipse", { cx: n[0], cy: n[1], rx: o, ry: a }) }))), kE(this, "hitTestPoint", ((e, t) => Zt.pointInBounds(t, this.getRotatedBounds(e)) && Zt.pointInEllipse(t, this.getCenter(e), e.radius[0], e.radius[1], e.rotation || 0))), kE(this, "hitTestLineSegment", ((e, t, n) => wt(t, n, this.getCenter(e), e.radius[0], e.radius[1], e.rotation || 0).didIntersect)), kE(this, "getBounds", (e => Zt.getFromCache(this.boundsCache, e, (() => Zt.getRotatedEllipseBounds(e.point[0], e.point[1], e.radius[0], e.radius[1], 0))))), kE(this, "getRotatedBounds", (e => Zt.getRotatedEllipseBounds(e.point[0], e.point[1], e.radius[0], e.radius[1], e.rotation))), kE(this, "hitTestBounds", ((e, t) => { let n = this.getBounds(e); return Zt.boundsContained(n, t) || function (e, t, n, r, i) { let { minX: o, minY: a, width: s, height: l } = i; return xt(e, t, n, r, [o, a], [s, l]) }(this.getCenter(e), e.radius[0], e.radius[1], e.rotation || 0, t).length > 0 })), kE(this, "shouldRender", ((e, t) => t.radius !== e.radius || t.style !== e.style || t.label !== e.label)), kE(this, "getCenter", (e => R.add(e.point, e.radius))), kE(this, "getBindingPoint", ((e, t, n, r, i, o) => { { let t, a, s = this.getExpandedBounds(e), l = this.getCenter(e); if (!Zt.pointInEllipse(n, l, e.radius[0] + this.bindingDistance, e.radius[1] + this.bindingDistance)) return; if (o) t = R.dist(n, this.getCenter(e)) < 12 ? [.5, .5] : R.divV(R.sub(n, [s.minX, s.minY]), [s.width, s.height]), a = 0; else { let o = gt(r, i, l, e.radius[0], e.radius[1], e.rotation || 0).points.sort(((e, t) => R.dist(e, r) - R.dist(t, r)))[0]; if (o || (o = wt(n, l, l, e.radius[0], e.radius[1], e.rotation || 0).points.sort(((e, t) => R.dist(e, n) - R.dist(t, n)))[0]), !o) return; let c = R.med(n, o); if (t = R.distanceToLineSegment(n, c, this.getCenter(e)) < 12 ? [.5, .5] : R.divV(R.sub(c, [s.minX, s.minY]), [s.width, s.height]), Zt.pointInEllipse(n, l, e.radius[0], e.radius[1], e.rotation || 0)) a = this.bindingDistance / 2; else { let t = wt(n, l, l, e.radius[0], e.radius[1], e.rotation || 0).points[0]; if (!t) return; a = Math.max(this.bindingDistance / 2, R.dist(n, t)) } } return { point: t, distance: a } } })), kE(this, "transform", ((e, t, { scaleX: n, scaleY: r, initialShape: i }) => { let { rotation: o = 0 } = i; return { point: [t.minX, t.minY], radius: [t.width / 2, t.height / 2], rotation: n < 0 && r >= 0 || r < 0 && n >= 0 ? -(o || 0) : o || 0 } })), kE(this, "transformSingle", ((e, t) => ({ point: R.toFixed([t.minX, t.minY]), radius: R.div([t.width, t.height], 2) }))) } }, zA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "draw"), kE(this, "pointsBoundsCache", new WeakMap([])), kE(this, "shapeBoundsCache", new Map), kE(this, "rotatedCache", new WeakMap([])), kE(this, "pointCache", {}), kE(this, "canClone", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "draw", name: "Draw", parentId: "page", childIndex: 1, point: [0, 0], rotation: 0, style: Ax, points: [], isComplete: !1 }, e))), kE(this, "Component", Fx.Component((({ shape: e, meta: t, isSelected: n, isGhost: r, events: i }, o) => { let { points: a, style: s, isComplete: l } = e, c = A.useMemo((() => function (e) { return e.points.length < 2 ? "" : Zt.getSvgPathFromStroke(nt(e.points, Jx(e)).map((e => e.point))) }(e)), [a, s.size]), u = A.useMemo((() => "draw" === s.dash ? function (e) { if (e.points.length < 2) return ""; let t = Jx(e), n = $x(e, t); return Zt.getSvgPathFromStroke(tt(n, t)) }(e) : eA(e)), [a, s.size, s.dash, l]), d = xx(s, t.isDarkMode), { stroke: p, fill: h, strokeWidth: f } = d, m = this.getBounds(e); if (m.width <= f / 2 && m.height <= f / 2) { let t = 1 + f; return A.createElement(gn, EE({ ref: o, id: e.id + "_svg" }, i), A.createElement("circle", { r: t, fill: p, stroke: p, pointerEvents: "all", opacity: r ? .3 : 1 })) } let g = s.isFilled && a.length > 3 && R.dist(a[0], a[a.length - 1]) < 2 * f; if ("draw" === e.style.dash) return A.createElement(gn, EE({ ref: o, id: e.id + "_svg" }, i), A.createElement("g", { opacity: r ? .3 : 1 }, A.createElement("path", { className: g || n ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: u }), g && A.createElement("path", { d: c, stroke: "none", fill: h, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }), A.createElement("path", { d: u, fill: p, stroke: p, strokeWidth: f / 2, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }))); let v = { draw: "none", solid: "none", dotted: "0.1 " + 4 * f, dashed: `${4 * f} ${4 * f}` }[s.dash], y = { draw: "none", solid: "none", dotted: "0", dashed: "0" }[s.dash], b = 1 + 1.5 * f; return A.createElement(gn, EE({ ref: o, id: e.id + "_svg" }, i), A.createElement("g", { opacity: r ? .3 : 1 }, A.createElement("path", { className: g && n ? "tl-fill-hitarea" : "tl-stroke-hitarea", d: u }), A.createElement("path", { d: u, fill: g ? h : "none", stroke: "none", strokeWidth: Math.min(4, 2 * f), strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }), A.createElement("path", { d: u, fill: "none", stroke: p, strokeWidth: b, strokeDasharray: v, strokeDashoffset: y, strokeLinejoin: "round", strokeLinecap: "round", pointerEvents: "none" }))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { points: t } = e, n = A.useMemo((() => eA(e)), [t]), r = this.getBounds(e); return r.width < 4 && r.height < 4 ? A.createElement("circle", { x: r.width / 2, y: r.height / 2, r: 1 }) : A.createElement("path", { d: n }) }))), kE(this, "transform", ((e, t, { initialShape: n, scaleX: r, scaleY: i }) => { let o = Zt.getFromCache(this.boundsCache, n, (() => Zt.getBoundsFromPoints(n.points))), a = n.points.map((([e, n, a]) => [t.width * (r < 0 ? 1 - e / o.width : e / o.width), t.height * (i < 0 ? 1 - n / o.height : n / o.height), a])), s = Zt.getBoundsFromPoints(e.points); return { points: a, point: R.sub([t.minX, t.minY], [s.minX, s.minY]) } })), kE(this, "getBounds", (e => { let t = !this.pointsBoundsCache.has(e.points), n = this.pointCache[e.id] !== e.point; if (t) { let t = Zt.getBoundsFromPoints(e.points); this.pointsBoundsCache.set(e.points, t), this.shapeBoundsCache.set(e.id, Zt.translateBounds(t, e.point)), this.pointCache[e.id] = e.point } else n && !t && (this.pointCache[e.id] = e.point, this.shapeBoundsCache.set(e.id, Zt.translateBounds(this.pointsBoundsCache.get(e.points), e.point))); return this.shapeBoundsCache.get(e.id) })), kE(this, "shouldRender", ((e, t) => t.points !== e.points || t.style !== e.style || t.isComplete !== e.isComplete)), kE(this, "hitTestPoint", ((e, t) => { let n = R.sub(t, e.point); return Zt.pointInPolyline(n, e.points) })), kE(this, "hitTestLineSegment", ((e, t, n) => { let { points: r, point: i } = e, o = R.sub(t, i), a = R.sub(n, i), s = this.getBounds(e); if (s.width < 8 && s.height < 8) return R.distanceToLineSegment(t, n, Zt.getBoundsCenter(s)) < 5; if (Et(o, a, s)) for (let e = 1; e < r.length; e++)if (yt(r[e - 1], r[e], o, a).didIntersect) return !0; return !1 })), kE(this, "hitTestBounds", ((e, t) => { if (!e.rotation) { let n = this.getBounds(e); return Zt.boundsContain(t, n) || (Zt.boundsContain(n, t) || function (e, t) { return function (e, t, n, r) { return ft(e, t).reduce(((e, [t, [i, o]]) => { let a = St(n, r, i, o); return e.push(...a.map((e => ht(`${t} ${e.message}`, ...e.points)))), e }), []).filter((e => e.didIntersect)) }([e.minX, e.minY], [e.width, e.height], [t.minX, t.minY], [t.width, t.height]) }(n, t).length > 0) && At(Zt.translateBounds(t, R.neg(e.point)), e.points).length > 0 } let n = this.getRotatedBounds(e), r = Zt.getFromCache(this.rotatedCache, e, (() => { let t = Zt.getBoundsCenter(Zt.getBoundsFromPoints(e.points)); return e.points.map((n => R.rotWith(n, t, e.rotation || 0))) })); return Zt.boundsContain(t, n) || At(Zt.translateBounds(t, R.neg(e.point)), r).length > 0 })) } }, HA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "arrow"), kE(this, "hideBounds", !0), kE(this, "canEdit", !0), kE(this, "pathCache", new WeakMap), kE(this, "getShape", (e => { var t, n, r, i; return EE({ id: "id", type: "arrow", name: "Arrow", parentId: "page", childIndex: 1, point: [0, 0], rotation: 0, bend: 0, handles: { start: EE({ id: "start", index: 0, point: [0, 0], canBind: !0 }, null == (t = e.handles) ? void 0 : t.start), end: EE({ id: "end", index: 1, point: [1, 1], canBind: !0 }, null == (n = e.handles) ? void 0 : n.end), bend: EE({ id: "bend", index: 2, point: [.5, .5] }, null == (r = e.handles) ? void 0 : r.bend) }, decorations: null != (i = e.decorations) ? i : { end: "arrow" }, style: EE(CE(EE({}, Ax), { isFilled: !1 }), e.style), label: "", labelPoint: [.5, .5] }, e) })), kE(this, "Component", Fx.Component((({ shape: e, isEditing: t, isGhost: n, meta: r, events: i, onShapeChange: o, onShapeBlur: a }, s) => { var l, c; let { id: u, label: d = "", handles: { start: p, bend: h, end: f }, decorations: m = {}, style: g } = e, v = null != (c = null == (l = null == d ? void 0 : d.trim()) ? void 0 : l.length) && c, y = R.dist(h.point, R.toFixed(R.med(p.point, f.point))) < 1, b = Sx(g), w = xx(g, r.isDarkMode), E = v || t ? rx(d, b) : [0, 0], C = this.getBounds(e), S = A.useMemo((() => { let { start: t, bend: n, end: r } = e.handles; if (y) return R.dist(t.point, r.point); let i = Hx(t.point, n.point, r.point), o = Yx(i.slice(0, 2), i[2], t.point, r.point); return Math.abs(o) }), [e.handles]), k = Math.max(.5, Math.min(1, Math.max(S / (E[1] + 128), S / (E[0] + 128)))), x = A.useMemo((() => { let t = this.getBounds(e); return R.sub(e.handles.bend.point, R.toFixed([t.width / 2, t.height / 2])) }), [e, k]), I = A.useCallback((e => { null == o || o({ id: u, label: e }) }), [o]), P = y ? Xx : Zx; return A.createElement(_x, EE({ ref: s }, i), A.createElement(Mx, { font: b, text: d, color: w.stroke, offsetX: x[0], offsetY: x[1], scale: k, isEditing: t, onChange: I, onBlur: a }), A.createElement(gn, { id: e.id + "_svg" }, A.createElement("defs", null, A.createElement("mask", { id: e.id + "_clip" }, A.createElement("rect", { x: -100, y: -100, width: C.width + 200, height: C.height + 200, fill: "white" }), A.createElement("rect", { x: C.width / 2 - E[0] / 2 * k + x[0], y: C.height / 2 - E[1] / 2 * k + x[1], width: E[0] * k, height: E[1] * k, rx: 4 * k, ry: 4 * k, fill: "black", opacity: 1 }))), A.createElement("g", { pointerEvents: "none", opacity: n ? .3 : 1, mask: v || t ? `url(#${e.id}_clip)` : "" }, A.createElement(P, { id: u, style: g, start: p.point, end: f.point, bend: h.point, arrowBend: e.bend, decorationStart: null == m ? void 0 : m.start, decorationEnd: null == m ? void 0 : m.end, isDraw: "draw" === g.dash, isDarkMode: r.isDarkMode })))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e, bounds: t }) => { var n, r; let { style: i, decorations: o, label: a, handles: { start: s, bend: l, end: c } } = e, u = null != (r = null == (n = null == a ? void 0 : a.trim()) ? void 0 : n.length) && r, d = Sx(i), p = u ? rx(a, d) : [0, 0], h = R.dist(l.point, R.toFixed(R.med(s.point, c.point))) < 1, f = A.useMemo((() => { let { start: t, bend: n, end: r } = e.handles; if (h) return R.dist(t.point, r.point); let i = Hx(t.point, n.point, r.point), o = Yx(i.slice(0, 2), i[2], t.point, r.point); return Math.abs(o) }), [e.handles]), m = Math.max(.5, Math.min(1, Math.max(f / (p[1] + 128), f / (p[0] + 128)))), g = A.useMemo((() => { let t = this.getBounds(e); return R.sub(e.handles.bend.point, [t.width / 2, t.height / 2]) }), [e, m]); return A.createElement(A.Fragment, null, u && A.createElement(ax, { id: e.id, scale: m, offset: g, bounds: t, labelSize: p }), A.createElement("path", { d: Kx(i, s.point, l.point, c.point, null == o ? void 0 : o.start, null == o ? void 0 : o.end), mask: u ? `url(#${e.id}_clip)` : "" }), u && A.createElement("rect", { x: t.width / 2 - p[0] / 2 * m + g[0], y: t.height / 2 - p[1] / 2 * m + g[1], width: p[0] * m, height: p[1] * m, rx: 4 * m, ry: 4 * m, fill: "transparent" })) }))), kE(this, "getBounds", (e => { let t = Zt.getFromCache(this.boundsCache, e, (() => { let { handles: { start: t, bend: n, end: r } } = e; return Zt.getBoundsFromPoints(Wx(t.point, n.point, r.point)) })); return Zt.translateBounds(t, e.point) })), kE(this, "getRotatedBounds", (e => { let { handles: { start: t, bend: n, end: r } } = e, i = Wx(t.point, n.point, r.point), { minX: o, minY: a, maxX: s, maxY: l } = Zt.getBoundsFromPoints(i); return 0 !== e.rotation && (i = i.map((t => R.rotWith(t, [(o + s) / 2, (a + l) / 2], e.rotation || 0)))), Zt.translateBounds(Zt.getBoundsFromPoints(i), e.point) })), kE(this, "getCenter", (e => { let { start: t, end: n } = e.handles; return R.add(e.point, R.med(t.point, n.point)) })), kE(this, "shouldRender", ((e, t) => t.decorations !== e.decorations || t.handles !== e.handles || t.style !== e.style || t.label !== e.label)), kE(this, "hitTestPoint", ((e, t) => { let { handles: { start: n, bend: r, end: i } } = e, o = R.sub(t, e.point), a = Wx(n.point, r.point, i.point); for (let e = 1; e < a.length; e++)if (R.distanceToLineSegment(a[e - 1], a[e], o) < 1) return !0; return !1 })), kE(this, "hitTestLineSegment", ((e, t, n) => { let { handles: { start: r, bend: i, end: o } } = e, a = R.sub(t, e.point), s = R.sub(n, e.point), l = Wx(r.point, i.point, o.point); for (let e = 1; e < l.length; e++)if (yt(l[e - 1], l[e], a, s).didIntersect) return !0; return !1 })), kE(this, "hitTestBounds", ((e, t) => { let { start: n, end: r, bend: i } = e.handles, o = R.add(e.point, n.point), a = R.add(e.point, r.point); if (Zt.pointInBounds(o, t) || Zt.pointInBounds(a, t)) return !0; if (R.isEqual(R.med(n.point, r.point), i.point)) return Et(o, a, t).length > 0; { let [s, l, c] = Hx(n.point, i.point, r.point); return function (e, t, n, r, i) { let { minX: o, minY: a, width: s, height: l } = i; return function (e, t, n, r, i, o) { return kt(i, o, e, t, n, r) }(e, t, n, r, [o, a], [s, l]) }(R.add(e.point, [s, l]), c, o, a, t).length > 0 } })), kE(this, "transform", ((e, t, { initialShape: n, scaleX: r, scaleY: i }) => { let o = this.getBounds(n), a = EE({}, n.handles);["start", "end"].forEach((e => { if ("bend" === e) return; let [n, s] = a[e].point, l = n / o.width, c = s / o.height; a[e] = CE(EE({}, a[e]), { point: [t.width * (r < 0 ? 1 - l : l), t.height * (i < 0 ? 1 - c : c)] }) })); let s = r > 0 && i < 0 || r < 0 && i > 0 ? -n.bend : n.bend, l = zx(a, s); return a.bend.point = l, { point: R.toFixed([t.minX, t.minY]), handles: a, bend: s } })), kE(this, "onDoubleClickHandle", ((e, t) => { var n, r; switch (t) { case "bend": return { bend: 0, handles: CE(EE({}, e.handles), { bend: CE(EE({}, e.handles.bend), { point: zx(e.handles, e.bend) }) }) }; case "start": return { decorations: CE(EE({}, e.decorations), { start: (null == (n = e.decorations) ? void 0 : n.start) ? void 0 : "arrow" }) }; case "end": return { decorations: CE(EE({}, e.decorations), { end: (null == (r = e.decorations) ? void 0 : r.end) ? void 0 : "arrow" }) } }return this })), kE(this, "onHandleChange", ((e, t) => { let n = Zt.deepMerge(e.handles, t), r = e.bend; if (n = Zt.deepMerge(n, { start: { point: R.toFixed(n.start.point) }, end: { point: R.toFixed(n.end.point) } }), R.isEqual(n.start.point, n.end.point)) return; if ("bend" in t) { let { start: e, end: t, bend: i } = n, o = R.dist(e.point, t.point), a = R.med(e.point, t.point), s = R.angle(e.point, t.point), l = R.uni(R.vec(e.point, t.point)), c = R.add(a, R.mul(R.per(l), o)), u = R.sub(a, R.mul(R.per(l), o)), d = R.nearestPointOnLineSegment(c, u, i.point, !0), p = R.dist(a, d) / (o / 2); r = Zt.clamp(p, -.99, .99); let h = R.angle(e.point, d); R.isEqual(a, zx(n, r)) ? r = 0 : function (e, t, n) { if (n === e || n === t) return !0; let r = 2 * Math.PI, i = (t - e + r) % r, o = (n - e + r) % r; return i <= Math.PI != o > i }(s, s + Math.PI, h) && (r *= -1) } let i = { point: e.point, bend: r, handles: CE(EE({}, n), { bend: CE(EE({}, n.bend), { point: zx(n, r) }) }) }, o = e.point, a = this.getBounds(EE({}, i)), s = R.sub([a.minX, a.minY], o); return R.isEqual(s, [0, 0]) || (Object.values(i.handles).forEach((e => { e.point = R.toFixed(R.sub(e.point, s)) })), i.point = R.toFixed(R.add(i.point, s))), i })), kE(this, "getSvgElement", ((e, t) => { var n, r, i, o, a; let s = null == (n = document.getElementById(e.id + "_svg")) ? void 0 : n.cloneNode(!0); if (s) { if (null != (o = null == (i = null == (r = e.label) ? void 0 : r.trim()) ? void 0 : i.length) && o) { let n, r = e, i = document.createElementNS("http://www.w3.org/2000/svg", "g"), o = Sx(e.style), l = rx(e.label, o), c = wx(e.style.size, e.style.font) * (null != (a = e.style.scale) ? a : 1), u = Ex(e.style.font).slice(1, -1), d = ox(r.label, c, u, "start", l[0], !1), { start: p, bend: h, end: f } = e.handles; if (R.dist(h.point, R.toFixed(R.med(p.point, f.point))) < 1) n = R.dist(p.point, f.point); else { let e = Hx(p.point, h.point, f.point), t = Yx(e.slice(0, 2), e[2], p.point, f.point); n = Math.abs(t) } let m = Math.max(.5, Math.min(1, Math.max(n / (l[1] + 128), n / (l[0] + 128)))), g = this.getBounds(e), v = R.sub(e.handles.bend.point, [g.width / 2, g.height / 2]), y = g.width / 2 - l[0] / 2 * m + v[0], b = g.height / 2 - l[1] / 2 * m + v[1]; return d.setAttribute("transform", `translate(${y}, ${b})`), d.setAttribute("fill", xx(e.style, t).stroke), d.setAttribute("transform-origin", "center center"), i.setAttribute("text-align", "center"), i.setAttribute("text-anchor", "middle"), i.appendChild(s), i.appendChild(d), i } return s } })) } }, NA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "text"), kE(this, "isAspectRatioLocked", !0), kE(this, "canEdit", !0), kE(this, "canBind", !0), kE(this, "canClone", !0), kE(this, "bindingDistance", 8), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "text", name: "Text", parentId: "page", childIndex: 1, point: [0, 0], rotation: 0, text: " ", style: Ix }, e))), kE(this, "texts", new Map), kE(this, "Component", Fx.Component((({ shape: e, isBinding: t, isGhost: n, isEditing: r, onShapeBlur: i, onShapeChange: o, meta: a, events: s }, l) => { let { text: c, style: u } = e, d = xx(u, a.isDarkMode), p = Sx(e.style), h = A.useRef(null), f = A.useRef(!1), m = A.useRef(c); A.useLayoutEffect((() => { if (c !== m.current) { let t = [0, 0]; this.texts.set(e.id, c); let n = this.getBounds(e), r = this.getBounds(e); switch (e.style.textAlign) { case "start": break; case "middle": t = R.div([r.width - n.width, 0], 2); break; case "end": t = [r.width - n.width, 0] }m.current = c, null == o || o(CE(EE({}, e), { id: e.id, point: R.sub(e.point, t), text: c })) } }), [c]); let g = A.useCallback((t => { let n = [0, 0], r = ZA.normalizeText(t.currentTarget.value), i = this.getBounds(e); this.texts.set(e.id, r); let a = this.getBounds(CE(EE({}, e), { text: r })); switch (e.style.textAlign) { case "start": break; case "middle": n = R.div([a.width - i.width, 0], 2); break; case "end": n = [a.width - i.width, 0] }m.current = r, null == o || o(CE(EE({}, e), { id: e.id, point: R.sub(e.point, n), text: r })) }), [e.id, e.point]), v = A.useCallback((t => { if ("Escape" === t.key) return t.preventDefault(), t.stopPropagation(), void (null == i || i()); if ("Tab" !== t.key || 0 !== e.text.length) { if ("Enter" === t.key && (t.metaKey || t.ctrlKey)) return t.preventDefault(), t.stopPropagation(), void h.current.blur(); if ("Meta" === t.key || t.metaKey) { if ("z" === t.key && t.metaKey) return t.shiftKey ? document.execCommand("redo", !1) : document.execCommand("undo", !1), t.stopPropagation(), void t.preventDefault() } else t.stopPropagation(); (t.metaKey || t.ctrlKey) && "=" === t.key && t.preventDefault(), "Tab" === t.key && (t.preventDefault(), t.shiftKey ? Px.unindent(t.currentTarget) : Px.indent(t.currentTarget), null == o || o(CE(EE({}, e), { text: ZA.normalizeText(t.currentTarget.value) }))) } else t.preventDefault() }), [e, o]), y = A.useCallback((e => { e.currentTarget.setSelectionRange(0, 0), null == i || i() }), []), b = A.useCallback((e => { !r || !f.current || document.activeElement === e.currentTarget && e.currentTarget.select() }), [r]), w = A.useCallback((e => { r && e.stopPropagation() }), [r]), E = A.useRef(r); return A.useEffect((() => { r ? (E.current = !0, this.texts.set(e.id, c), requestAnimationFrame((() => { f.current = !0; let e = h.current; e && (e.focus(), e.select()) }))) : E.current && (E.current = !1, null == i || i()) }), [r]), A.createElement(Yn, EE({ ref: l }, s), A.createElement(EA, { isGhost: n, isEditing: r, onPointerDown: w }, A.createElement(SA, { style: { font: p, color: d.stroke, textAlign: $k(u.textAlign) } }, t && A.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: -this.bindingDistance, left: -this.bindingDistance, width: `calc(100% + ${2 * this.bindingDistance}px)`, height: `calc(100% + ${2 * this.bindingDistance}px)`, backgroundColor: "var(--tl-selectFill)" } }), r ? A.createElement(kA, { ref: h, style: { font: p, color: d.stroke }, name: "text", tabIndex: -1, autoComplete: "false", autoCapitalize: "false", autoCorrect: "false", autoSave: "false", autoFocus: !0, placeholder: "", spellCheck: "true", wrap: "off", dir: "auto", datatype: "wysiwyg", defaultValue: c, color: d.stroke, onFocus: b, onChange: g, onKeyDown: v, onBlur: y, onPointerDown: w, onContextMenu: yS, onCopy: yS, onPaste: yS, onCut: yS }) : c, ""))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { width: t, height: n } = this.getBounds(e); return A.createElement("rect", { x: 0, y: 0, width: t, height: n }) }))), kE(this, "getBounds", (e => { let t = Zt.getFromCache(this.boundsCache, e, (() => { var t; if (!hA) return { minX: 0, minY: 0, maxX: 10, maxY: 10, width: 10, height: 10 }; hA.parentNode || document.body.appendChild(hA), hA.style.font = Sx(e.style), hA.textContent = null != (t = this.texts.get(e.id)) ? t : e.text; let n = hA.offsetWidth || 1, r = hA.offsetHeight || 1; return { minX: 0, maxX: n, minY: 0, maxY: r, width: n, height: r } })); return Zt.translateBounds(t, e.point) })), kE(this, "shouldRender", ((e, t) => t.text !== e.text || t.style.scale !== e.style.scale || t.style !== e.style)), kE(this, "transform", ((e, t, { initialShape: n, scaleX: r, scaleY: i }) => { let { rotation: o = 0, style: { scale: a = 1 } } = n, s = a * Math.abs(Math.min(r, i)); return { point: [t.minX, t.minY], rotation: r < 0 && i >= 0 || i < 0 && r >= 0 ? -(o || 0) : o, style: CE(EE({}, n.style), { scale: s }) } })), kE(this, "transformSingle", ((e, t, { initialShape: n, scaleX: r, scaleY: i }) => { let { style: { scale: o = 1 } } = n; return { point: R.toFixed([t.minX, t.minY]), style: CE(EE({}, n.style), { scale: o * Math.max(Math.abs(i), Math.abs(r)) }) } })), kE(this, "onDoubleClickBoundsHandle", (e => { let t = this.getCenter(e), n = this.getCenter(CE(EE({}, e), { style: CE(EE({}, e.style), { scale: 1 }) })); return { style: CE(EE({}, e.style), { scale: 1 }), point: R.toFixed(R.add(e.point, R.sub(t, n))) } })), kE(this, "getSvgElement", ((e, t) => { var n, r; let i = this.getBounds(e), o = xx(e.style, t), a = wx(e.style.size, e.style.font) * (null != (n = e.style.scale) ? n : 1), s = Ex(e.style.font).slice(1, -1), l = null != (r = e.style.textAlign) ? r : "middle", c = ox(e.text, a, s, l, i.width, !1); return c.setAttribute("fill", o.stroke), c })) } }, jA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "group"), kE(this, "canBind", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "group", name: "Group", parentId: "page", childIndex: 1, point: [0, 0], size: [100, 100], rotation: 0, children: [], style: Ax }, e))), kE(this, "Component", Fx.Component((({ shape: e, isBinding: t, isGhost: n, isHovered: r, isSelected: i, events: o }, a) => { let { id: s, size: l } = e, c = Math.max(0, l[0] - 1), u = Math.max(0, l[1] - 1), d = [[[1, 1], [c, 1], c - 1], [[c, 1], [c, u], u - 1], [[c, u], [1, u], c - 1], [[1, u], [1, 1], u - 1]].map((([e, t], n) => A.createElement("line", { key: s + "_" + n, x1: e[0], y1: e[1], x2: t[0], y2: t[1] }))); return A.createElement(gn, EE({ ref: a }, o), t && A.createElement("rect", { className: "tl-binding-indicator", strokeWidth: this.bindingDistance }), A.createElement("g", { opacity: n ? .3 : 1 }, A.createElement("rect", { x: 0, y: 0, width: l[0], height: l[1], fill: "transparent", pointerEvents: "all" }), A.createElement(aA, { stroke: "black", opacity: r || i ? 1 : 0, strokeLinecap: "round", pointerEvents: "stroke" }, d))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { id: t, size: n } = e, r = Math.max(0, n[0] - 1), i = Math.max(0, n[1] - 1), o = [[[1, 1], [r, 1], r - 1], [[r, 1], [r, i], i - 1], [[r, i], [1, i], r - 1], [[1, i], [1, 1], i - 1]].map((([e, n], r) => A.createElement("line", { key: t + "_" + r, x1: e[0], y1: e[1], x2: n[0], y2: n[1] }))); return A.createElement(aA, { strokeLinecap: "round", pointerEvents: "stroke" }, o) }))), kE(this, "getBounds", (e => Qk(e, this.boundsCache))), kE(this, "shouldRender", ((e, t) => t.size !== e.size || t.style !== e.style)) } }, UA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "sticky"), kE(this, "canBind", !0), kE(this, "canEdit", !0), kE(this, "canClone", !0), kE(this, "hideResizeHandles", !0), kE(this, "showCloneHandles", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "id", type: "sticky", name: "Sticky", parentId: "page", childIndex: 1, point: [0, 0], size: [200, 200], text: "", rotation: 0, style: Ix }, e))), kE(this, "Component", Fx.Component((({ shape: e, meta: t, events: n, isGhost: r, isBinding: i, isEditing: o, onShapeBlur: a, onShapeChange: s }, l) => { let c = function (e) { let t = Cx(e.size), n = Ex(e.font), { scale: r = 1 } = e; return `${t * r}px/1 ${n}` }(e.style), { color: u, fill: d } = kx(e.style, t.isDarkMode), p = A.useRef(null), h = A.useRef(null), f = A.useRef(null), m = A.useRef(!1), g = A.useCallback((e => { e.stopPropagation() }), []), v = A.useCallback((t => { null == s || s({ id: e.id, type: e.type, text: ZA.normalizeText(t) }) }), [e.id]), y = A.useCallback((e => { v(e.currentTarget.value) }), [s, v]), b = A.useCallback((t => { if ("Escape" === t.key) return t.preventDefault(), t.stopPropagation(), void (null == a || a()); if ("Tab" !== t.key || 0 !== e.text.length) { if ("Meta" === t.key || t.metaKey) { if ("z" === t.key && t.metaKey) return t.shiftKey ? document.execCommand("redo", !1) : document.execCommand("undo", !1), t.stopPropagation(), void t.preventDefault() } else t.stopPropagation(); (t.metaKey || t.ctrlKey) && "=" === t.key && t.preventDefault(), "Tab" === t.key && (t.preventDefault(), t.shiftKey ? Px.unindent(t.currentTarget) : Px.indent(t.currentTarget), null == s || s(CE(EE({}, e), { text: ZA.normalizeText(t.currentTarget.value) }))) } else t.preventDefault() }), [e, s]), w = A.useCallback((e => { e.currentTarget.setSelectionRange(0, 0), null == a || a() }), []), E = A.useCallback((e => { !o || !m.current || e.currentTarget.select() }), [o]); A.useEffect((() => { if (o) { m.current = !0; let e = h.current; e.focus(), e.select() } }), [o]), A.useEffect((() => { let t = f.current, { size: n } = e, { offsetHeight: r } = t; if (r === n[1] - 32) return; if (r > 168) return void (null == s || s({ id: e.id, size: [n[0], r + 32] })); if (r < 168 && n[1] > 200) return void (null == s || s({ id: e.id, size: [n[0], 200] })); let i = h.current; null == i || i.focus() }), [e.text, e.size[1], e.style]); let C = { font: c, color: u, textShadow: t.isDarkMode ? "0.5px 0.5px 2px rgba(255, 255, 255,.25)" : "0.5px 0.5px 2px rgba(255, 255, 255,.5)" }; return A.createElement(Yn, EE({ ref: l }, n), A.createElement(vA, { ref: p, isDarkMode: t.isDarkMode, isGhost: r, style: EE({ backgroundColor: d }, C) }, i && A.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: -this.bindingDistance, left: -this.bindingDistance, width: `calc(100% + ${2 * this.bindingDistance}px)`, height: `calc(100% + ${2 * this.bindingDistance}px)`, backgroundColor: "var(--tl-selectFill)" } }), A.createElement(bA, { ref: f, isEditing: o, alignment: e.style.textAlign }, e.text, ""), o && A.createElement(wA, { ref: h, onPointerDown: g, value: e.text, onChange: y, onKeyDown: b, onFocus: E, onBlur: w, tabIndex: -1, autoComplete: "false", autoCapitalize: "false", autoCorrect: "false", autoSave: "false", autoFocus: !0, spellCheck: !0, alignment: e.style.textAlign, onContextMenu: yS, onCopy: yS, onPaste: yS, onCut: yS }))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { size: [t, n] } = e; return A.createElement("rect", { x: 0, y: 0, rx: 3, ry: 3, width: Math.max(1, t), height: Math.max(1, n) }) }))), kE(this, "getBounds", (e => Qk(e, this.boundsCache))), kE(this, "shouldRender", ((e, t) => t.size !== e.size || t.style !== e.style || t.text !== e.text)), kE(this, "transform", ((e, t, { scaleX: n, scaleY: r, transformOrigin: i }) => ({ point: R.toFixed([t.minX + (t.width - e.size[0]) * (n < 0 ? 1 - i[0] : i[0]), t.minY + (t.height - e.size[1]) * (r < 0 ? 1 - i[1] : i[1])]) }))), kE(this, "transformSingle", (e => e)), kE(this, "getSvgElement", ((e, t) => { var n, r; let i = this.getBounds(e), o = kx(e.style, t), a = Cx(e.style.size) * (null != (n = e.style.scale) ? n : 1), s = Ex(e.style.font).slice(1, -1), l = null != (r = e.style.textAlign) ? r : "start", c = ox(e.text, a, s, l, i.width - 32, !0); c.setAttribute("fill", o.color), c.setAttribute("transform", "translate(16, 16)"); let u = document.createElementNS("http://www.w3.org/2000/svg", "g"), d = document.createElementNS("http://www.w3.org/2000/svg", "rect"); return d.setAttribute("width", i.width + ""), d.setAttribute("height", i.height + ""), d.setAttribute("fill", o.fill), d.setAttribute("rx", "3"), d.setAttribute("ry", "3"), u.appendChild(d), u.appendChild(c), u })) } }, VA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "image"), kE(this, "canBind", !0), kE(this, "canClone", !0), kE(this, "isAspectRatioLocked", !0), kE(this, "showCloneHandles", !1), kE(this, "getShape", (e => Zt.deepMerge({ id: "image", type: "image", name: "Image", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: CE(EE({}, Ax), { isFilled: !0 }), assetId: "assetId" }, e))), kE(this, "Component", Fx.Component((({ shape: e, asset: t = { src: "" }, isBinding: n, isGhost: r, meta: i, events: o, onShapeChange: a }, s) => { let { size: l, style: c } = e, { bindingDistance: u } = this, d = A.useRef(null), p = A.useRef(null); return A.useLayoutEffect((() => { let e = p.current; if (!e) return; let [t, n] = l; e.style.width = `${t}px`, e.style.height = `${n}px` }), [l]), A.createElement(Yn, EE({ ref: s }, o), n && A.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: `calc(${-u}px * var(--tl-zoom))`, left: `calc(${-u}px * var(--tl-zoom))`, width: `calc(100% + ${2 * u}px * var(--tl-zoom))`, height: `calc(100% + ${2 * u}px * var(--tl-zoom))`, backgroundColor: "var(--tl-selectFill)" } }), A.createElement(sA, { ref: p, isDarkMode: i.isDarkMode, isFilled: c.isFilled, isGhost: r }, A.createElement(lA, { id: e.id + "_image", ref: d, src: t.src, alt: "tl_image_asset", draggable: !1 }))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { size: [t, n] } = e; return A.createElement("rect", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, t), height: Math.max(1, n) }) }))), kE(this, "getBounds", (e => Qk(e, this.boundsCache))), kE(this, "shouldRender", ((e, t) => t.size !== e.size || t.style !== e.style)), kE(this, "transform", Lx), kE(this, "transformSingle", Ox), kE(this, "getSvgElement", (e => { let t = this.getBounds(e), n = document.createElementNS("http://www.w3.org/2000/svg", "image"); return n.setAttribute("width", `${t.width}`), n.setAttribute("height", `${t.height}`), n.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), n })) } }, KA = new class extends Fx { constructor() { super(...arguments), kE(this, "type", "video"), kE(this, "canBind", !0), kE(this, "canEdit", !0), kE(this, "canClone", !0), kE(this, "isAspectRatioLocked", !0), kE(this, "showCloneHandles", !1), kE(this, "isStateful", !0), kE(this, "getShape", (e => Zt.deepMerge({ id: "video", type: "video", name: "Video", parentId: "page", childIndex: 1, point: [0, 0], size: [1, 1], rotation: 0, style: Ax, assetId: "assetId", isPlaying: !0, currentTime: 0 }, e))), kE(this, "Component", Fx.Component((({ shape: e, asset: t = { src: "" }, isBinding: n, isEditing: r, isGhost: i, meta: o, events: a, onShapeChange: s }, l) => { let c = A.useRef(null), u = A.useRef(null), { currentTime: d = 0, size: p, isPlaying: h, style: f } = e; A.useLayoutEffect((() => { let e = u.current; if (!e) return; let [t, n] = p; e.style.width = `${t}px`, e.style.height = `${n}px` }), [p]), A.useLayoutEffect((() => { let e = c.current; !e || (h ? e.play() : e.pause()) }), [h]), A.useLayoutEffect((() => { let e = c.current; !e || d !== e.currentTime && (e.currentTime = d) }), [d]); let m = A.useCallback((() => { null == s || s({ id: e.id, isPlaying: !0 }) }), []), g = A.useCallback((() => { null == s || s({ id: e.id, isPlaying: !1 }) }), []), v = A.useCallback((() => { let t = c.current; !t || !r || null == s || s({ id: e.id, currentTime: t.currentTime }) }), [r]); return A.createElement(Yn, EE({ ref: l }, a), n && A.createElement("div", { className: "tl-binding-indicator", style: { position: "absolute", top: -this.bindingDistance, left: -this.bindingDistance, width: `calc(100% + ${2 * this.bindingDistance}px)`, height: `calc(100% + ${2 * this.bindingDistance}px)`, backgroundColor: "var(--tl-selectFill)" } }), A.createElement(BA, { ref: u, isDarkMode: o.isDarkMode, isGhost: i, isFilled: f.isFilled }, A.createElement(DA, { ref: c, id: e.id + "_video", muted: !0, loop: !0, playsInline: !0, disableRemotePlayback: !0, disablePictureInPicture: !0, controls: r, autoPlay: h, onPlay: m, onPause: g, onTimeUpdate: v }, A.createElement("source", { src: t.src })))) }))), kE(this, "Indicator", Fx.Indicator((({ shape: e }) => { let { size: [t, n] } = e; return A.createElement("rect", { x: 0, y: 0, rx: 2, ry: 2, width: Math.max(1, t), height: Math.max(1, n) }) }))), kE(this, "getBounds", (e => Qk(e, this.boundsCache))), kE(this, "shouldRender", ((e, t) => t.size !== e.size || t.style !== e.style || t.isPlaying !== e.isPlaying)), kE(this, "getSvgElement", (e => { let t = this.getBounds(e), n = document.createElementNS("http://www.w3.org/2000/svg", "image"); return n.setAttribute("width", `${t.width}`), n.setAttribute("height", `${t.height}`), n.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), n })), kE(this, "transform", Lx), kE(this, "transformSingle", Ox) } }, WA = { rectangle: LA, triangle: OA, ellipse: FA, draw: zA, arrow: HA, text: NA, group: jA, sticky: UA, image: VA, video: KA }, YA = e => "string" == typeof e ? WA[e] : WA[e.type], GA = class { static getShapeUtil(e) { return YA(e) } static getSelectedShapes(e, t) { let n = GA.getPage(e, t); return GA.getSelectedIds(e, t).map((e => n.shapes[e])) } static screenToWorld(e, t) { let n = GA.getPageState(e, e.appState.currentPageId).camera; return R.sub(R.div(t, n.zoom), n.point) } static getCameraZoom(e) { return Zt.clamp(e, .1, 5) } static getPage(e, t) { return e.document.pages[t] } static getPageState(e, t) { return e.document.pageStates[t] } static getSelectedIds(e, t) { return GA.getPageState(e, t).selectedIds } static getShapes(e, t) { return Object.values(GA.getPage(e, t).shapes) } static getCamera(e, t) { return GA.getPageState(e, t).camera } static getShape(e, t, n) { return GA.getPage(e, n).shapes[t] } static getCenter(e) { return GA.getShapeUtil(e).getCenter(e) } static getBounds(e) { return GA.getShapeUtil(e).getBounds(e) } static getRotatedBounds(e) { return GA.getShapeUtil(e).getRotatedBounds(e) } static getSelectedBounds(e) { return Zt.getCommonBounds(GA.getSelectedShapes(e, e.appState.currentPageId).map((e => GA.getShapeUtil(e).getBounds(e)))) } static getParentId(e, t, n) { return GA.getShape(e, t, n).parentId } static getDocumentBranch(e, t, n) { let r = GA.getShape(e, t, n); return void 0 === r.children ? [t] : [t, ...r.children.flatMap((t => GA.getDocumentBranch(e, t, n)))] } static getSelectedBranchSnapshot(e, t, n) { let r = GA.getPage(e, t), i = GA.getSelectedIds(e, t).flatMap((n => GA.getDocumentBranch(e, n, t).map((e => r.shapes[e])))).filter((e => !e.isLocked)).map(Zt.deepClone); return void 0 !== n ? i.map((e => EE({ id: e.id }, n(e)))) : i } static getSelectedShapeSnapshot(e, t, n) { let r = GA.getSelectedShapes(e, t).filter((e => !e.isLocked)).map(Zt.deepClone); return void 0 !== n ? r.map((e => EE({ id: e.id }, n(e)))) : r } static getAllEffectedShapeIds(e, t, n) { let r = GA.getPage(e, n), i = new Set(t); return t.forEach((e => { let t = r.shapes[e]; !function e(t) { void 0 !== t.children && t.children.filter((e => !i.has(e))).forEach((t => { i.add(t), e(r.shapes[t]) })) }(t), function e(t) { let n = t.parentId; n !== r.id && (i.has(n) || (i.add(n), e(r.shapes[n]))) }(t), i.forEach((e => { Object.values(r.bindings).filter((t => t.fromId === e || t.toId === e)).forEach((t => i.add(t.fromId === e ? t.toId : t.fromId))) })) })), Array.from(i.values()) } static getLinkedShapeIds(e, t, n, r = !0) { let i = GA.getSelectedIds(e, t), o = GA.getPage(e, t), a = new Set(i), s = new Set, l = [...i], c = new Set(Object.values(o.shapes).filter((e => { var t; return "arrow" === e.type && (e.handles.start.bindingId || (null == (t = e.handles) ? void 0 : t.end.bindingId)) }))); for (; l.length;) { let e = l.pop(); if (!e || !c.size) break; s.has(e) || (s.add(e), c.forEach((t => { var i, s; let { handles: { start: { bindingId: u }, end: { bindingId: d } } } = t, p = u ? o.bindings[u] : null, h = d ? o.bindings[d] : null, f = !1; p && p.toId === e ? (f = "center" === n || ((null == (i = t.decorations) ? void 0 : i.start) && h ? "left" === n : "right" === n), f && (r && a.add(t.id), a.add(e), h && (a.add(h.toId), l.push(h.toId)))) : h && h.toId === e && (f = "center" === n || ((null == (s = t.decorations) ? void 0 : s.end) && p ? "left" === n : "right" === n), f && (r && a.add(t.id), a.add(e), p && (a.add(p.toId), l.push(p.toId)))), (!p || a.has(p.toId)) && (!h || a.has(h.toId)) && c.delete(t) }))) } return Array.from(a.values()) } static getChildIndexAbove(e, t, n) { let r, i = e.document.pages[n], o = i.shapes[t]; if (o.parentId === i.id) r = Object.values(i.shapes).filter((e => e.parentId === i.id)).sort(((e, t) => e.childIndex - t.childIndex)); else { let e = i.shapes[o.parentId]; if (!e.children) throw Error("No children in parent!"); r = e.children.map((e => i.shapes[e])).sort(((e, t) => e.childIndex - t.childIndex)) } let a = r.indexOf(o), s = r[a + 1]; return s ? s.childIndex : o.childIndex + 1 } static getBeforeShape(e, t) { return Object.fromEntries(Object.keys(t).map((t => [t, e[t]]))) } static mutateShapes(e, t, n, r, i = !1) { let o = {}, a = {}; t.forEach(((s, l) => { let c = GA.getShape(e, s, r); if (c.isLocked) return; "group" === (null == c ? void 0 : c.type) && (1 === t.length || i) && c.children.forEach(((t, i) => { let s = GA.getShape(e, t, r); if (s.isLocked) return; let l = n(s, i); l && (o[t] = GA.getBeforeShape(s, l), a[t] = l) })); let u = n(c, l); u && (o[s] = GA.getBeforeShape(c, u), a[s] = u) })); let s = Zt.deepMerge(e, { document: { pages: { [e.appState.currentPageId]: { shapes: a } } } }); return { before: o, after: a, data: s } } static createShapes(e, t, n) { let r = { document: { pages: { [n]: { shapes: EE({}, Object.fromEntries(t.flatMap((t => { let r = [[t.id, void 0]]; if (t.parentId !== n) { let i = GA.getShape(e, t.parentId, n); if (!i.children) throw Error("No children in parent!"); r.push([i.id, { children: i.children }]) } return r })))) } } } }, i = { document: { pages: { [n]: { shapes: { shapes: EE({}, Object.fromEntries(t.flatMap((t => { let r = [[t.id, t]]; if (t.parentId !== n) { let i = GA.getShape(e, t.parentId, n); if (!i.children) throw Error("No children in parent!"); r.push([i.id, { children: [...i.children, t.id] }]) } return r })))) } } } } }; return { before: r, after: i } } static deleteShapes(e, t, n) { n = n || e.appState.currentPageId; let r = GA.getPage(e, n), i = "string" == typeof t[0] ? t : t.map((e => e.id)), o = { document: { pages: { [n]: { shapes: EE({}, Object.fromEntries(i.flatMap((e => { let t = r.shapes[e], i = [[t.id, t]]; if (t.parentId !== n) { let e = r.shapes[t.parentId]; if (!e.children) throw Error("No children in parent!"); i.push([e.id, { children: e.children }]) } return i })))), bindings: EE({}, Object.fromEntries(Object.values(r.bindings).filter((e => i.includes(e.fromId) || i.includes(e.toId))).map((e => [e.id, e])))) } } } }, a = { document: { pages: { [n]: { shapes: EE({}, Object.fromEntries(i.flatMap((e => { let t = r.shapes[e], n = [[t.id, void 0]]; if (t.parentId !== r.id) { let e = r.shapes[t.parentId]; if (!e.children) throw Error("No children in parent!"); n.push([e.id, { children: e.children.filter((e => e !== t.id)) }]) } return n })))) } } } }; return { before: o, after: a } } static onSessionComplete(e) { var t, n; let r = null == (n = (t = GA.getShapeUtil(e)).onSessionComplete) ? void 0 : n.call(t, e); return r ? EE(EE({}, e), r) : e } static onChildrenChange(e, t, n) { var r, i; if (!t.children) return; let o = null == (i = (r = GA.getShapeUtil(t)).onChildrenChange) ? void 0 : i.call(r, t, t.children.map((t => GA.getShape(e, t, n)))); return o ? EE(EE({}, t), o) : t } static updateArrowBindings(e, t) { var n, r, i, o, a, s; let l = { start: _k(t.handles.start), end: _k(t.handles.end) }, c = { isBound: !1, handle: t.handles.start, point: R.add(t.handles.start.point, t.point) }, u = { isBound: !1, handle: t.handles.end, point: R.add(t.handles.end.point, t.point) }; if (t.handles.start.bindingId) { let r = void 0 !== (null == (n = t.decorations) ? void 0 : n.start), i = t.handles.start, o = e.bindings[t.handles.start.bindingId]; if (!o) throw Error("Could not find a binding to match the start handle's bindingId: " + t.handles.start.bindingId); let a = e.shapes[o.toId], s = GA.getShapeUtil(a), l = s.getBounds(a), u = s.getExpandedBounds(a), d = r ? Zt.expandBounds(l, o.distance) : l, { minX: p, minY: h, width: f, height: m } = u; c = { isBound: !0, hasDecoration: r, binding: o, handle: i, point: R.add([p, h], R.mulV([f, m], R.rotWith(o.point, [.5, .5], a.rotation || 0))), util: s, target: a, bounds: l, expandedBounds: u, intersectBounds: d, center: s.getCenter(a) } } if (t.handles.end.bindingId) { let n = void 0 !== (null == (r = t.decorations) ? void 0 : r.end), i = t.handles.end, o = e.bindings[t.handles.end.bindingId]; if (!o) throw Error("Could not find a binding to match the end handle's bindingId"); let a = e.shapes[o.toId], s = GA.getShapeUtil(a), l = s.getBounds(a), c = s.getExpandedBounds(a), d = n ? Zt.expandBounds(l, o.distance) : l, { minX: p, minY: h, width: f, height: m } = c; u = { isBound: !0, hasDecoration: n, binding: o, handle: i, point: R.add([p, h], R.mulV([f, m], R.rotWith(o.point, [.5, .5], a.rotation || 0))), util: s, target: a, bounds: l, expandedBounds: c, intersectBounds: d, center: s.getCenter(a) } } for (let e of ["end", "start"]) { let n = "start" === e ? c : u, r = "start" === e ? u : c; if (n.isBound) if (n.binding.distance) { let a = R.uni(R.sub(n.point, r.point)); switch (n.target.type) { case "ellipse": { let i = gt(r.point, a, n.center, n.target.radius[0] + (n.hasDecoration ? n.binding.distance : 0), n.target.radius[1] + (n.hasDecoration ? n.binding.distance : 0), n.target.rotation || 0).points.sort(((e, t) => R.dist(e, r.point) - R.dist(t, r.point))); void 0 !== i[0] && (l[e].point = R.toFixed(R.sub(i[0], t.point))); break } case "triangle": { let i = n.target.point, o = xA(n.target.size, n.hasDecoration ? 16 : 0, n.target.rotation).map((e => R.add(e, i))), s = Zt.pointsToLineSegments(o, !0).map((([e, t]) => mt(r.point, a, e, t))).filter((e => e.didIntersect)).flatMap((e => e.points)).sort(((e, t) => R.dist(e, r.point) - R.dist(t, r.point))); void 0 !== s[0] && (l[e].point = R.toFixed(R.sub(s[0], t.point))); break } default: { let s, c = vt(r.point, a, n.intersectBounds, n.target.rotation).filter((e => e.didIntersect)).map((e => e.points[0])).sort(((e, t) => R.dist(e, r.point) - R.dist(t, r.point))); if (!c[0]) continue; if (r.isBound && (s = vt(r.point, a, r.intersectBounds, r.target.rotation).filter((e => e.didIntersect)).map((e => e.points[0])).sort(((e, t) => R.dist(e, r.point) - R.dist(t, r.point)))[0]), r.isBound && (c.length < 2 || s && c[0] && Math.ceil(R.dist(c[0], s)) < 40 || Zt.boundsContain(n.expandedBounds, r.expandedBounds) || Zt.boundsCollide(n.expandedBounds, r.expandedBounds))) { let i = R.uni(R.sub(r.point, n.point)), o = vt(n.point, i, n.bounds, n.target.rotation).filter((e => e.didIntersect)).map((e => e.points[0])); if (!o[0]) continue; l[e].point = R.toFixed(R.sub(o[0], t.point)), l["start" === e ? "end" : "start"].point = R.toFixed(R.add(R.sub(o[0], t.point), R.mul(i, Math.min(R.dist(o[0], r.point), 40 * (Zt.boundsContain(r.bounds, n.intersectBounds) ? -1 : 1))))) } else { if (!r.isBound && (c[0] && R.dist(c[0], r.point) < 40 || Zt.pointInBounds(r.point, n.intersectBounds))) { let a = R.uni(R.sub(n.center, r.point)); return null == (o = (i = GA.getShapeUtil(t)).onHandleChange) ? void 0 : o.call(i, t, { [e]: CE(EE({}, t.handles[e]), { point: R.toFixed(R.add(R.sub(r.point, t.point), R.mul(a, 40))) }) }) } c[0] && (l[e].point = R.toFixed(R.sub(c[0], t.point))) } } } } else l[e].point = R.sub(n.point, t.point) } return null == (s = (a = GA.getShapeUtil(t)).onHandleChange) ? void 0 : s.call(a, t, l) } static transform(e, t, n) { let r = GA.getShapeUtil(e).transform(e, t, n); return r ? EE(EE({}, e), r) : e } static transformSingle(e, t, n) { let r = GA.getShapeUtil(e).transformSingle(e, t, n); return r ? EE(EE({}, e), r) : e } static getRotatedShapeMutation(e, t, n, r) { var i, o; let a = R.sub(t, e.point), s = R.rotWith(t, n, r), l = R.toFixed(R.sub(s, a)); return void 0 !== e.handles ? null == (o = (i = this.getShapeUtil(e)).onHandleChange) ? void 0 : o.call(i, CE(EE({}, e), { point: l }), Object.fromEntries(Object.entries(e.handles).map((([e, t]) => { let n = R.toFixed(R.rotWith(t.point, a, r)); return [e, CE(EE({}, t), { point: n })] })))) : { point: l, rotation: Zt.clampRadians((e.rotation || 0) + r) } } static updateParents(e, t, n) { let r = GA.getPage(e, t); if (0 === n.length) return; let { shapes: i } = GA.getPage(e, t), o = Array.from(new Set(n.map((e => i[e].parentId)).values())).filter((e => e !== r.id)); for (let n of o) { let r = i[n]; if (!r.children) throw Error("A shape is parented to a shape without a children array."); GA.onChildrenChange(e, r, t) } GA.updateParents(e, t, o) } static getBinding(e, t, n) { return GA.getPage(e, n).bindings[t] } static getBindings(e, t) { let n = GA.getPage(e, t); return Object.values(n.bindings) } static getBindableShapeIds(e) { return GA.getShapes(e, e.appState.currentPageId).filter((e => GA.getShapeUtil(e).canBind)).sort(((e, t) => t.childIndex - e.childIndex)).map((e => e.id)) } static getBindingsWithShapeIds(e, t, n) { return Array.from(new Set(GA.getBindings(e, n).filter((e => t.includes(e.toId) || t.includes(e.fromId)))).values()) } static getRelatedBindings(e, t, n) { let r = new Set(t), i = GA.getPage(e, n), o = Object.values(i.bindings), a = new Set(o.filter((e => r.has(e.toId) || r.has(e.fromId)))), s = a.size, l = -1; for (; 0 !== l;)a.forEach((e => { let t = e.fromId; for (let e of o) e.fromId === t && a.add(e), e.toId === t && a.add(e) })), l = a.size - s, s = a.size; return Array.from(a.values()) } static normalizeText(e) { return e.replace(GA.fixNewLines, "\n").split("\n").map((e => e || " ")).join("\n") } static assertShapeHasProperty(e, t) { if (void 0 === e[t]) throw new Error } static warn(e) { } static error(e) { } static getSvgString(e, t = 1) { let n = e.cloneNode(!0); return e.setAttribute("width", +e.getAttribute("width") * t + ""), e.setAttribute("height", +e.getAttribute("height") * t + ""), (new XMLSerializer).serializeToString(n).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1") } static getSvgAsDataUrl(e, t = 1) { let n = GA.getSvgString(e, t); return `data:image/svg+xml;base64,${window.btoa(unescape(n))}` } static getImageForSvg(e) { return xE(this, arguments, (function* (e, t = "png", n = {}) { let { scale: r = 2, quality: i = 1 } = n, o = GA.getSvgString(e, r); if (!o) return; let a = yield new Promise((e => { let t = new Image; t.crossOrigin = "anonymous"; let n = `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(o)))}`; t.onload = () => { let r = document.createElement("canvas"), i = r.getContext("2d"), o = t.width, a = t.height; r.width = o, r.height = a, i.drawImage(t, 0, 0, o, a), URL.revokeObjectURL(n), e(r) }, t.onerror = () => { console.warn("Could not convert that SVG to an image.") }, t.src = n })); return yield new Promise((e => a.toBlob((t => e(t)), "image/" + t, i))) })) } }, ZA = GA; kE(ZA, "copyStringToClipboard", (e => { try { navigator.clipboard && navigator.clipboard.write([new ClipboardItem({ "text/plain": new Blob([e], { type: "text/plain" }) })]) } catch (t) { let n = document.createElement("textarea"); n.setAttribute("position", "fixed"), n.setAttribute("top", "0"), n.setAttribute("readonly", "true"), n.setAttribute("contenteditable", "true"), n.style.position = "fixed", n.value = e, document.body.appendChild(n), n.focus(), n.select(); try { let e = document.createRange(); e.selectNodeContents(n); let t = window.getSelection(); t && (t.removeAllRanges(), t.addRange(e), n.setSelectionRange(0, n.value.length)), document.execCommand("copy") } catch (e) { } finally { document.body.removeChild(n) } } })), kE(ZA, "flattenShape", ((e, t) => { var n; return [t, ...(null != (n = t.children) ? n : []).map((t => GA.getShape(e, t, e.appState.currentPageId))).sort(((e, t) => e.childIndex - t.childIndex)).flatMap((t => GA.flattenShape(e, t)))] })), kE(ZA, "flattenPage", ((e, t) => Object.values(e.document.pages[t].shapes).sort(((e, t) => e.childIndex - t.childIndex)).reduce(((t, n) => [...t, ...GA.flattenShape(e, n)]), []))), kE(ZA, "getTopChildIndex", ((e, t) => { let n = GA.getShapes(e, t); return 0 === n.length ? 1 : n.filter((e => e.parentId === t)).sort(((e, t) => t.childIndex - e.childIndex))[0].childIndex + 1 })), kE(ZA, "fixNewLines", /\r?\n|\r/g); var XA = e => e.room, _A = function () { let e = pC(), t = e.useStore(XA), [n, r] = A.useState(!1), i = A.useRef(0), o = A.useCallback((() => { r(!0), ZA.copyStringToClipboard(window.location.href), clearTimeout(i.current), i.current = setTimeout((() => r(!1)), 1200) }), []), a = A.useCallback((() => { r(!0); let e = window.location.href.split("/"); e[e.length - 2] = "v", e[e.length - 1] = Zt.lns(e[e.length - 1]), ZA.copyStringToClipboard(e.join("/")), clearTimeout(i.current), i.current = setTimeout((() => r(!1)), 1200) }), []), s = A.useCallback((() => xE(this, null, (function* () { e.isDirty ? e.fileSystemHandle ? window.confirm("Do you want to save changes to your current project?") && (yield e.saveProject()) : window.confirm("Do you want to save your current project?") && (yield e.saveProject()) : e.fileSystemHandle || window.confirm("Do you want to save your current project?") && (yield e.saveProject()) }))), []), l = A.useCallback((() => xE(this, null, (function* () { var t; let n = Zt.deepClone(e.document); e.setIsLoading(!0); try { if (e.callbacks.onAssetUpload) for (let r in n.assets) { let i = n.assets[r]; if (i.src.includes("base64")) { let n = QA(i.src, (null != (t = i.fileName) ? t : "video" === i.type) ? "image.png" : "image.mp4"), o = yield e.callbacks.onAssetUpload(e, n, r); i.src = o || "" } } let r = yield fetch("/api/create", { method: "POST", mode: "no-cors", headers: { "Access-Control-Allow-Origin": "*", "Content-Type": "application/json" }, body: JSON.stringify({ roomId: Zt.uniqueId(), pageId: e.currentPageId, document: n }) }).then((e => e.json())); (null == r ? void 0 : r.url) ? window.location.href = r.url : ZA.warn(null == r ? void 0 : r.message) } catch (e) { ZA.warn(e.message) } e.setIsLoading(!1) }))), []); return A.createElement(Cf, { dir: "ltr" }, A.createElement(SS, { id: "TD-MultiplayerMenuIcon", isActive: !!t }, A.createElement(Nk, null)), A.createElement(bS, { variant: "menu", id: "TD-MultiplayerMenu", side: "bottom", align: "start", sideOffset: 4 }, A.createElement(mS, { id: "TD-Multiplayer-CopyInviteLink", onClick: o, disabled: !t }, A.createElement($p, { id: "copy.invite.link" }), A.createElement(LE, null, n ? A.createElement(Rd, null) : A.createElement(zd, null))), A.createElement(mS, { id: "TD-Multiplayer-CopyReadOnlyLink", onClick: a, disabled: !t }, A.createElement($p, { id: "copy.readonly.link" }), A.createElement(LE, null, n ? A.createElement(Rd, null) : A.createElement(zd, null))), A.createElement(ME, null), A.createElement(mS, { id: "TD-Multiplayer-CreateMultiplayerProject", onClick: s }, A.createElement("a", { href: `${window.location.origin}/r` }, A.createElement($p, { id: "create.multiplayer.project" }))), A.createElement(mS, { id: "TD-Multiplayer-CopyToMultiplayerProject", onClick: l }, A.createElement($p, { id: "copy.multiplayer.project" })))) }; function QA(e, t) { var n, r; let i = e.split(","), o = null == (r = null == (n = i[0]) ? void 0 : n.match(/:(.*?);/)) ? void 0 : r[1], a = window.atob(i[1]), s = a.length, l = new Uint8Array(s); for (; s--;)l[s] = a.charCodeAt(s); return new File([l], t, { type: o }) } var qA = e => Object.keys(e.document.pages).length > 1; function JA({ page: e, onOpen: t, onClose: n }) { let r = pC(), i = Qp(), [o, a] = A.useState(!1), [s, l] = A.useState(e.name || "Page"), c = r.useStore(qA), u = A.useRef(null), d = A.useCallback((() => { a(!1) }), []), p = A.useCallback((() => { r.duplicatePage(e.id) }), [r]), h = A.useCallback((() => { window.confirm("Are you sure you want to delete this page?") && r.deletePage(e.id) }), [r]), f = A.useCallback((e => { a(e), e && (null == t || t()) }), [r]); function m(e) { e.stopPropagation() } let g = A.useRef(e.name || "Page"), v = A.useRef(g.current), y = A.useCallback((e => { let t = e.target.value.trimStart(); v.current = t, l(t) }), []), b = A.useCallback((t => { switch (t.key) { case "Enter": v.current === g.current || (g.current = v.current, r.renamePage(e.id, v.current.trim())), a(!1); break; case "Escape": if (v.current === g.current) return void a(!1); v.current = g.current, l(g.current), requestAnimationFrame((() => { let e = u.current; e && (e.focus(), e.setSelectionRange(0, e.value.length)) })) } }), []), w = A.useRef(!1); A.useEffect((() => (o ? (w.current = !0, g.current = e.name || "Page", v.current = g.current, requestAnimationFrame((() => { let e = u.current; e && (e.focus(), e.setSelectionRange(0, e.value.length)) }))) : w.current && (null == n || n()), () => { v.current !== g.current && (g.current = v.current, r.renamePage(e.id, v.current)) })), [o]); let E = fC(); return A.createElement(pb, { open: o, onOpenChange: f }, A.createElement(hb, { asChild: !0, "data-shy": "true" }, A.createElement(WC, { bp: OE }, A.createElement(LE, null, A.createElement(dp, null)))), A.createElement(fb, { container: E.current }, A.createElement(eI, { onPointerDown: d }), A.createElement($A, { dir: "ltr", onKeyDown: m, onKeyUp: m }, A.createElement(aS, { ref: u, placeholder: i.formatMessage({ id: "page.name" }), value: s, onChange: y, onKeyDown: b, icon: A.createElement(hp, null) }), A.createElement(ME, null), A.createElement(tI, { onSelect: p }, A.createElement($p, { id: "duplicate" })), A.createElement(tI, { disabled: !c, onSelect: h }, A.createElement($p, { id: "delete" })), A.createElement(ME, null), A.createElement(yb, { asChild: !0 }, A.createElement(FE, null, A.createElement($p, { id: "cancel" })))))) } var $A = AE(gb, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", minWidth: 240, maxWidth: "fit-content", maxHeight: "85vh", marginTop: "-5vh", pointerEvents: "all", backgroundColor: "$panel", padding: "$1", borderRadius: "$2", font: "$ui", zIndex: 999999, "&:focus": { outline: "none" } }), eI = AE(mb, { backgroundColor: "rgba(0, 0, 0, .15)", position: "absolute", pointerEvents: "all", inset: 0, zIndex: 999998 }); function tI(e) { var t = e, { onSelect: n } = t, r = SE(t, ["onSelect"]); return A.createElement(vb, { asChild: !0, onClick: n, onSelect: n }, A.createElement(FE, EE({}, r))) } var nI = e => Object.values(e.document.pages).sort(((e, t) => (e.childIndex || 0) - (t.childIndex || 0))), rI = e => e.document.pages[e.appState.currentPageId].name, iI = e => e.document.pages[e.appState.currentPageId].id; function oI() { let e = pC(), t = Qp(), n = A.useRef(!1), [r, i] = A.useState(!1); A.useEffect((() => { n.current !== r && (n.current = r) }), [r]); let o = A.useCallback((() => { i(!1) }), [i]), a = A.useCallback((e => { n.current !== e && i(e) }), [i]), s = e.useStore(rI); return A.createElement(Cf, { dir: "ltr", open: r, onOpenChange: a }, A.createElement(Sf, { dir: "ltr", asChild: !0, id: "TD-Page" }, A.createElement(bC, { variant: "text" }, s || t.formatMessage({ id: "page" }))), A.createElement(bS, { variant: "menu", align: "start", sideOffset: 4 }, r && A.createElement(aI, { onClose: o }))) } function aI({ onClose: e }) { let t = pC(), n = Qp(), r = t.useStore(nI), i = t.useStore(iI), o = n.formatMessage({ id: "page" }), a = A.useCallback((() => { let e = o + " " + (Object.keys(t.document.pages).length + 1); t.createPage(void 0, e) }), [t]), s = A.useCallback((n => { e(), t.changePage(n) }), [t]), [l, c] = A.useState(null), [u, d] = A.useState(null), p = A.useCallback((e => { c(e.currentTarget.id), d(r.findIndex((t => t.id === e.currentTarget.id))), e.dataTransfer.effectAllowed = "move" }), []), h = A.useCallback((e => { e.preventDefault(); let t = r.findIndex((t => t.id === e.currentTarget.id)), n = e.currentTarget.getBoundingClientRect(); t = (e.clientY - n.top) / n.height < .5 ? t : t + 1, d(t) }), [l, r]), f = A.useCallback((() => { null !== l && null !== u && t.movePage(l, u), c(null), d(null) }), [l, u]); return A.createElement(A.Fragment, null, A.createElement(Pf, { dir: "ltr", value: i, onValueChange: s }, r.map(((t, n) => A.createElement(sI, { key: t.id, isDropAbove: n === u && 0 === n, isDropBelow: null !== u && n === u - 1 }, A.createElement(Mf, { title: t.name || o, value: t.id, key: t.id, id: t.id, asChild: !0, onDragOver: h, onDragStart: p, onDrop: f, draggable: !0 }, A.createElement(lI, null, A.createElement("span", { id: t.id }, t.name || o), A.createElement(Tf, null, A.createElement(LE, null, A.createElement(Rd, null))))), A.createElement(JA, { page: t, onClose: e }))))), A.createElement(ME, null), A.createElement(Af, { onSelect: a, asChild: !0 }, A.createElement(FE, null, A.createElement("span", null, A.createElement($p, { id: "create.page" })), A.createElement(LE, null, A.createElement(Ep, null))))) } var sI = AE("div", { position: "relative", display: "grid", gridTemplateColumns: "1fr auto", gridAutoFlow: "column", margin: 0, '& > *[data-shy="true"]': { opacity: 0 }, '&:hover > *[data-shy="true"]': { opacity: 1 }, variants: { isDropAbove: { true: { "&::after": { content: "", display: "block", position: "absolute", top: 0, width: "100%", height: "1px", backgroundColor: "$selected", zIndex: 999, pointerEvents: "none" } } }, isDropBelow: { true: { "&::after": { content: "", display: "block", position: "absolute", width: "100%", height: "1px", top: "100%", backgroundColor: "$selected", zIndex: 999, pointerEvents: "none" } } } } }), lI = AE(FE, { minWidth: 128 }), cI = e => e.appState.currentStyle, uI = e => e.document.pageStates[e.appState.currentPageId].selectedIds, dI = Object.keys(Ix), pI = { draw: A.createElement((function () { return A.createElement("svg", { width: "24", height: "24", viewBox: "1 1.5 21 22", fill: "currentColor", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("path", { d: "M10.0162 19.2768C10.0162 19.2768 9.90679 19.2517 9.6879 19.2017C9.46275 19.1454 9.12816 19.0422 8.68413 18.8921C8.23384 18.7358 7.81482 18.545 7.42707 18.3199C7.03307 18.101 6.62343 17.7883 6.19816 17.3818C5.77289 16.9753 5.33511 16.3718 4.88482 15.5713C4.43453 14.7645 4.1531 13.8545 4.04053 12.8414C3.92795 11.822 4.04991 10.8464 4.40639 9.91451C4.76286 8.98266 5.39452 8.10084 6.30135 7.26906C7.21444 6.44353 8.29325 5.83377 9.5378 5.43976C10.7823 5.05202 11.833 4.92068 12.6898 5.04576C13.5466 5.16459 14.3878 5.43664 15.2133 5.86191C16.0388 6.28718 16.7768 6.8688 17.4272 7.60678C18.0714 8.34475 18.5404 9.21406 18.8344 10.2147C19.1283 11.2153 19.1721 12.2598 18.9657 13.348C18.7593 14.4299 18.2872 15.4337 17.5492 16.3593C16.8112 17.2849 15.9263 18.0072 14.8944 18.5263C13.8624 19.0391 12.9056 19.3174 12.0238 19.3612C11.142 19.405 10.2101 19.2705 9.22823 18.9578C8.24635 18.6451 7.35828 18.151 6.56402 17.4756C5.77601 16.8002 6.08871 16.8658 7.50212 17.6726C8.90927 18.4731 10.1444 18.8484 11.2076 18.7983C12.2645 18.7545 13.2965 18.4825 14.3034 17.9822C15.3102 17.4819 16.1264 16.8221 16.7518 16.0028C17.3772 15.1835 17.7681 14.3111 17.9244 13.3855C18.0808 12.4599 18.0401 11.5781 17.8025 10.74C17.5586 9.902 17.1739 9.15464 16.6486 8.49797C16.1233 7.8413 15.2289 7.27844 13.9656 6.80939C12.7086 6.34034 11.4203 6.20901 10.1007 6.41539C8.78732 6.61552 7.69599 7.06893 6.82669 7.77564C5.96363 8.48859 5.34761 9.26409 4.97863 10.1021C4.60964 10.9402 4.45329 11.8376 4.50958 12.7945C4.56586 13.7513 4.79101 14.6238 5.18501 15.4118C5.57276 16.1998 5.96363 16.8002 6.35764 17.2129C6.75164 17.6257 7.13313 17.9509 7.50212 18.1886C7.87736 18.4325 8.28074 18.642 8.71227 18.8171C9.15005 18.9922 9.47839 19.111 9.69728 19.1736C9.91617 19.2361 10.0256 19.2705 10.0256 19.2768H10.0162Z", strokeWidth: "2" })) }), null), solid: A.createElement((function () { return A.createElement("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2, strokeLinecap: "round" })) }), null), dashed: A.createElement((function () { return A.createElement("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: 5.026548 })) }), null), dotted: A.createElement((function () { return A.createElement("svg", { width: "24", height: "24", stroke: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, A.createElement("circle", { cx: 12, cy: 12, r: 8, fill: "none", strokeWidth: 2.5, strokeLinecap: "round", strokeDasharray: "1.256637 5.026548" })) }), null) }, hI = { small: A.createElement((function (e) { return A.createElement("svg", EE({ width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, e), A.createElement("path", { d: "M12.4239 4.62C13.3572 4.62 14.1572 4.73333 14.8239 4.96C15.4906 5.17333 15.9772 5.43333 16.2839 5.74C16.3639 5.82 16.4039 5.94 16.4039 6.1V8.86H14.0639C13.9172 8.86 13.8439 8.78666 13.8439 8.64V7.26C13.4306 7.12666 12.9572 7.06 12.4239 7.06C11.6506 7.06 11.0639 7.18 10.6639 7.42C10.2639 7.66 10.0639 8.04666 10.0639 8.58V9C10.0639 9.38666 10.1639 9.69333 10.3639 9.92C10.5772 10.1333 11.0306 10.3467 11.7239 10.56L13.6439 11.14C14.4706 11.38 15.1172 11.66 15.5839 11.98C16.0506 12.3 16.3772 12.68 16.5639 13.12C16.7639 13.5467 16.8639 14.0733 16.8639 14.7V15.62C16.8639 16.7933 16.4039 17.7133 15.4839 18.38C14.5639 19.0467 13.2839 19.38 11.6439 19.38C10.6706 19.38 9.79723 19.2867 9.0239 19.1C8.2639 18.9133 7.71056 18.6533 7.3639 18.32C7.3239 18.28 7.29056 18.24 7.2639 18.2C7.25056 18.1467 7.2439 18.06 7.2439 17.94V15.74H7.6239C8.2239 16.1533 8.85056 16.4533 9.5039 16.64C10.1572 16.8267 10.9306 16.92 11.8239 16.92C12.6506 16.92 13.2506 16.7867 13.6239 16.52C14.0106 16.2533 14.2039 15.9333 14.2039 15.56V14.88C14.2039 14.6667 14.1639 14.48 14.0839 14.32C14.0172 14.16 13.8706 14.0133 13.6439 13.88C13.4172 13.7467 13.0572 13.6067 12.5639 13.46L10.6639 12.88C9.7839 12.6133 9.11056 12.3 8.6439 11.94C8.17723 11.58 7.85056 11.18 7.6639 10.74C7.49056 10.3 7.4039 9.83333 7.4039 9.34V8.38C7.4039 7.64666 7.61056 7 8.0239 6.44C8.43723 5.88 9.01723 5.44 9.7639 5.12C10.5239 4.78666 11.4106 4.62 12.4239 4.62Z" })) }), null), medium: A.createElement((function (e) { return A.createElement("svg", EE({ width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, e), A.createElement("path", { d: "M8.16191 19H5.68191C5.53525 19 5.46191 18.9267 5.46191 18.78V5H8.76191C8.88191 5 8.97525 5.03333 9.04191 5.1C9.10858 5.15333 9.17525 5.27333 9.24191 5.46C9.72191 6.59333 10.1686 7.7 10.5819 8.78C11.0086 9.84667 11.4352 10.98 11.8619 12.18H12.1619C12.6019 10.9667 13.0352 9.79333 13.4619 8.66C13.8886 7.52667 14.3552 6.30667 14.8619 5H18.3219C18.4686 5 18.5419 5.07333 18.5419 5.22V19H16.0619C15.9152 19 15.8419 18.9267 15.8419 18.78V16.26C15.8419 15.5267 15.8486 14.8133 15.8619 14.12C15.8886 13.4267 15.9286 12.6867 15.9819 11.9C16.0486 11.1 16.1419 10.1933 16.2619 9.18H15.9019C15.4352 10.3533 14.9486 11.5667 14.4419 12.82C13.9486 14.06 13.4819 15.2333 13.0419 16.34H11.1019C11.0619 16.34 11.0152 16.3333 10.9619 16.32C10.9219 16.2933 10.8886 16.2467 10.8619 16.18C10.4619 15.18 10.0086 14.06 9.50191 12.82C9.00858 11.58 8.53525 10.3667 8.08191 9.18H7.70191C7.83525 10.18 7.93525 11.0733 8.00191 11.86C8.06858 12.6467 8.10858 13.3933 8.12191 14.1C8.14858 14.8067 8.16191 15.5267 8.16191 16.26V19Z" })) }), null), large: A.createElement((function (e) { return A.createElement("svg", EE({ width: 24, height: 24, viewBox: "-2 -2 28 28", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" }, e), A.createElement("path", { d: "M7.68191 19C7.53525 19 7.46191 18.9267 7.46191 18.78V5H10.1219C10.2686 5 10.3419 5.07333 10.3419 5.22V16.56H13.4419V15.02H15.7619C15.9086 15.02 15.9819 15.0933 15.9819 15.24V19H7.68191Z" })) }), null) }, fI = { start: A.createElement(Kp, null), middle: A.createElement(Np, null), end: A.createElement(Yp, null), justify: A.createElement(Up, null) }, mI = e => e.settings.isDarkMode ? "dark" : "light", gI = e => e.settings.keepStyleMenuOpen, vI = e => { let { activeTool: t, currentPageId: n } = e.appState; switch (t) { case "select": { let t = e.document.pages[n], r = !1, i = !1; for (let o of e.document.pageStates[n].selectedIds) "text" in t.shapes[o] && (r = !0), "label" in t.shapes[o] && (i = !0); return r ? "text" : i ? "label" : "" } case "text": return "text"; case "rectangle": case "ellipse": case "triangle": case "arrow": case "line": return "label" }return !1 }, yI = A.memo((function () { let e = pC(), t = Qp(), n = e.useStore(mI), r = e.useStore(gI), i = e.useStore(vI), o = e.useStore(cI), a = e.useStore(uI), [s, l] = A.useState(o), c = A.useRef(o); A.useEffect((() => { let { appState: { currentStyle: t }, page: n, selectedIds: r } = e, i = {}; if (r.length <= 0) i = t; else { let t = new Set([]); e.selectedIds.map((e => n.shapes[e])).forEach((e => { dI.forEach((n => { if (!t.has(n)) if (void 0 === i[n]) i[n] = e.style[n]; else { if (i[n] === e.style[n]) return; i[n] = e.style[n], t.add(n) } })) })) } JSON.stringify(i) !== JSON.stringify(c.current) && (c.current = i, l(i)) }), [o, a]); let u = A.useCallback((t => { e.setSetting("keepStyleMenuOpen", t) }), []), d = A.useCallback((t => { e.style({ isFilled: t }) }), []), p = A.useCallback((t => { e.style({ dash: t }) }), []), h = A.useCallback((t => { e.style({ size: t }) }), []), f = A.useCallback((t => { e.style({ font: t }) }), []), m = A.useCallback((t => { e.style({ textAlign: t }) }), []), g = A.useCallback((t => { e.setMenuOpen(t) }), [e]); return A.createElement(Cf, { dir: "ltr", onOpenChange: g, open: !!r || void 0, modal: !1 }, A.createElement(Sf, { asChild: !0, id: "TD-Styles" }, A.createElement(bC, { "aria-label": t.formatMessage({ id: "styles" }), variant: "text" }, A.createElement($p, { id: "styles" }), A.createElement(CI, { style: { color: hx[n][s.color] } }, s.isFilled && A.createElement(HS, { size: 16, stroke: "none", fill: fx[n][s.color] }), pI[s.dash]))), A.createElement(bS, { id: "TD-StylesMenu", side: "bottom", align: "end", sideOffset: 4, alignOffset: 4 }, A.createElement(wI, { variant: "tall", id: "TD-Styles-Color-Container" }, A.createElement("span", null, A.createElement($p, { id: "style.menu.color" })), A.createElement(bI, null, Object.keys(hx.light).map((r => A.createElement(Af, { key: r, onSelect: gS, asChild: !0, id: `TD-Styles-Color-Swatch-${r}` }, A.createElement(bC, { variant: "icon", isActive: s.color === r, onClick: () => e.style({ color: r }), "aria-label": t.formatMessage({ id: r }) }, A.createElement(HS, { size: 18, strokeWidth: 2.5, fill: s.isFilled ? fx[n][r] : "transparent", stroke: hx.light[r] }))))))), A.createElement(vS, { variant: "styleMenu", checked: !!s.isFilled, onCheckedChange: d, id: "TD-Styles-Fill" }, A.createElement($p, { id: "style.menu.fill" })), A.createElement(wI, { id: "TD-Styles-Dash-Container" }, A.createElement($p, { id: "style.menu.dash" }), A.createElement(EI, { dir: "ltr", value: s.dash, onValueChange: p }, Object.values(rC).map((e => A.createElement(ES, { key: e, isActive: e === s.dash, value: e, onSelect: gS, bp: OE, id: `TD-Styles-Dash-${e}`, "aria-label": t.formatMessage({ id: e }) }, pI[e]))))), A.createElement(wI, { id: "TD-Styles-Size-Container" }, A.createElement($p, { id: "style.menu.size" }), A.createElement(EI, { dir: "ltr", value: s.size, onValueChange: h }, Object.values(nC).map((e => A.createElement(ES, { key: e, isActive: e === s.size, value: e, onSelect: gS, bp: OE, id: `TD-Styles-Dash-${e}`, "aria-label": t.formatMessage({ id: e }) }, hI[e]))))), ("text" === i || "label" === i) && A.createElement(A.Fragment, null, A.createElement(ME, null), A.createElement(wI, { id: "TD-Styles-Font-Container" }, A.createElement($p, { id: "style.menu.font" }), A.createElement(EI, { dir: "ltr", value: s.font, onValueChange: f }, Object.values(aC).map((e => A.createElement(ES, { key: e, isActive: e === s.font, value: e, onSelect: gS, bp: OE, id: `TD-Styles-Font-${e}` }, A.createElement(SI, { fontStyle: e }, "Aa")))))), "text" === i && A.createElement(wI, { id: "TD-Styles-Align-Container" }, A.createElement($p, { id: "style.menu.align" }), A.createElement(EI, { dir: "ltr", value: s.textAlign, onValueChange: m }, Object.values(oC).map((e => A.createElement(ES, { key: e, isActive: e === s.textAlign, value: e, onSelect: gS, bp: OE, id: `TD-Styles-Align-${e}` }, fI[e])))))), A.createElement(ME, null), A.createElement(vS, { variant: "styleMenu", checked: r, onCheckedChange: u, id: "TD-Styles-Keep-Open" }, A.createElement($p, { id: "style.menu.keep.open" })))) })), bI = AE("div", { display: "grid", gridTemplateColumns: "repeat(4, auto)", gap: 0 }), wI = AE("div", { position: "relative", width: "100%", background: "none", border: "none", cursor: "pointer", minHeight: "32px", outline: "none", color: "$text", fontFamily: "$ui", fontWeight: 400, fontSize: "$1", padding: "$2 0 $2 $3", borderRadius: 4, userSelect: "none", WebkitUserSelect: "none", margin: 0, display: "flex", gap: "$3", flexDirection: "row", alignItems: "center", justifyContent: "space-between", variants: { variant: { tall: { alignItems: "flex-start", padding: "0 0 0 $3", "& > span": { paddingTop: "$4" } } } } }), EI = AE(Ef, { display: "flex", flexDirection: "row", gap: "$1" }), CI = AE("div", { display: "grid", "& > *": { gridColumn: 1, gridRow: 1 } }), SI = AE("div", { width: 32, height: 32, display: "flex", alignItems: "center", justifyContent: "center", fontSize: "$3", variants: { fontStyle: { script: { fontFamily: "Caveat Brush" }, sans: { fontFamily: "Recursive" }, serif: { fontFamily: "Georgia" }, mono: { fontFamily: "Recursive Mono" } } } }), kI = e => e.document.pageStates[e.appState.currentPageId].camera.zoom, xI = function () { let e = pC(), t = e.useStore(kI); return A.createElement(Cf, { dir: "ltr" }, A.createElement(Sf, { dir: "ltr", asChild: !0, id: "TD-Zoom" }, A.createElement(AI, { onDoubleClick: e.resetZoom, variant: "text" }, Math.round(100 * t), "%")), A.createElement(bS, { align: "end" }, A.createElement(mS, { onSelect: gS, onClick: e.zoomIn, kbd: "#+", id: "TD-Zoom-Zoom_In" }, A.createElement($p, { id: "zoom.in" })), A.createElement(mS, { onSelect: gS, onClick: e.zoomOut, kbd: "#", id: "TD-Zoom-Zoom_Out" }, A.createElement($p, { id: "zoom.out" })), A.createElement(mS, { onSelect: gS, onClick: e.resetZoom, kbd: "0", id: "TD-Zoom-Zoom_To_100%" }, A.createElement($p, { id: "zoom.to" }), " 100%"), A.createElement(mS, { onSelect: gS, onClick: e.zoomToFit, kbd: "1", id: "TD-Zoom-To_Fit" }, A.createElement($p, { id: "zoom.to.fit" })), A.createElement(mS, { onSelect: gS, onClick: e.zoomToSelection, kbd: "2", id: "TD-Zoom-To_Selection" }, A.createElement($p, { id: "zoom.to.selection" })))) }, AI = AE(bC, { minWidth: 56 }), II = AE("div", { width: "100%", position: "absolute", top: 0, left: 0, right: 0, display: "flex", flexDirection: "row", pointerEvents: "none", "& > *": { pointerEvents: "all" } }), PI = AE("div", { flexGrow: 2, pointerEvents: "none" }), MI = AE("div", { width: "100%", display: "flex", alignItems: "center", justifyContent: "center", fontFamily: "$ui", fontSize: "$1", paddingLeft: "$4", paddingRight: "$1", userSelect: "none", WebkitUserSelect: "none" }), TI = A.memo((function ({ readOnly: e, showPages: t, showMenu: n, showStyles: r, showZoom: i, showMultiplayerMenu: o }) { let a = pC(), s = Qp(); return A.createElement(II, null, (n || t) && A.createElement(uk, { side: "left", id: "TD-MenuPanel" }, n && A.createElement(Hk, { readOnly: e }), o && A.createElement(_A, null), t && A.createElement(oI, null)), A.createElement(PI, null), (r || i) && A.createElement(uk, { side: "right" }, a.readOnly ? A.createElement(MI, null, "Read Only") : A.createElement(A.Fragment, null, A.createElement(wC, { kbd: "#Z", label: s.formatMessage({ id: "undo" }), onClick: a.undo, id: "TD-TopPanel-Undo", "aria-label": s.formatMessage({ id: "undo" }) }, A.createElement(jS, null)), A.createElement(wC, { kbd: "#Z", label: s.formatMessage({ id: "redo" }), onClick: a.redo, id: "TD-TopPanel-Redo", "aria-label": s.formatMessage({ id: "redo" }) }, A.createElement(jS, { flipHorizontal: !0 }))), i && A.createElement(xI, null), r && !e && A.createElement(yI, null))) })), RI = "tldraw_clipboard", BI = class { constructor(e, t, n, r) { var i; kE(this, "_idbId"), kE(this, "initialState"), kE(this, "store"), kE(this, "pointer", -1), kE(this, "_state"), kE(this, "_status", "loading"), kE(this, "stack", []), kE(this, "_snapshot"), kE(this, "useStore"), kE(this, "ready"), kE(this, "isPaused", !1), kE(this, "persist", ((e, t) => { if ("ready" === this._status && (this.onPersist && this.onPersist(this._state, e, t), this._idbId)) return oE(this._idbId, this._state).catch((e => console.error(e))) })), kE(this, "applyPatch", ((e, t) => { let n = this._state, r = Zt.deepMerge(this._state, e), i = this.cleanup(r, n, e, t); return this.onStateWillChange && this.onStateWillChange(i, t), this._state = i, this.store.setState(this._state, !0), this.onStateDidChange && this.onStateDidChange(this._state, t), this })), kE(this, "migrate", (e => e)), kE(this, "cleanup", ((e, t, n, r) => e)), kE(this, "onStateWillChange"), kE(this, "onStateDidChange"), kE(this, "patchState", ((e, t) => (this.applyPatch(e, t), this.onPatch && this.onPatch(this._state, e, t), this))), kE(this, "replaceState", ((e, t) => { let n = this.cleanup(e, this._state, e, t); return this.onStateWillChange && this.onStateWillChange(n, "replace"), this._state = n, this.store.setState(this._state, !0), this.onStateDidChange && this.onStateDidChange(this._state, "replace"), this })), kE(this, "setState", ((e, t = e.id) => (this.pointer < this.stack.length - 1 && (this.stack = this.stack.slice(0, this.pointer + 1)), this.stack.push(CE(EE({}, e), { id: t })), this.pointer = this.stack.length - 1, this.applyPatch(e.after, t), this.onCommand && this.onCommand(this._state, e, t), this.persist(e.after, t), this))), kE(this, "onReady"), kE(this, "onPatch"), kE(this, "onCommand"), kE(this, "onPersist"), kE(this, "onReplace"), kE(this, "onReset"), kE(this, "onResetHistory"), kE(this, "onUndo"), kE(this, "onRedo"), kE(this, "reset", (() => (this.onStateWillChange && this.onStateWillChange(this.initialState, "reset"), this._state = this.initialState, this.store.setState(this._state, !0), this.resetHistory(), this.persist({}, "reset"), this.onStateDidChange && this.onStateDidChange(this._state, "reset"), this.onReset && this.onReset(this._state), this))), kE(this, "replaceHistory", ((e, t = e.length - 1) => (this.stack = e, this.pointer = t, this.onReplace && this.onReplace(this._state), this))), kE(this, "resetHistory", (() => (this.stack = [], this.pointer = -1, this.onResetHistory && this.onResetHistory(this._state), this))), kE(this, "undo", (() => { if (!this.isPaused) { if (!this.canUndo) return this; let e = this.stack[this.pointer]; this.pointer--, this.applyPatch(e.before, "undo"), this.persist(e.before, "undo") } return this.onUndo && this.onUndo(this._state), this })), kE(this, "redo", (() => { if (!this.isPaused) { if (!this.canRedo) return this; this.pointer++; let e = this.stack[this.pointer]; this.applyPatch(e.after, "redo"), this.persist(e.after, "undo") } return this.onRedo && this.onRedo(this._state), this })), kE(this, "setSnapshot", (() => (this._snapshot = EE({}, this._state), this))), kE(this, "forceUpdate", (() => { this.store.setState(this._state, !0) })), this._idbId = t, this._state = _k(e), this._snapshot = _k(e), this.initialState = _k(e), this.store = (i = () => this._state, console.warn("[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."), sE(i)), this.useStore = (e => (console.warn("[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."), (e => e ? dE(e) : dE)(e)))(this.store), this.ready = new Promise((i => { let o = "none"; this._idbId ? (o = "restored", iE(this._idbId).then((a => xE(this, null, (function* () { if (a) { let i = a; if (n) { let s = yield iE(t + "_version"); s && s < n && (i = r ? r(a, e, s) : e, o = "migrated") } yield oE(t + "_version", n || -1); let s = this._state.appState.isEmptyCanvas; i = this.migrate(i), this._state = _k(i), this._snapshot = _k(i), this._state.appState.isEmptyCanvas = s, this.store.setState(this._state, !0) } else yield oE(t + "_version", n || -1); this._status = "ready", i(o) })))).catch((e => console.error(e)))) : (this._status = "ready", i(o)) })).then((e => (this.onReady && this.onReady(e), e))) } pause() { this.isPaused = !0 } resume() { this.isPaused = !1 } get canUndo() { return this.pointer > -1 } get canRedo() { return this.pointer < this.stack.length - 1 } get state() { return this._state } get status() { return this._status } get snapshot() { return this._snapshot } }; function DI(e, t) { var n; let r = e, i = new Set(t); for (; i.has(r);)r = (null == (n = /^.*(\d+)$/.exec(r)) ? void 0 : n[1]) ? r.replace(/(\d+)(?=\D?)$/, (e => (+e + 1).toString())) : `${r} 1`; return r } function LI(e, t, n = []) { let { currentPageId: r } = e, i = {}, o = {}; t.forEach((e => { i[e.id] = void 0, o[e.id] = e })); let a = {}, s = {}; return n.forEach((e => { a[e.id] = void 0, s[e.id] = e })), { id: "create", before: { document: { pages: { [r]: { shapes: i, bindings: a } }, pageStates: { [r]: { selectedIds: [...e.selectedIds] } } } }, after: { document: { pages: { [r]: { shapes: o, bindings: s } }, pageStates: { [r]: { selectedIds: t.map((e => e.id)) } } } } } } function OI(e, t, n = e.currentPageId) { let { pageState: r, selectedIds: i, document: { assets: o } } = e, { before: a, after: s, assetsToRemove: l } = function (e, t, n) { let r = { shapes: {}, bindings: {} }, i = { shapes: {}, bindings: {} }, o = [], a = new Set, s = new Set; t.filter((t => !ZA.getShape(e, t, n).isLocked)).forEach((t => { a.add(t); let l = ZA.getShape(e, t, n); r.shapes[t] = l, i.shapes[t] = void 0, void 0 !== l.children && l.children.forEach((t => { a.add(t); let o = ZA.getShape(e, t, n); r.shapes[t] = o, i.shapes[t] = void 0 })), l.parentId !== n && o.push(ZA.getShape(e, l.parentId, n)), l.assetId && s.add(l.assetId) })), o.forEach((o => { var s; t.includes(o.id) || (a.add(o.id), r.shapes[o.id] = { children: o.children }, i.shapes[o.id] = { children: o.children.filter((e => !t.includes(e))) }, 0 === (null == (s = i.shapes[o.id]) ? void 0 : s.children.length) && (i.shapes[o.id] = void 0, r.shapes[o.id] = ZA.getShape(e, o.id, n))) })); let l = ZA.getPage(e, n); return Object.values(l.bindings).filter((e => a.has(e.fromId) || a.has(e.toId))).forEach((e => { for (let t of [e.toId, e.fromId]) if (void 0 === i.shapes[t]) { r.bindings[e.id] = e, i.bindings[e.id] = void 0; let n = l.shapes[t]; n && n.handles && Object.values(n.handles).filter((t => t.bindingId === e.id)).forEach((n => { var o, s, l, c, u, d; r.shapes[t] = CE(EE({}, r.shapes[t]), { handles: CE(EE({}, null == (o = r.shapes[t]) ? void 0 : o.handles), { [n.id]: CE(EE({}, null == (l = null == (s = r.shapes[t]) ? void 0 : s.handles) ? void 0 : l[n.id]), { bindingId: e.id }) }) }), a.has(t) || (i.shapes[t] = CE(EE({}, i.shapes[t]), { handles: CE(EE({}, null == (c = i.shapes[t]) ? void 0 : c.handles), { [n.id]: CE(EE({}, null == (d = null == (u = i.shapes[t]) ? void 0 : u.handles) ? void 0 : d[n.id]), { bindingId: void 0 }) }) })) })) } })), Object.values(e.document.pages).flatMap((e => Object.values(e.shapes))).forEach((e => { "assetId" in e && e.assetId && !a.has(e.id) && s.delete(e.assetId) })), { before: r, after: i, assetsToRemove: Array.from(s) } }(e.state, t, n), c = ((e, t) => { let n = EE({}, e); return t.forEach((e => n[e] = void 0)), n })(o, l); return { id: "delete", before: { document: { assets: o, pages: { [n]: a }, pageStates: { [n]: { selectedIds: [...e.selectedIds] } } } }, after: { document: { assets: c, pages: { [n]: s }, pageStates: { [n]: { selectedIds: i.filter((e => !t.includes(e))), hoveredId: r.hoveredId && t.includes(r.hoveredId) ? void 0 : r.hoveredId } } } } } } function FI(e, t, n) { let { selectedIds: r, currentPageId: i, page: { shapes: o } } = e, a = t.map((e => ZA.getBounds(o[e]))), s = 1 === t.length && "group" === o[t[0]].type, l = Zt.getCommonBounds(a), { before: c, after: u } = ZA.mutateShapes(e.state, t, (e => { let t = ZA.getBounds(e), r = e.parentId !== i; switch (n) { case "horizontal": { if (r && !s) { let n = ZA.getBounds(o[e.parentId]), r = Zt.getRelativeTransformedBoundingBox(l, l, n, !0, !1).minX - n.minX; return ZA.getShapeUtil(e).transform(e, CE(EE({}, t), { minX: t.minX + r, maxX: t.maxX + r }), { type: Kt.TopLeft, scaleX: 1, scaleY: 1, initialShape: e, transformOrigin: [.5, .5] }) } let n = Zt.getRelativeTransformedBoundingBox(l, l, t, !0, !1); return ZA.getShapeUtil(e).transform(e, n, { type: Kt.TopLeft, scaleX: -1, scaleY: 1, initialShape: e, transformOrigin: [.5, .5] }) } case "vertical": { if (r && !s) { let n = ZA.getBounds(o[e.parentId]), r = Zt.getRelativeTransformedBoundingBox(l, l, n, !1, !0).minY - n.minY; return ZA.getShapeUtil(e).transform(e, CE(EE({}, t), { minY: t.minY + r, maxY: t.maxY + r }), { type: Kt.TopLeft, scaleX: 1, scaleY: 1, initialShape: e, transformOrigin: [.5, .5] }) } let n = Zt.getRelativeTransformedBoundingBox(l, l, t, !1, !0); return ZA.getShapeUtil(e).transform(e, n, { type: Kt.TopLeft, scaleX: 1, scaleY: -1, initialShape: e, transformOrigin: [.5, .5] }) } } }), i, !0); return { id: "flip", before: { document: { pages: { [i]: { shapes: c } }, pageStates: { [i]: { selectedIds: r } } } }, after: { document: { pages: { [i]: { shapes: u } }, pageStates: { [i]: { selectedIds: t } } } } } } function zI(e, t, n) { let r, i, o, { currentPageId: a, page: s } = e, l = new Set(t.map((t => e.getShape(t).parentId))), c = { before: {}, after: {} }; return Array.from(l.values()).forEach((l => { let u = []; if (l === s.id) u = Object.values(s.shapes).sort(((e, t) => e.childIndex - t.childIndex)); else { let t = e.getShape(l); if (!t.children) throw Error("No children in parent!"); u = t.children.map((t => e.getShape(t))).sort(((e, t) => e.childIndex - t.childIndex)) } let d = u.map((e => e.id)), p = t.filter((e => d.includes(e))).map((e => d.indexOf(e))).sort(((e, t) => e - t)); if (p.length !== d.length) switch (n) { case "toBack": for (let e = 0; e < d.length; e++)if (!p.includes(e)) { r = e; break } i = u[r].childIndex, o = i / (p.length + 1), c = ZA.mutateShapes(e.state, p.map((e => u[e].id)).reverse(), ((e, t) => ({ childIndex: i - (t + 1) * o })), a); break; case "toFront": for (let e = d.length - 1; e >= 0; e--)if (!p.includes(e)) { r = e; break } i = u[r].childIndex, o = 1, c = ZA.mutateShapes(e.state, p.map((e => u[e].id)), ((e, t) => ({ childIndex: i + (t + 1) })), a); break; case "backward": { let t = {}; for (let e = d.length - 1; e >= 0; e--)if (p.includes(e)) for (let n = e; n >= 0; n--)if (!p.includes(n)) { let r, i, o = u[n].childIndex; 0 === n ? (r = o / 2, i = o / 2 / (e - n + 1)) : (r = u[n - 1].childIndex, i = (o - r) / (e - n + 1), r += i); for (let o = 0; o < e - n; o++)t[u[n + o + 1].id] = r + i * o; break } Object.values(t).length > 0 && (c = ZA.mutateShapes(e.state, p.map((e => u[e].id)), (e => ({ childIndex: t[e.id] })), a)); break } case "forward": { let t = {}; for (let e = 0; e < d.length; e++)if (p.includes(e)) for (let n = e; n < d.length; n++)if (!p.includes(n)) { i = u[n].childIndex; let r = n === d.length - 1 ? 1 : (u[n + 1].childIndex - i) / (n - e + 1); for (let o = 0; o < n - e; o++)t[u[e + o].id] = i + r * (o + 1); break } Object.values(t).length > 0 && (c = ZA.mutateShapes(e.state, p.map((e => u[e].id)), (e => ({ childIndex: t[e.id] })), a)); break } } })), { id: "move", before: { document: { pages: { [a]: { shapes: c.before } }, pageStates: { [a]: { selectedIds: t } } } }, after: { document: { pages: { [a]: { shapes: c.after } }, pageStates: { [a]: { selectedIds: t } } } } } } function HI(e, t, n) { let { currentPageId: r } = e, { before: i, after: o } = ZA.mutateShapes(e.state, t, (t => { var n, r; return null == (r = (n = e.getShapeUtil(t)).onDoubleClickBoundsHandle) ? void 0 : r.call(n, t) }), n); return { id: "reset_bounds", before: { document: { pages: { [r]: { shapes: i } }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: { shapes: o } }, pageStates: { [r]: { selectedIds: t } } } } } } var NI = 2 * Math.PI; function jI(e, t, n) { let { currentPageId: r } = e, i = t.map((t => e.getShape(t))).filter((e => "isLocked" === n || !e.isLocked)), o = i.every((e => e[n])), a = {}, s = {}; return i.forEach((e => { a[e.id] = { [n]: e[n] }, s[e.id] = { [n]: !o } })), { id: "toggle", before: { document: { pages: { [r]: { shapes: a } }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: { shapes: s } }, pageStates: { [r]: { selectedIds: t } } } } } } function UI(e, t, n) { let r = t.map((e => e.id)), i = ZA.mutateShapes(e.state, r.filter((t => !e.getShape(t, n).isLocked)), ((e, n) => t[n]), n); return { id: "update", before: { document: { pages: { [n]: { shapes: i.before } } } }, after: { document: { pages: { [n]: { shapes: i.after } } } } } } var VI = {}; function KI(e, t) { let { document: n, settings: r } = e, { version: i = 0 } = n; "assets" in n || (n.assets = {}); let o = new Set; return Object.values(n.pages).forEach((e => Object.values(e.shapes).forEach((t => { let { parentId: n, children: r, assetId: i } = t; i && o.add(i), n !== e.id && !e.shapes[n] && (console.warn("Encountered a shape with a missing parent!"), t.parentId = e.id), "group" === t.type && r && r.forEach((n => { e.shapes[n] || (console.warn("Encountered a parent with a missing child!", t.id, n), null == r || r.splice(r.indexOf(n), 1)) })) })))), Object.keys(n.assets).forEach((e => { o.has(e) || delete n.assets[e] })), i !== t && (i < 14 && Object.values(n.pages).forEach((e => { Object.values(e.shapes).filter((e => "text" === e.type)).forEach((e => "script" === e.style.font)) })), i <= 13 && Object.values(n.pages).forEach((e => { Object.values(e.bindings).forEach((e => { Object.assign(e, e.meta) })), Object.values(e.shapes).forEach((e => { Object.entries(e.style).forEach((([t, n]) => { "string" == typeof n && (e.style[t] = n.toLowerCase()) })), "arrow" === e.type && e.decorations && Object.entries(e.decorations).forEach((([t, n]) => { "Arrow" === n && (e.decorations = CE(EE({}, e.decorations), { [t]: "arrow" })) })) })) })), i <= 13.1 && (n.name = "New Document"), i < 15 && (n.assets = {}), Object.values(n.pages).forEach((e => { Object.values(e.shapes).forEach((e => { i < 15.2 && ("image" === e.type || "video" === e.type) && (e.style.isFilled = !0), i < 15.3 && ("rectangle" === e.type || "triangle" === e.type || "ellipse" === e.type || "arrow" === e.type) && (e.label = e.text || "", e.labelPoint = [.5, .5]) })) })), i < 15.4 && (r.dockPosition = "bottom"), i < 15.5 && (r.exportBackground = "transparent")), Object.values(n.pageStates).forEach((e => { e.selectedIds = e.selectedIds.filter((t => void 0 !== n.pages[e.id].shapes[t])), e.bindingId = void 0, e.editingId = void 0, e.hoveredId = void 0, e.pointedId = void 0 })), n.version = t, e } ((e, t) => { for (var n in t) pE(e, n, { get: t[n], enumerable: !0 }) })(VI, { fileToBase64: () => qI, fileToText: () => JI, getImageSizeFromSrc: () => $I, getVideoSizeFromSrc: () => eP, loadFileHandle: () => GI, migrate: () => KI, openAssetsFromFileSystem: () => QI, openFromFileSystem: () => _I, saveFileHandle: () => ZI, saveToFileSystem: () => XI }); var WI = { mode: "readwrite" }, YI = e => xE(void 0, null, (function* () { return "granted" === (yield e.queryPermission(WI)) || "granted" === (yield e.requestPermission(WI)) })); function GI() { return xE(this, null, (function* () { if ("undefined" != typeof Window && "_location" in Window) return (yield iE(`Tldraw_file_handle_${window.location.origin}`)) || null })) } function ZI(e) { return xE(this, null, (function* () { return oE(`Tldraw_file_handle_${window.location.origin}`, e) })) } function XI(e, t, n) { return xE(this, null, (function* () { let r = { name: e.name || "New Document", fileHandle: null != t ? t : null, document: e }, i = JSON.stringify(r), o = new Blob([i], { type: "application/vnd.Tldraw+json" }); if (t && !(yield YI(t))) return null; let a = !Dw && (null == n ? void 0 : n.length) ? n : `${r.name}`, s = yield Nw(o, { fileName: `${a}${Vk}`, description: "Tldraw File", extensions: [`${Vk}`] }, t); return yield ZI(s), s })) } function _I() { return xE(this, null, (function* () { var e; let t = yield Ow({ description: "Tldraw File", extensions: [`${Vk}`], multiple: !1 }); if (!t) return null; let n = yield new Promise((e => { let n = new FileReader; n.onloadend = () => { n.readyState === FileReader.DONE && e(n.result) }, n.readAsText(t, "utf8") })), r = JSON.parse(n); if ("tldrawFileFormatVersion" in r) return alert("This file was created in a newer version of tldraw. Please visit beta.tldraw.com to open it."), null; let i = null != (e = t.handle) ? e : null; return yield ZI(i), { fileHandle: i, document: r.document } })) } function QI() { return xE(this, null, (function* () { return Ow({ description: "Image or Video", extensions: [...Zk, ...Xk], multiple: !0 }) })) } function qI(e) { return new Promise(((t, n) => { if (e) { let r = new FileReader; r.readAsDataURL(e), r.onload = () => t(r.result), r.onerror = e => n(e), r.onabort = e => n(e) } })) } function JI(e) { return new Promise(((t, n) => { if (e) { let r = new FileReader; r.readAsText(e), r.onload = () => t(r.result), r.onerror = e => n(e), r.onabort = e => n(e) } })) } function $I(e) { return new Promise(((t, n) => { let r = new Image; r.onload = () => t([r.width, r.height]), r.onerror = () => n(new Error("Could not get image size")), r.src = e })) } function eP(e) { return new Promise(((t, n) => { let r = document.createElement("video"); r.onloadedmetadata = () => t([r.videoWidth, r.videoHeight]), r.onerror = () => n(new Error("Could not get video size")), r.src = e })) } ((e, t, n, r) => { if (t && "object" == typeof t || "function" == typeof t) for (let n of gE(t)) !yE.call(e, n) && "default" !== n && pE(e, n, { get: () => t[n], enumerable: !(r = fE(t, n)) || r.enumerable }) })(VI, r); var tP = class { constructor(e) { this.app = e } }, nP = { arrow: class extends tP { constructor(e, t, n, r = !1) { var i, o, a; super(e), kE(this, "type", "arrow"), kE(this, "performanceMode"), kE(this, "status", "translatingHandle"), kE(this, "newStartBindingId", Zt.uniqueId()), kE(this, "draggedBindingId", Zt.uniqueId()), kE(this, "didBind", !1), kE(this, "initialShape"), kE(this, "handleId"), kE(this, "bindableShapeIds"), kE(this, "initialBinding"), kE(this, "startBindingShapeId"), kE(this, "isCreate"), kE(this, "start", (() => { })), kE(this, "update", (() => { var e, t, n; let { initialShape: r } = this, { currentPoint: i, shiftKey: o, altKey: a, metaKey: s, currentGrid: l, settings: { showGrid: c } } = this.app, u = this.app.getShape(r.id); if (u.isLocked) return; let { handles: d } = r, p = this.handleId; if (!d[p].canBind) return; let h = R.sub(i, R.add(d[p].point, r.point)); if (o) { let e = a ? R.med(d.start.point, d.end.point) : d["start" === p ? "end" : "start"].point, t = d[p].point, n = R.add(t, h), r = R.angle(e, n), i = R.rotWith(n, e, Zt.snapAngleToSegments(r, 24) - r); h = R.add(h, R.sub(i, n)) } let f = R.add(d[p].point, h), m = { [p]: CE(EE({}, d[p]), { point: c ? R.snap(f, l) : R.toFixed(f), bindingId: void 0 }) }, g = WA.arrow, v = null == (e = g.onHandleChange) ? void 0 : e.call(g, r, m); if (!v) return; let y, b = { shape: Zt.deepMerge(u, v), bindings: {} }, w = b.shape.handles[this.handleId], E = b.shape.handles["start" === this.handleId ? "end" : "start"]; if (this.startBindingShapeId) { let e, t = this.app.page.shapes[this.startBindingShapeId], n = ZA.getShapeUtil(t), o = n.getCenter(t), a = b.shape.handles.start, l = b.shape.handles.end, c = R.add(a.point, b.shape.point); R.isEqual(c, o) && c[1]++; let d = o, p = n.hitTestPoint(t, i), h = R.uni(R.sub(c, d)), f = void 0 !== this.app.getBinding(this.newStartBindingId); !s && !n.hitTestPoint(t, R.add(b.shape.point, l.point)) && (e = this.findBindingPoint(u, t, "start", this.newStartBindingId, o, d, h, p)), e && !f ? (this.didBind = !0, b.bindings[this.newStartBindingId] = e, b.shape = Zt.deepMerge(b.shape, { handles: { start: { bindingId: e.id } } })) : !e && f && (this.didBind = !1, b.bindings[this.newStartBindingId] = void 0, b.shape = Zt.deepMerge(r, { handles: { start: { bindingId: void 0 } } })) } if (!s) { let e = R.add(E.point, b.shape.point), t = R.add(w.point, b.shape.point), n = R.uni(R.sub(t, e)), r = R.add(b.shape.point, b.shape.handles.start.point), i = R.add(b.shape.point, b.shape.handles.end.point), o = this.bindableShapeIds.map((e => this.app.page.shapes[e])).sort(((e, t) => t.childIndex - e.childIndex)).filter((e => { if (e.isLocked) return !1; let t = ZA.getShapeUtil(e); return ![r, i].every((n => t.hitTestPoint(e, n))) })); for (let r of o) if (y = this.findBindingPoint(u, r, this.handleId, this.draggedBindingId, t, e, n, a), y) break } if (y) this.didBind = !0, b.bindings[this.draggedBindingId] = y, b.shape = Zt.deepMerge(b.shape, { handles: { [this.handleId]: { bindingId: this.draggedBindingId } } }); else { this.didBind = this.didBind || !1; let e = u.handles[this.handleId].bindingId; void 0 !== e && (b.bindings[e] = void 0, b.shape = Zt.deepMerge(b.shape, { handles: { [this.handleId]: { bindingId: void 0 } } })) } let C = null == (n = (t = ZA.getShapeUtil(b.shape)).onHandleChange) ? void 0 : n.call(t, b.shape, b.shape.handles); return { document: { pages: { [this.app.currentPageId]: { shapes: { [u.id]: EE(EE({}, b.shape), null != C ? C : {}) }, bindings: b.bindings } }, pageStates: { [this.app.currentPageId]: { bindingId: b.shape.handles[p].bindingId } } } } })), kE(this, "cancel", (() => { let { initialShape: e, initialBinding: t, newStartBindingId: n, draggedBindingId: r } = this, i = ZA.onSessionComplete(this.app.page.shapes[e.id]), o = this.isCreate || R.dist(i.handles.start.point, i.handles.end.point) < 4, a = {}; return a[r] = void 0, t && (a[t.id] = o ? void 0 : t), n && (a[n] = void 0), { document: { pages: { [this.app.currentPageId]: { shapes: { [e.id]: o ? void 0 : e }, bindings: a } }, pageStates: { [this.app.currentPageId]: { selectedIds: o ? [] : [e.id], bindingId: void 0, hoveredId: void 0, editingId: void 0 } } } } })), kE(this, "complete", (() => { let { initialShape: e, initialBinding: t, newStartBindingId: n, startBindingShapeId: r, handleId: i } = this, o = ZA.onSessionComplete(this.app.page.shapes[e.id]), a = o.handles[i].bindingId, s = R.dist(o.handles.start.point, o.handles.end.point); if (!a && !t && s < 4) return this.cancel(); let l = {}, c = {}; return t && (l[t.id] = this.isCreate ? void 0 : t, c[t.id] = void 0), a && (l[a] = void 0, c[a] = this.app.page.bindings[a]), r && (l[n] = void 0, c[n] = this.app.page.bindings[n]), { id: "arrow", before: { document: { pages: { [this.app.currentPageId]: { shapes: { [e.id]: this.isCreate ? void 0 : e }, bindings: l } }, pageStates: { [this.app.currentPageId]: { selectedIds: this.isCreate ? [] : [e.id], bindingId: void 0, hoveredId: void 0, editingId: void 0 } } } }, after: { document: { pages: { [this.app.currentPageId]: { shapes: { [e.id]: o }, bindings: c } }, pageStates: { [this.app.currentPageId]: { selectedIds: [e.id], bindingId: void 0, hoveredId: void 0, editingId: void 0 } } } } } })), kE(this, "findBindingPoint", ((e, t, n, r, i, o, a, s) => { let l = ZA.getShapeUtil(t.type).getBindingPoint(t, e, i, o, a, s); if (l) return { id: r, type: "arrow", fromId: e.id, toId: t.id, handleId: n, point: R.toFixed(l.point), distance: l.distance } })), this.isCreate = r; let { currentPageId: s } = e.state.appState, l = e.state.document.pages[s]; this.handleId = n, this.initialShape = _k(l.shapes[t]), this.bindableShapeIds = ZA.getBindableShapeIds(e.state).filter((e => !(e === this.initialShape.id || e === this.initialShape.parentId))); let c = null == (i = this.initialShape.handles["start" === n ? "end" : "start"]) ? void 0 : i.bindingId; if (c) { let e = null == (o = l.bindings[c]) ? void 0 : o.toId; e && (this.bindableShapeIds = this.bindableShapeIds.filter((t => t !== e))) } let { originPoint: u } = this.app; if (this.isCreate) this.startBindingShapeId = null == (a = this.bindableShapeIds.map((e => l.shapes[e])).filter((e => !e.isLocked && Zt.pointInBounds(u, ZA.getShapeUtil(e).getBounds(e)))).sort(((e, t) => t.childIndex - e.childIndex))[0]) ? void 0 : a.id, this.startBindingShapeId && this.bindableShapeIds.splice(this.bindableShapeIds.indexOf(this.startBindingShapeId), 1); else { let e = this.initialShape.handles[this.handleId].bindingId; e ? this.initialBinding = l.bindings[e] : this.initialShape.handles[this.handleId].bindingId = void 0 } } }, brush: class extends tP { constructor(e) { super(e), kE(this, "type", "brush"), kE(this, "performanceMode"), kE(this, "status", "brushing"), kE(this, "initialSelectedIds"), kE(this, "shapesToTest"), kE(this, "start", (() => { })), kE(this, "update", (() => { let { initialSelectedIds: e, shapesToTest: t, app: { metaKey: n, settings: r, originPoint: i, currentPoint: o } } = this, a = Zt.getBoundsFromPoints([i, o]), s = r.isCadSelectMode ? !n && i[0] < o[0] : n, l = new Set, c = new Set(e); t.forEach((({ id: e, selectId: t }) => { let n = this.app.getShape(e); if (!l.has(t)) { let e = this.app.getShapeUtil(n); (s ? Zt.boundsContain(a, e.getBounds(n)) : e.hitTestBounds(n, a)) ? (l.add(t), c.has(t) || c.add(t)) : c.has(t) && c.delete(t) } })); let u = this.app.selectedIds, d = c.size !== u.length || u.some((e => !c.has(e))), p = d ? Array.from(c.values()) : u; return d ? { appState: { selectByContain: s }, document: { pageStates: { [this.app.currentPageId]: { brush: a, selectedIds: p } } } } : { appState: { selectByContain: s }, document: { pageStates: { [this.app.currentPageId]: { brush: a } } } } })), kE(this, "cancel", (() => ({ appState: { selectByContain: !1 }, document: { pageStates: { [this.app.currentPageId]: { brush: null, selectedIds: Array.from(this.initialSelectedIds.values()) } } } }))), kE(this, "complete", (() => ({ appState: { selectByContain: !1 }, document: { pageStates: { [this.app.currentPageId]: { brush: null, selectedIds: [...this.app.selectedIds] } } } }))); let { currentPageId: t } = e; this.initialSelectedIds = new Set(this.app.selectedIds), this.shapesToTest = this.app.shapes.filter((e => !(e.isLocked || e.isHidden || e.parentId !== t || this.initialSelectedIds.has(e.id) || this.initialSelectedIds.has(e.parentId)))).map((e => ({ id: e.id, bounds: this.app.getShapeUtil(e).getBounds(e), selectId: e.id }))), this.update() } }, draw: class extends tP { constructor(e, t) { var n; super(e), kE(this, "type", "draw"), kE(this, "performanceMode"), kE(this, "status", "creating"), kE(this, "topLeft"), kE(this, "points"), kE(this, "initialShape"), kE(this, "lastAdjustedPoint"), kE(this, "shiftedPoints", []), kE(this, "shapeId"), kE(this, "isLocked"), kE(this, "isExtending"), kE(this, "lockedDirection"), kE(this, "start", (() => { var e; let t = this.app.originPoint, n = [0, 0, null != (e = t[2]) ? e : .5]; this.points.push(n); let r = [Math.min(this.topLeft[0], t[0]), Math.min(this.topLeft[1], t[1])], i = R.sub(r, t); return this.topLeft = r, this.shiftedPoints = this.points.map((e => R.toFixed(R.sub(e, i)).concat(e[2]))), { document: { pages: { [this.app.currentPageId]: { shapes: { [this.shapeId]: { point: this.topLeft, points: this.shiftedPoints } } } }, pageStates: { [this.app.currentPageId]: { selectedIds: [this.shapeId] } } } } })), kE(this, "update", (() => { let { shapeId: e } = this, { currentPoint: t, originPoint: n, shiftKey: r, zoom: i } = this.app; if (!this.lockedDirection && this.points.length > 1) { let e = R.sub(t, n); R.len(e) > 3 / i && (this.lockedDirection = Math.abs(e[0]) > Math.abs(e[1]) ? "horizontal" : "vertical") } if (r) { if (!this.isLocked && this.points.length > 2) { if (!this.lockedDirection) { let e = R.sub(t, n); R.len(e) > 3 / i && (this.lockedDirection = Math.abs(e[0]) > Math.abs(e[1]) ? "horizontal" : "vertical") } this.isLocked = !0; let e = [...this.lastAdjustedPoint]; "vertical" === this.lockedDirection ? e[0] = 0 : e[1] = 0, this.points.push(e.concat(t[2])) } } else this.isLocked && (this.isLocked = !1); this.isLocked && ("vertical" === this.lockedDirection ? t[0] = n[0] : t[1] = n[1]); let o = this.addPoint(t); if (o) return { document: { pages: { [this.app.currentPageId]: { shapes: { [e]: o } } }, pageStates: { [this.app.currentPageId]: { selectedIds: [e] } } } } })), kE(this, "cancel", (() => { let { shapeId: e } = this, t = this.app.currentPageId; return { document: { pages: { [t]: { shapes: { [e]: this.isExtending ? this.initialShape : void 0 } } }, pageStates: { [t]: { selectedIds: [] } } } } })), kE(this, "complete", (() => { let { shapeId: e } = this, t = this.app.currentPageId, n = this.app.getShape(e); return { id: "create_draw", before: { document: { pages: { [t]: { shapes: { [e]: this.isExtending ? this.initialShape : void 0 } } }, pageStates: { [t]: { selectedIds: [] } } } }, after: { document: { pages: { [t]: { shapes: { [e]: CE(EE({}, n), { point: R.toFixed(n.point), points: n.points.map((e => R.toFixed(e))), isComplete: !0 }) } } }, pageStates: { [this.app.currentPageId]: { selectedIds: [] } } } } } })), kE(this, "addPoint", (e => { let { originPoint: t } = this.app, n = R.toFixed(R.sub(e, t)).concat(e[2]); if (R.isEqual(this.lastAdjustedPoint, n)) return; this.points.push(n), this.lastAdjustedPoint = n; let r, i = [...this.topLeft], o = [Math.min(this.topLeft[0], e[0]), Math.min(this.topLeft[1], e[1])], a = R.sub(o, t); return i[0] !== o[0] || i[1] !== o[1] ? (this.topLeft = o, r = this.points.map((e => R.toFixed(R.sub(e, a)).concat(e[2])))) : r = [...this.shiftedPoints, R.sub(n, a).concat(n[2])], this.shiftedPoints = r, { point: this.topLeft, points: r } })); let { originPoint: r } = this.app; this.shapeId = t, this.initialShape = this.app.getShape(t), this.topLeft = [...this.initialShape.point]; let i = [0, 0, null != (n = r[2]) ? n : .5], o = R.sub(r, this.topLeft), a = this.initialShape.points.map((e => R.sub(e, o).concat(e[2]))); this.isExtending = a.length > 0; let s = []; if (this.isExtending) { let e = a[a.length - 1]; if (e) { s.push(e, e); let t = Math.floor(R.dist(e, i) / 16); if (t > 1) for (let n = 0; n < t; n++) { let r = n / (t - 1); s.push(R.lrp(e, i, r).concat(e[2])) } else s.push(i, i) } } else s.push(i); this.points = [...a, ...s], this.shiftedPoints = this.points.map((e => R.add(e, o).concat(e[2]))), this.lastAdjustedPoint = this.points[this.points.length - 1] } }, erase: class extends tP { constructor(e) { super(e), kE(this, "type", "draw"), kE(this, "performanceMode"), kE(this, "status", "creating"), kE(this, "isLocked"), kE(this, "lockedDirection"), kE(this, "erasedShapes", new Set), kE(this, "erasedBindings", new Set), kE(this, "initialSelectedShapes"), kE(this, "erasableShapes"), kE(this, "prevPoint"), kE(this, "prevEraseShapesSize", 0), kE(this, "interval"), kE(this, "timestamp1", 0), kE(this, "timestamp2", 0), kE(this, "prevErasePoint", []), kE(this, "loop", (() => { let e = Date.now(), t = e - this.timestamp1, n = e - this.timestamp2, { eraseLine: r } = this.app.appState, i = [...r], o = !1; t > 16 && this.prevErasePoint !== this.prevPoint && (o = !0, i = [...r, this.prevPoint], this.prevErasePoint = this.prevPoint), n > 32 && i.length > 1 && (o = !0, i.splice(0, Math.ceil(.1 * i.length)), this.timestamp2 = e), o && this.app.patchState({ appState: { eraseLine: i } }, "eraseline"), this.interval = requestAnimationFrame(this.loop) })), kE(this, "start", (() => { })), kE(this, "update", (() => { let { page: e, shiftKey: t, originPoint: n, currentPoint: r, zoom: i } = this.app; if (t) { let e = R.sub(r, n); if (!this.isLocked && R.len(e) > 3 / i) { if (!this.lockedDirection) { let e = R.sub(r, n); this.lockedDirection = Math.abs(e[0]) > Math.abs(e[1]) ? "horizontal" : "vertical" } this.isLocked = !0 } } else this.isLocked && (this.isLocked = !1); this.isLocked && ("vertical" === this.lockedDirection ? r[0] = n[0] : r[1] = n[1]); let o = R.toFixed(R.add(n, R.sub(r, n))), a = new Set([]); this.erasableShapes.forEach((e => { if (!this.erasedShapes.has(e) && this.app.getShapeUtil(e).hitTestLineSegment(e, this.prevPoint, o) && (this.erasedShapes.add(e), a.add(e.id), void 0 !== e.children)) for (let t of e.children) this.erasedShapes.add(this.app.getShape(t)), a.add(t) })), Object.values(e.bindings).forEach((e => { for (let t of [e.toId, e.fromId]) a.has(t) && this.erasedBindings.add(e) })), this.erasedShapes.forEach((e => { this.app.getShape(e.id) || (this.erasedShapes.delete(e), this.erasableShapes.delete(e), a.delete(e.id)) })); let s = Array.from(this.erasedShapes.values()); if (this.prevPoint = o, s.length !== this.prevEraseShapesSize) return this.prevEraseShapesSize = s.length, { document: { pages: { [e.id]: { shapes: Object.fromEntries(s.map((e => [e.id, { isGhost: !0 }]))) } } } } })), kE(this, "cancel", (() => { let { page: e } = this.app; cancelAnimationFrame(this.interval), this.erasedShapes.forEach((e => { this.app.getShape(e.id) || (this.erasedShapes.delete(e), this.erasableShapes.delete(e)) })); let t = Array.from(this.erasedShapes.values()); return { document: { pages: { [e.id]: { shapes: Object.fromEntries(t.map((e => [e.id, { isGhost: !1 }]))) } }, pageStates: { [e.id]: { selectedIds: this.initialSelectedShapes.map((e => e.id)) } } }, appState: { eraseLine: [] } } })), kE(this, "complete", (() => { let { page: e } = this.app; cancelAnimationFrame(this.interval), this.erasedShapes.forEach((e => { this.app.getShape(e.id) || (this.erasedShapes.delete(e), this.erasableShapes.delete(e)) })), this.erasedBindings.forEach((e => { this.app.getBinding(e.id) || this.erasedBindings.delete(e) })); let t = Array.from(this.erasedShapes.values()), n = Array.from(this.erasedBindings.values()), r = t.map((e => e.id)), i = n.map((e => e.id)), o = { shapes: Object.fromEntries(t.map((e => [e.id, e]))), bindings: Object.fromEntries(n.map((e => [e.id, e]))) }, a = { shapes: Object.fromEntries(t.map((e => [e.id, void 0]))), bindings: Object.fromEntries(n.map((e => [e.id, void 0]))) }; return this.app.shapes.forEach((e => { e.handles && !a.shapes[e.id] && Object.values(e.handles).forEach((t => { var n, s; t.bindingId && i.includes(t.bindingId) && (o.shapes[e.id] = CE(EE({}, o.shapes[e.id]), { handles: CE(EE({}, null == (n = o.shapes[e.id]) ? void 0 : n.handles), { [t.id]: t }) }), r.includes(e.id) || (a.shapes[e.id] = CE(EE({}, a.shapes[e.id]), { handles: CE(EE({}, null == (s = a.shapes[e.id]) ? void 0 : s.handles), { [t.id]: CE(EE({}, t), { bindingId: void 0 }) }) }))) })) })), { id: "erase", before: { document: { pages: { [e.id]: o }, pageStates: { [e.id]: { selectedIds: this.initialSelectedShapes.filter((e => !!this.app.getShape(e.id))).map((e => e.id)) } } }, appState: { eraseLine: [] } }, after: { document: { pages: { [e.id]: a }, pageStates: { [e.id]: { selectedIds: this.initialSelectedShapes.filter((e => !!this.app.getShape(e.id))).filter((e => !r.includes(e.id))).map((e => e.id)) } } }, appState: { eraseLine: [] } } } })), this.prevPoint = [...e.originPoint], this.initialSelectedShapes = this.app.selectedIds.map((e => this.app.getShape(e))), this.erasableShapes = new Set(this.app.shapes.filter((e => !e.isLocked))), this.interval = this.loop() } }, handle: class extends tP { constructor(e, t, n, r = "move_handle") { super(e), kE(this, "type", "handle"), kE(this, "performanceMode"), kE(this, "status", "translatingHandle"), kE(this, "commandId"), kE(this, "topLeft"), kE(this, "shiftKey", !1), kE(this, "initialShape"), kE(this, "handleId"), kE(this, "start", (() => { })), kE(this, "update", (() => { var e, t; let { initialShape: n, app: { currentPageId: r, currentPoint: i } } = this, o = this.app.getShape(n.id); if (o.isLocked) return; let a = o.handles, s = this.handleId, l = R.sub(i, a[s].point), c = { [s]: CE(EE({}, a[s]), { point: R.sub(R.add(a[s].point, l), o.point) }) }, u = null == (t = (e = ZA.getShapeUtil(o)).onHandleChange) ? void 0 : t.call(e, o, c); return u ? { document: { pages: { [r]: { shapes: { [o.id]: u } } } } } : void 0 })), kE(this, "cancel", (() => { let { initialShape: e, app: { currentPageId: t } } = this; return { document: { pages: { [t]: { shapes: { [e.id]: e } } } } } })), kE(this, "complete", (() => { let { initialShape: e, app: { currentPageId: t } } = this; return { id: this.commandId, before: { document: { pages: { [t]: { shapes: { [e.id]: e } } } } }, after: { document: { pages: { [t]: { shapes: { [e.id]: ZA.onSessionComplete(this.app.getShape(this.initialShape.id)) } } } } } } })); let { originPoint: i } = e; this.topLeft = [...i], this.handleId = n, this.initialShape = this.app.getShape(t), this.commandId = r } }, rotate: class extends tP { constructor(e) { super(e), kE(this, "type", "rotate"), kE(this, "status", "transforming"), kE(this, "performanceMode"), kE(this, "delta", [0, 0]), kE(this, "commonBoundsCenter"), kE(this, "initialAngle"), kE(this, "initialShapes"), kE(this, "changes", {}), kE(this, "start", (() => { })), kE(this, "update", (() => { let { commonBoundsCenter: e, initialShapes: t, app: { currentPageId: n, currentPoint: r, shiftKey: i } } = this, o = {}, a = R.angle(e, r) - this.initialAngle; return i && (a = Zt.snapAngleToSegments(a, 24)), t.forEach((({ center: t, shape: n }) => { let { rotation: r = 0 } = n, s = 0; i && (s = Zt.snapAngleToSegments(r, 24) - r); let l = ZA.getRotatedShapeMutation(n, t, e, i ? a + s : a); l && (o[n.id] = l) })), this.changes = o, { document: { pages: { [n]: { shapes: o } } } } })), kE(this, "cancel", (() => { let { initialShapes: e, app: { currentPageId: t } } = this, n = {}; return e.forEach((({ shape: e }) => n[e.id] = e)), { document: { pages: { [t]: { shapes: n } } } } })), kE(this, "complete", (() => { let { initialShapes: e, app: { currentPageId: t } } = this, n = {}, r = this.changes; return e.forEach((({ shape: { id: e, point: t, rotation: r, handles: i } }) => { n[e] = { point: t, rotation: r, handles: i } })), { id: "rotate", before: { document: { pages: { [t]: { shapes: n } } } }, after: { document: { pages: { [t]: { shapes: r } } } } } })); let { app: { currentPageId: t, pageState: n, originPoint: r } } = this, i = ZA.getSelectedBranchSnapshot(e.state, t).filter((e => !e.isLocked)); if (0 === i.length) throw Error("No selected shapes!"); if (e.rotationInfo.selectedIds === n.selectedIds) { if (void 0 === e.rotationInfo.center) throw Error("We should have a center for rotation!"); this.commonBoundsCenter = e.rotationInfo.center } else this.commonBoundsCenter = Zt.getBoundsCenter(Zt.getCommonBounds(i.map(ZA.getBounds))), e.rotationInfo.selectedIds = n.selectedIds, e.rotationInfo.center = this.commonBoundsCenter; this.initialShapes = i.filter((e => void 0 === e.children)).map((e => ({ shape: e, center: this.app.getShapeUtil(e).getCenter(e) }))), this.initialAngle = R.angle(this.commonBoundsCenter, r) } }, transform: class extends tP { constructor(e, t = Kt.BottomRight, n = !1) { super(e), this.transformType = t, this.isCreate = n, kE(this, "type", "transform"), kE(this, "performanceMode"), kE(this, "status", "transforming"), kE(this, "scaleX", 1), kE(this, "scaleY", 1), kE(this, "initialShapes"), kE(this, "initialShapeIds"), kE(this, "initialSelectedIds"), kE(this, "shapeBounds"), kE(this, "hasUnlockedShapes"), kE(this, "isAllAspectRatioLocked"), kE(this, "initialCommonBounds"), kE(this, "snapInfo", { state: "empty" }), kE(this, "prevPoint", [0, 0]), kE(this, "speed", 1), kE(this, "start", (() => { this.snapInfo = { state: "ready", bounds: this.app.shapes.filter((e => !this.initialShapeIds.includes(e.id))).map((e => Zt.getBoundsWithCenter(ZA.getRotatedBounds(e)))) } })), kE(this, "update", (() => { let { transformType: e, shapeBounds: t, initialCommonBounds: n, isAllAspectRatioLocked: r, app: { currentPageId: i, pageState: { camera: o }, viewport: a, currentPoint: s, previousPoint: l, originPoint: c, shiftKey: u, altKey: d, metaKey: p, currentGrid: h, settings: { isSnapping: f, showGrid: m } } } = this, g = {}, v = d ? R.mul(R.sub(s, c), 2) : R.sub(s, c), y = Zt.getTransformedBoundingBox(n, e, v, 0, u || r); d && (y = EE(EE({}, y), Zt.centerBounds(y, Zt.getBoundsCenter(n)))), m && (y = EE(EE({}, y), Zt.snapBoundsToGrid(y, h))); let b = R.dist(s, l) - this.speed; this.speed = this.speed + b * (b > 1 ? .5 : .15); let w = []; if ((f && !p || !f && p) && this.speed * o.zoom < 10 && "ready" === this.snapInfo.state) { let t = Zt.getSnapPoints(Zt.getBoundsWithCenter(y), this.snapInfo.bounds.filter((e => Zt.boundsContain(a, e) || Zt.boundsCollide(a, e))), 5 / o.zoom); t && (w = t.snapLines, y = Zt.getTransformedBoundingBox(n, e, R.sub(v, t.offset), 0, u || r)) } return this.scaleX = y.scaleX, this.scaleY = y.scaleY, t.forEach((({ initialShape: e, initialShapeBounds: t, transformOrigin: r }) => { let i = Zt.getRelativeTransformedBoundingBox(y, n, t, this.scaleX < 0, this.scaleY < 0); m && (i = Zt.snapBoundsToGrid(i, h)); let o = ZA.transform(this.app.getShape(e.id), i, { type: this.transformType, initialShape: e, scaleX: this.scaleX, scaleY: this.scaleY, transformOrigin: r }); g[e.id] = o })), { appState: { snapLines: w }, document: { pages: { [i]: { shapes: g } } } } })), kE(this, "cancel", (() => { let { shapeBounds: e, app: { currentPageId: t } } = this, n = {}; return this.isCreate ? e.forEach((e => n[e.initialShape.id] = void 0)) : e.forEach((e => n[e.initialShape.id] = e.initialShape)), { appState: { snapLines: [] }, document: { pages: { [t]: { shapes: n } }, pageStates: { [t]: { selectedIds: this.isCreate ? [] : e.map((e => e.initialShape.id)) } } } } })), kE(this, "complete", (() => { let { isCreate: e, shapeBounds: t, hasUnlockedShapes: n, app: { currentPageId: r } } = this; if (!n) return; if (this.isCreate && R.dist(this.app.originPoint, this.app.currentPoint) < 2) return this.cancel(); let i, o, a = {}, s = {}; return e ? (i = [], o = [], t.forEach((({ initialShape: e }) => { a[e.id] = void 0, s[e.id] = this.app.getShape(e.id) }))) : (i = this.initialSelectedIds, o = this.initialSelectedIds, t.forEach((({ initialShape: e }) => { a[e.id] = e, s[e.id] = this.app.getShape(e.id) }))), { id: "transform", before: { appState: { snapLines: [] }, document: { pages: { [r]: { shapes: a } }, pageStates: { [r]: { selectedIds: i, hoveredId: void 0, editingId: void 0 } } } }, after: { appState: { snapLines: [] }, document: { pages: { [r]: { shapes: s } }, pageStates: { [r]: { selectedIds: o, hoveredId: void 0, editingId: void 0 } } } } } })), this.initialSelectedIds = [...this.app.selectedIds], this.app.rotationInfo.selectedIds = [...this.initialSelectedIds], this.initialShapes = ZA.getSelectedBranchSnapshot(this.app.state, this.app.currentPageId).filter((e => !e.isLocked)), this.initialShapeIds = this.initialShapes.map((e => e.id)), this.hasUnlockedShapes = this.initialShapes.length > 0, this.isAllAspectRatioLocked = this.initialShapes.every((e => e.isAspectRatioLocked || ZA.getShapeUtil(e).isAspectRatioLocked)); let r = Object.fromEntries(this.initialShapes.map((e => [e.id, ZA.getBounds(e)]))), i = Object.values(r); this.initialCommonBounds = Zt.getCommonBounds(i); let o = Zt.getBoundsFromPoints(i.map(Zt.getBoundsCenter)); this.shapeBounds = this.initialShapes.map((e => { let t = r[e.id], n = Zt.getBoundsCenter(t); return { initialShape: e, initialShapeBounds: t, transformOrigin: [(n[0] - o.minX) / o.width, (n[1] - o.minY) / o.height] } })) } }, transformSingle: class extends tP { constructor(e, t, n, r = !1) { super(e), kE(this, "type", "transformSingle"), kE(this, "status", "transforming"), kE(this, "performanceMode"), kE(this, "transformType"), kE(this, "scaleX", 1), kE(this, "scaleY", 1), kE(this, "isCreate"), kE(this, "initialShape"), kE(this, "initialShapeBounds"), kE(this, "initialCommonBounds"), kE(this, "snapInfo", { state: "empty" }), kE(this, "prevPoint", [0, 0]), kE(this, "speed", 1), kE(this, "start", (() => { this.snapInfo = { state: "ready", bounds: this.app.shapes.filter((e => e.id !== this.initialShape.id)).map((e => Zt.getBoundsWithCenter(ZA.getRotatedBounds(e)))) } })), kE(this, "update", (() => { let { transformType: e, initialShape: t, initialShapeBounds: n, app: { settings: { isSnapping: r, showGrid: i }, currentPageId: o, pageState: { camera: a }, viewport: s, currentPoint: l, previousPoint: c, originPoint: u, currentGrid: d, shiftKey: p, altKey: h, metaKey: f } } = this; if (t.isLocked) return; let m = {}, g = h ? R.mul(R.sub(l, u), 2) : R.sub(l, u), v = this.app.getShape(t.id), y = ZA.getShapeUtil(v), b = Zt.getTransformedBoundingBox(n, e, g, v.rotation, p || v.isAspectRatioLocked || y.isAspectRatioLocked); h && (b = EE(EE({}, b), Zt.centerBounds(b, Zt.getBoundsCenter(n)))), i && (b = EE(EE({}, b), Zt.snapBoundsToGrid(b, d))); let w = R.dist(l, c) - this.speed; this.speed = this.speed + w * (w > 1 ? .5 : .15); let E = []; if ((r && !f || !r && f) && !t.rotation && this.speed * a.zoom < 10 && "ready" === this.snapInfo.state) { let t = Zt.getSnapPoints(Zt.getBoundsWithCenter(b), this.snapInfo.bounds.filter((e => Zt.boundsContain(s, e) || Zt.boundsCollide(s, e))), 5 / a.zoom); t && (E = t.snapLines, b = Zt.getTransformedBoundingBox(n, e, R.sub(g, t.offset), v.rotation, p || v.isAspectRatioLocked || y.isAspectRatioLocked)) } let C = ZA.getShapeUtil(v).transformSingle(v, b, { initialShape: t, type: this.transformType, scaleX: b.scaleX, scaleY: b.scaleY, transformOrigin: [.5, .5] }); return C && (m[v.id] = C), i && C && C.point && (C.point = R.snap(C.point, d)), { appState: { snapLines: E }, document: { pages: { [o]: { shapes: m } } } } })), kE(this, "cancel", (() => { let { initialShape: e, app: { currentPageId: t } } = this, n = {}; return this.isCreate ? n[e.id] = void 0 : n[e.id] = e, { appState: { snapLines: [] }, document: { pages: { [t]: { shapes: n } }, pageStates: { [t]: { selectedIds: this.isCreate ? [] : [e.id] } } } } })), kE(this, "complete", (() => { let { initialShape: e, app: { currentPageId: t } } = this; if (e.isLocked) return; if (this.isCreate && R.dist(this.app.originPoint, this.app.currentPoint) < 2) return this.cancel(); let n = {}, r = {}; return n[e.id] = this.isCreate ? void 0 : e, r[e.id] = ZA.onSessionComplete(this.app.getShape(e.id)), { id: "transform_single", before: { appState: { snapLines: [] }, document: { pages: { [t]: { shapes: n } }, pageStates: { [t]: { selectedIds: this.isCreate ? [] : [e.id], editingId: void 0, hoveredId: void 0 } } } }, after: { appState: { snapLines: [] }, document: { pages: { [t]: { shapes: r } }, pageStates: { [t]: { selectedIds: [e.id], editingId: void 0, hoveredId: void 0 } } } } } })), this.isCreate = r, this.transformType = n; let i = this.app.getShape(t); this.initialShape = i, this.initialShapeBounds = ZA.getBounds(i), this.initialCommonBounds = ZA.getRotatedBounds(i), this.app.rotationInfo.selectedIds = [i.id] } }, translate: class extends tP { constructor(e, t = !1, n = !1) { super(e), kE(this, "performanceMode"), kE(this, "type", "translate"), kE(this, "status", "translating"), kE(this, "delta", [0, 0]), kE(this, "prev", [0, 0]), kE(this, "prevPoint", [0, 0]), kE(this, "speed", 1), kE(this, "cloneInfo", { state: "empty" }), kE(this, "snapInfo", { state: "empty" }), kE(this, "snapLines", []), kE(this, "isCloning", !1), kE(this, "isCreate"), kE(this, "link"), kE(this, "initialIds"), kE(this, "hasUnlockedShapes"), kE(this, "initialSelectedIds"), kE(this, "initialCommonBounds"), kE(this, "initialShapes"), kE(this, "initialParentChildren"), kE(this, "bindingsToDelete"), kE(this, "start", (() => { let { bindingsToDelete: e, initialIds: t, app: { currentPageId: n, page: r } } = this, i = [], o = []; if (Object.values(r.shapes).forEach((e => { let n = Zt.getBoundsWithCenter(ZA.getRotatedBounds(e)); i.push(n), t.has(e.id) || o.push(n) })), this.snapInfo = { state: "ready", bounds: i, others: o }, 0 === e.length) return; let a = {}, s = {}; return e.forEach((e => { a[e.id] = void 0; let t = this.app.getShape(e.fromId); s[e.fromId] = { handles: CE(EE({}, t.handles), { [e.handleId]: CE(EE({}, t.handles[e.handleId]), { bindingId: void 0 }) }) } })), { document: { pages: { [n]: { bindings: a, shapes: s } } } } })), kE(this, "update", (() => { let { initialParentChildren: e, initialShapes: t, initialCommonBounds: n, bindingsToDelete: r, app: { pageState: { camera: i }, settings: { isSnapping: o, showGrid: a }, currentPageId: s, viewport: l, selectedIds: c, currentPoint: u, previousPoint: d, originPoint: p, altKey: h, shiftKey: f, metaKey: m, currentGrid: g } } = this, v = {}, y = {}, b = {}, w = R.sub(u, p), E = !1; this.isCreate || (h && !this.isCloning ? (this.isCloning = !0, E = !0) : !h && this.isCloning && (this.isCloning = !1, E = !0)), f && (Math.abs(w[0]) < Math.abs(w[1]) ? w[0] = 0 : w[1] = 0); let C = R.dist(u, d) - this.speed; if (this.speed = this.speed + C * (C > 1 ? .5 : .15), this.snapLines = [], (o && !m || !o && m) && this.speed * i.zoom < 10 && "ready" === this.snapInfo.state) { let e = Zt.getSnapPoints(Zt.getBoundsWithCenter(a ? Zt.snapBoundsToGrid(Zt.translateBounds(n, w), g) : Zt.translateBounds(n, w)), (this.isCloning ? this.snapInfo.bounds : this.snapInfo.others).filter((e => Zt.boundsContain(l, e) || Zt.boundsCollide(l, e))), 5 / i.zoom); e && (this.snapLines = e.snapLines, w = R.sub(w, e.offset)) } if (this.prev = w, this.isCloning) if (E) { if ("empty" === this.cloneInfo.state && this.createCloneInfo(), "empty" === this.cloneInfo.state) throw Error; let { clones: n, clonedBindings: i } = this.cloneInfo; this.isCloning = !0, r.forEach((e => v[e.id] = e)), t.forEach((e => y[e.id] = { point: e.point })), n.forEach((t => { var n; if (y[t.id] = EE({}, t), t.parentId !== s && !c.includes(t.parentId)) { let r = (null == (n = y[t.parentId]) ? void 0 : n.children) || e[t.parentId]; r.includes(t.id) || (y[t.parentId] = CE(EE({}, y[t.parentId]), { children: [...r, t.id] })) } })); for (let e of i) v[e.id] = e; b.selectedIds = n.map((e => e.id)), n.forEach((e => { y[e.id] = CE(EE({}, e), { point: a ? R.snap(R.toFixed(R.add(e.point, w)), g) : R.toFixed(R.add(e.point, w)) }) })) } else { if ("empty" === this.cloneInfo.state) throw Error; let { clones: e } = this.cloneInfo; e.forEach((e => { y[e.id] = { point: a ? R.snap(R.toFixed(R.add(e.point, w)), g) : R.toFixed(R.add(e.point, w)) } })) } else if (E) { if ("empty" === this.cloneInfo.state) throw Error; let { clones: n, clonedBindings: i } = this.cloneInfo; this.isCloning = !1, r.forEach((e => v[e.id] = void 0)), n.forEach((t => { t.parentId !== s && (y[t.parentId] = CE(EE({}, y[t.parentId]), { children: e[t.parentId] })) })), n.forEach((e => y[e.id] = void 0)), t.forEach((e => { y[e.id] = { point: a ? R.snap(R.toFixed(R.add(e.point, w)), g) : R.toFixed(R.add(e.point, w)) } })); for (let e of i) v[e.id] = void 0; b.selectedIds = t.map((e => e.id)) } else t.forEach((e => { y[e.id] = { point: a ? R.snap(R.toFixed(R.add(e.point, w)), g) : R.toFixed(R.add(e.point, w)) } })); return { appState: { snapLines: this.snapLines }, document: { pages: { [s]: { shapes: y, bindings: v } }, pageStates: { [s]: b } } } })), kE(this, "cancel", (() => { let { initialShapes: e, initialSelectedIds: t, bindingsToDelete: n, app: { currentPageId: r } } = this, i = {}, o = {}, a = { editingId: void 0, hoveredId: void 0 }; if (this.isCreate ? (e.forEach((({ id: e }) => o[e] = void 0)), a.selectedIds = []) : (e.forEach((({ id: e, point: t, handles: n }) => o[e] = CE(EE({}, o[e]), n ? { point: t, handles: n } : { point: t }))), a.selectedIds = t, n.forEach((e => { i[e.id] = e }))), "ready" === this.cloneInfo.state) { let { clones: e, clonedBindings: t } = this.cloneInfo; e.forEach((e => o[e.id] = void 0)), t.forEach((e => i[e.id] = void 0)) } return { appState: { snapLines: [] }, document: { pages: { [r]: { shapes: o, bindings: i } }, pageStates: { [r]: a } } } })), kE(this, "complete", (() => { let { initialShapes: e, initialParentChildren: t, bindingsToDelete: n, app: { currentPageId: r } } = this, i = {}, o = {}, a = {}, s = {}; if (this.isCloning) { if ("empty" === this.cloneInfo.state && this.createCloneInfo(), "ready" !== this.cloneInfo.state) throw Error; let { clones: e, clonedBindings: n } = this.cloneInfo; e.forEach((e => { o[e.id] = void 0, s[e.id] = this.app.getShape(e.id), e.parentId !== r && (o[e.parentId] = CE(EE({}, o[e.parentId]), { children: t[e.parentId] }), s[e.parentId] = CE(EE({}, s[e.parentId]), { children: this.app.getShape(e.parentId).children })) })), n.forEach((e => { i[e.id] = void 0, a[e.id] = this.app.getBinding(e.id) })) } else e.forEach((e => { o[e.id] = this.isCreate ? void 0 : CE(EE({}, o[e.id]), { point: e.point }), s[e.id] = EE(EE({}, s[e.id]), this.isCreate ? this.app.getShape(e.id) : { point: this.app.getShape(e.id).point }) })); return n.forEach((e => { var t, n, r, a, l; i[e.id] = e, o[e.fromId] = CE(EE({}, o[e.fromId]), { id: e.fromId, handles: CE(EE({}, null == (t = o[e.fromId]) ? void 0 : t.handles), { [e.handleId]: CE(EE({}, null == (r = null == (n = o[e.fromId]) ? void 0 : n.handles) ? void 0 : r[e.handleId]), { bindingId: e.id }) }) }), s[e.fromId] = CE(EE({}, s[e.fromId]), { id: e.fromId, handles: CE(EE({}, s[e.fromId].handles), { [e.handleId]: CE(EE({}, null == (l = null == (a = s[e.fromId]) ? void 0 : a.handles) ? void 0 : l[e.handleId]), { bindingId: void 0 }) }) }) })), n.forEach((e => a[e.id] = void 0)), { id: "translate", before: { appState: { snapLines: [] }, document: { pages: { [r]: { shapes: o, bindings: i } }, pageStates: { [r]: { selectedIds: this.isCreate ? [] : [...this.initialSelectedIds] } } } }, after: { appState: { snapLines: [] }, document: { pages: { [r]: { shapes: s, bindings: a } }, pageStates: { [r]: { selectedIds: [...this.app.selectedIds] } } } } } })), kE(this, "createCloneInfo", (() => { let { initialShapes: e, initialParentChildren: t, app: { selectedIds: n, currentPageId: r, page: i } } = this, o = {}, a = {}, s = [], l = []; e.forEach((e => { let n = Zt.uniqueId(); t[n] = t[e.id], o[e.id] = n; let i = CE(EE({}, Zt.deepClone(e)), { id: n, parentId: e.parentId, childIndex: ZA.getChildIndexAbove(this.app.state, e.id, r) }); if ("video" === i.type) { let t = document.getElementById(e.id + "_video"); t && (i.currentTime = (t.currentTime + 16) % t.duration) } l.push(i) })), l.forEach((e => { void 0 !== e.children && (e.children = e.children.map((e => o[e]))) })), l.forEach((e => { n.includes(e.parentId) && (e.parentId = o[e.parentId]) })); let c = new Set(Object.keys(o)); Object.values(i.bindings).filter((e => c.has(e.fromId) || c.has(e.toId))).forEach((e => { if (c.has(e.fromId) && c.has(e.toId)) { let t = Zt.uniqueId(), n = CE(EE({}, Zt.deepClone(e)), { id: t, fromId: o[e.fromId] || e.fromId, toId: o[e.toId] || e.toId }); a[e.id] = t, s.push(n) } })), l.forEach((e => { if (e.handles && e.handles) for (let t in e.handles) { let n = e.handles[t]; n.bindingId = n.bindingId ? a[n.bindingId] : void 0 } })), l.forEach((e => { if (i.shapes[e.id]) throw Error("uh oh, we didn't clone correctly") })), this.cloneInfo = { state: "ready", clones: l, cloneMap: o, clonedBindings: s } })), this.isCreate = t, this.link = n; let { currentPageId: r, selectedIds: i, page: o } = this.app; this.initialSelectedIds = [...i]; let a = (n ? ZA.getLinkedShapeIds(this.app.state, r, n, !1) : i).map((e => this.app.getShape(e))).filter((e => !e.isLocked)), s = new Set(a.map((e => e.id))); this.hasUnlockedShapes = a.length > 0, this.initialShapes = Array.from(new Set(a.filter((e => !s.has(e.parentId))).flatMap((e => e.children ? [e, ...e.children.map((e => this.app.getShape(e)))] : [e]))).values()), this.initialIds = new Set(this.initialShapes.map((e => e.id))), this.bindingsToDelete = [], Object.values(o.bindings).filter((e => this.initialIds.has(e.fromId) || this.initialIds.has(e.toId))).forEach((e => { this.initialIds.has(e.fromId) && (this.initialIds.has(e.toId) || this.bindingsToDelete.push(e)) })), this.initialParentChildren = {}, this.initialShapes.map((e => e.parentId)).filter((e => e !== o.id)).forEach((e => { this.initialParentChildren[e] = this.app.getShape(e).children })), this.initialCommonBounds = Zt.getCommonBounds(this.initialShapes.map(ZA.getRotatedBounds)), this.app.rotationInfo.selectedIds = [...this.app.selectedIds] } }, grid: class extends tP { constructor(e, t) { var n; super(e), kE(this, "type", "grid"), kE(this, "performanceMode"), kE(this, "status", "translating"), kE(this, "shape"), kE(this, "bounds"), kE(this, "initialSelectedIds"), kE(this, "initialSiblings"), kE(this, "grid", {}), kE(this, "columns", 1), kE(this, "rows", 1), kE(this, "isCopying", !1), kE(this, "start", (() => { })), kE(this, "update", (() => { let { currentPageId: e, altKey: t, shiftKey: n, currentPoint: r } = this.app, i = {}, o = Zt.getBoundsCenter(this.bounds), a = R.sub(r, o); n && (Math.abs(a[0]) < Math.abs(a[1]) ? a[0] = 0 : a[1] = 0); let s = this.bounds.width + 32, l = this.bounds.height + 32, c = Math.ceil(a[0] / s), u = Math.ceil(a[1] / l), d = Math.min(c, 0), p = Math.min(u, 0), h = Math.max(c, 1), f = Math.max(u, 1), m = new Set, g = t; g !== this.isCopying && (Object.values(this.grid).filter((e => e !== this.shape.id)).forEach((e => i[e] = void 0)), this.grid = { "0_0": this.shape.id }, this.isCopying = g); for (let e = d; e < h; e++)for (let t = p; t < f; t++) { let n = `${e}_${t}`; if (m.add(n), this.grid[n] || 0 === e && 0 === t) continue; let r = this.getClone(R.add(this.shape.point, [e * s, t * l]), g); i[r.id] = r, this.grid[n] = r.id } if (Object.entries(this.grid).forEach((([e, t]) => { m.has(e) || (i[t] = void 0, delete this.grid[e]) })), 0 !== Object.values(i).length) return this.initialSiblings && (i[this.shape.parentId] = { children: [...this.initialSiblings, ...Object.values(this.grid)] }), { document: { pages: { [e]: { shapes: i } }, pageStates: { [e]: {} } } } })), kE(this, "cancel", (() => { let { currentPageId: e } = this.app, t = {}; return Object.values(this.grid).forEach((e => { t[e] = void 0 })), t[this.shape.id] = CE(EE({}, t[this.shape.id]), { point: this.shape.point }), this.initialSiblings && (t[this.shape.parentId] = { children: [...this.initialSiblings, this.shape.id] }), { document: { pages: { [e]: { shapes: t } }, pageStates: { [e]: { selectedIds: [this.shape.id] } } } } })), kE(this, "complete", (() => { let { currentPageId: e } = this.app, t = {}, n = {}, r = []; if (Object.values(this.grid).forEach((e => { t[e] = void 0, n[e] = this.app.getShape(e), r.push(e) })), t[this.shape.id] = this.shape, this.initialSiblings && (t[this.shape.parentId] = { children: [...this.initialSiblings, this.shape.id] }, n[this.shape.parentId] = { children: [...this.initialSiblings, ...Object.values(this.grid)] }), 1 !== r.length) return { id: "grid", before: { document: { pages: { [e]: { shapes: t } }, pageStates: { [e]: { selectedIds: [], hoveredId: void 0 } } } }, after: { document: { pages: { [e]: { shapes: n } }, pageStates: { [e]: { selectedIds: r, hoveredId: void 0 } } } } } })), kE(this, "getClone", ((e, t) => { let n = CE(EE({}, this.shape), { id: Zt.uniqueId(), point: e }); return t || "sticky" === n.type && (n.text = ""), n })), this.shape = this.app.getShape(t), this.grid["0_0"] = this.shape.id, this.bounds = this.app.getShapeBounds(t), this.initialSelectedIds = [...this.app.selectedIds], this.shape.parentId !== this.app.currentPageId && (this.initialSiblings = null == (n = this.app.getShape(this.shape.parentId).children) ? void 0 : n.filter((e => e !== this.shape.id))) } }, edit: class extends tP { constructor(e, t, n) { super(e), kE(this, "type", "edit"), kE(this, "performanceMode"), kE(this, "initialShape"), kE(this, "initialSelectedIds"), kE(this, "currentPageId"), kE(this, "isCreating"), kE(this, "start", (() => { })), kE(this, "update", (() => { })), kE(this, "cancel", (() => ({ document: { pages: { [this.currentPageId]: { shapes: { [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape } } }, pageStates: { [this.currentPageId]: { selectedIds: this.isCreating ? [] : this.initialSelectedIds, editingId: void 0 } } } }))), kE(this, "complete", (() => { let e = this.app.getShape(this.initialShape.id); return { id: "edit", before: { document: { pages: { [this.currentPageId]: { shapes: { [this.initialShape.id]: this.isCreating ? void 0 : this.initialShape } } }, pageStates: { [this.currentPageId]: { selectedIds: this.isCreating ? [] : this.initialSelectedIds, editingId: void 0 } } } }, after: { document: { pages: { [this.currentPageId]: { shapes: { [this.initialShape.id]: e } } }, pageStates: { [this.currentPageId]: { selectedIds: [e.id], editingId: void 0 } } } } } })), this.initialShape = e.getShape(t, e.currentPageId), this.currentPageId = e.currentPageId, this.isCreating = n, this.initialSelectedIds = [...e.selectedIds] } } }, rP = class extends WE { constructor(e) { super(), this.app = e, kE(this, "type", "select"), kE(this, "previous"), kE(this, "status", "idle"), kE(this, "setStatus", (e => { this.status = e, this.app.setStatus(this.status) })), kE(this, "onEnter", (() => { this.setStatus("idle") })), kE(this, "onExit", (() => { this.setStatus("idle") })), kE(this, "onCancel", (() => { "idle" === this.status ? this.app.selectTool("select") : this.setStatus("idle"), this.app.cancelSession() })), kE(this, "getNextChildIndex", (() => { let { shapes: e, appState: { currentPageId: t } } = this.app; return 0 === e.length ? 1 : e.filter((e => e.parentId === t)).sort(((e, t) => t.childIndex - e.childIndex))[0].childIndex + 1 })), kE(this, "onPinchStart", (() => { this.app.cancelSession(), this.setStatus("pinching") })), kE(this, "onPinchEnd", (() => { Zt.isMobileSafari() && this.app.undoSelect(), this.setStatus("idle") })), kE(this, "onPinch", ((e, t) => { var n; "pinching" === this.status && (isNaN(e.delta[0]) || isNaN(e.delta[1]) || (this.app.pinchZoom(e.point, e.delta, e.delta[2]), null == (n = this.onPointerMove) || n.call(this, e, t))) })), kE(this, "onKeyDown", (e => { "Escape" !== e ? "Meta" !== e && "Control" !== e && "Alt" !== e || this.app.updateSession() : this.onCancel() })), kE(this, "onKeyUp", (e => { "Meta" !== e && "Control" !== e && "Alt" !== e || this.app.updateSession() })), kE(this, "onPointerMove", (() => { "creating" === this.status && this.app.updateSession() })), kE(this, "onPointerUp", (() => { if ("creating" === this.status) { this.app.completeSession(); let { isToolLocked: e } = this.app.appState; e || this.app.selectTool("select") } this.setStatus("idle") })) } }, iP = class extends rP { constructor() { super(...arguments), kE(this, "type", "arrow"), kE(this, "onPointerDown", (() => { if ("idle" !== this.status) return; let { currentPoint: e, currentGrid: t, settings: { showGrid: n }, appState: { currentPageId: r, currentStyle: i } } = this.app, o = this.getNextChildIndex(), a = Zt.uniqueId(), s = HA.create({ id: a, parentId: r, childIndex: o, point: n ? B.snap(e, t) : e, style: EE({}, i) }); this.app.patchCreate([s]), this.app.startSession("arrow", s.id, "end", !0), this.setStatus("creating") })) } }, oP = class extends rP { constructor() { super(...arguments), kE(this, "type", "draw"), kE(this, "lastShapeId"), kE(this, "onEnter", (() => { this.lastShapeId = void 0 })), kE(this, "onCancel", (() => { "idle" === this.status ? this.app.selectTool("select") : this.setStatus("idle"), this.app.cancelSession() })), kE(this, "onPointerDown", (e => { if ("idle" !== this.status || this.app.readOnly) return; let { currentPoint: t, appState: { currentPageId: n, currentStyle: r } } = this.app, i = this.lastShapeId && this.app.getShape(this.lastShapeId); if (e.shiftKey && i) this.app.startSession("draw", i.id), this.setStatus("extending"); else { let e = this.getNextChildIndex(), i = Zt.uniqueId(), o = zA.create({ id: i, parentId: n, childIndex: e, point: t, style: EE({}, r) }); this.lastShapeId = i, this.app.patchCreate([o]), this.app.startSession("draw", i), this.setStatus("creating") } })), kE(this, "onPointerMove", (() => { if (!this.app.readOnly) switch (this.status) { case "extending": case "creating": this.app.updateSession() } })), kE(this, "onPointerUp", (() => { this.app.completeSession(), this.setStatus("idle") })) } }, aP = class extends rP { constructor() { super(...arguments), kE(this, "type", "ellipse"), kE(this, "onPointerDown", (() => { if (this.app.readOnly || "idle" !== this.status) return; let { currentPoint: e, currentGrid: t, settings: { showGrid: n }, appState: { currentPageId: r, currentStyle: i } } = this.app, o = this.getNextChildIndex(), a = Zt.uniqueId(), s = FA.create({ id: a, parentId: r, childIndex: o, point: n ? B.snap(e, t) : e, style: EE({}, i) }); this.app.patchCreate([s]), this.app.startSession("transformSingle", s.id, Kt.BottomRight, !0), this.setStatus("creating") })) } }, sP = class extends rP { constructor() { super(...arguments), kE(this, "type", "erase"), kE(this, "status", "idle"), kE(this, "onPointerDown", (() => { this.app.readOnly || "idle" === this.status && this.setStatus("pointing") })), kE(this, "onPointerMove", (e => { if (!this.app.readOnly) switch (this.status) { case "pointing": B.dist(e.origin, e.point) > 3 && (this.app.startSession("erase"), this.app.updateSession(), this.setStatus("erasing")); break; case "erasing": this.app.updateSession() } })), kE(this, "onPointerUp", (() => { if (!this.app.readOnly) { switch (this.status) { case "pointing": { let e = this.app.shapes.filter((e => !e.isLocked)).filter((e => this.app.getShapeUtil(e).hitTestPoint(e, this.app.currentPoint))).flatMap((e => e.children ? [e.id, ...e.children] : e.id)); this.app.delete(e); break } case "erasing": this.app.completeSession() }this.setStatus("idle") } })), kE(this, "onCancel", (() => { "idle" === this.status ? this.previous ? this.app.selectTool(this.previous) : this.app.selectTool("select") : this.setStatus("idle"), this.app.cancelSession() })) } }, lP = class extends rP { constructor() { super(...arguments), kE(this, "type", "line"), kE(this, "onPointerDown", (() => { if (this.app.readOnly || "idle" !== this.status) return; let { currentPoint: e, currentGrid: t, settings: { showGrid: n }, appState: { currentPageId: r, currentStyle: i } } = this.app, o = this.getNextChildIndex(), a = Zt.uniqueId(), s = HA.create({ id: a, parentId: r, childIndex: o, point: n ? B.snap(e, t) : e, decorations: { start: void 0, end: void 0 }, style: EE({}, i) }); this.app.patchCreate([s]), this.app.startSession("arrow", s.id, "end", !0), this.setStatus("creating") })) } }, cP = class extends rP { constructor() { super(...arguments), kE(this, "type", "rectangle"), kE(this, "onPointerDown", (() => { if (this.app.readOnly || "idle" !== this.status) return; let { currentPoint: e, currentGrid: t, settings: { showGrid: n }, appState: { currentPageId: r, currentStyle: i } } = this.app, o = this.getNextChildIndex(), a = Zt.uniqueId(), s = LA.create({ id: a, parentId: r, childIndex: o, point: n ? B.snap(e, t) : e, style: EE({}, i) }); this.app.patchCreate([s]), this.app.startSession("transformSingle", s.id, Kt.BottomRight, !0), this.setStatus("creating") })) } }, uP = class extends rP { constructor() { super(...arguments), kE(this, "type", "select"), kE(this, "pointedId"), kE(this, "selectedGroupId"), kE(this, "pointedHandleId"), kE(this, "pointedBoundsHandle"), kE(this, "pointedLinkHandleId"), kE(this, "onEnter", (() => { this.setStatus("idle") })), kE(this, "onExit", (() => { this.setStatus("idle") })), kE(this, "clonePaint", (e => { if (0 === this.app.selectedIds.length) return; let t = this.app.selectedIds.map((e => this.app.getShape(e))), n = Zt.expandBounds(Zt.getCommonBounds(t.map(ZA.getBounds)), 16), r = Zt.getBoundsCenter(n), i = [n.width, n.height], o = [r[0] + i[0] * Math.floor((e[0] + i[0] / 2 - r[0]) / i[0]), r[1] + i[1] * Math.floor((e[1] + i[1] / 2 - r[1]) / i[1])], a = Zt.centerBounds(n, o); this.app.shapes.some((e => ZA.getShapeUtil(e).hitTestBounds(e, a))) || this.app.duplicate(this.app.selectedIds, o) })), kE(this, "getShapeClone", ((e, t) => { let n = this.app.getShape(e), r = ZA.getShapeUtil(n); if (r.canClone) { let e = r.getBounds(n), i = r.getCenter(n), o = { top: [e.minX, e.minY - (e.height + 32)], right: [e.maxX + 32, e.minY], bottom: [e.minX, e.maxY + 32], left: [e.minX - (e.width + 32), e.minY], topLeft: [e.minX - (e.width + 32), e.minY - (e.height + 32)], topRight: [e.maxX + 32, e.minY - (e.height + 32)], bottomLeft: [e.minX - (e.width + 32), e.maxY + 32], bottomRight: [e.maxX + 32, e.maxY + 32] }[t]; if (0 !== n.rotation) { let t = B.add(o, [e.width / 2, e.height / 2]), r = B.rotWith(t, i, n.rotation || 0); o = B.sub(r, [e.width / 2, e.height / 2]) } let a = Zt.uniqueId(), s = CE(EE({}, n), { id: a, point: o }); return "sticky" === s.type && (s.text = ""), s } })), kE(this, "onCancel", (() => { this.app.session ? this.app.cancelSession() : this.selectNone(), this.setStatus("idle") })), kE(this, "onKeyDown", ((e, t, n) => { switch (e) { case "Escape": this.onCancel(); break; case "Tab": if (this.app.readOnly) return; if (!this.app.pageState.editingId && "idle" === this.status && 1 === this.app.selectedIds.length) { let [e] = this.app.selectedIds, t = this.getShapeClone(e, "right"); t && (this.app.createShapes(t), this.setStatus("idle"), "sticky" === t.type && (this.app.select(t.id), this.app.setEditingId(t.id))) } break; case "Meta": case "Control": case "Alt": this.app.updateSession(); break; case "Enter": { if (this.app.readOnly) return; let { pageState: e } = this.app; 1 === e.selectedIds.length && !e.editingId && (this.app.setEditingId(e.selectedIds[0]), n.preventDefault()) } } })), kE(this, "onKeyUp", ((e, t) => { "clonePainting" !== this.status || t.altKey && t.shiftKey ? "Meta" !== e && "Control" !== e && "Alt" !== e || this.app.updateSession() : this.setStatus("idle") })), kE(this, "onPointerMove", (() => { let { originPoint: e, currentPoint: t } = this.app; if (this.app.readOnly && this.app.isPointing) this.app.session ? this.app.updateSession() : B.dist(e, t) > 3 && (this.app.startSession("brush"), this.setStatus("brushing")); else switch (this.status) { case "pointingBoundsHandle": if (!this.pointedBoundsHandle) throw Error("No pointed bounds handle"); if (B.dist(e, t) > 3) { if ("rotate" === this.pointedBoundsHandle) this.setStatus("rotating"), this.app.startSession("rotate"); else if ("center" === this.pointedBoundsHandle || "left" === this.pointedBoundsHandle || "right" === this.pointedBoundsHandle) this.setStatus("translating"), this.app.startSession("translate", !1, this.pointedBoundsHandle); else { this.setStatus("transforming"); let e = this.app.selectedIds.flatMap((e => ZA.getDocumentBranch(this.app.state, e, this.app.currentPageId))); 1 === e.length ? this.app.startSession("transformSingle", e[0], this.pointedBoundsHandle) : this.app.startSession("transform", this.pointedBoundsHandle) } this.app.updateSession() } break; case "pointingCanvas": B.dist(e, t) > 3 && (this.app.startSession("brush"), this.setStatus("brushing")); break; case "pointingClone": B.dist(e, t) > 3 && (this.setStatus("translatingClone"), this.app.startSession("translate"), this.app.updateSession()); break; case "pointingBounds": B.dist(e, t) > 3 && (this.setStatus("translating"), this.app.startSession("translate"), this.app.updateSession()); break; case "pointingHandle": if (!this.pointedHandleId) throw Error("No pointed handle"); if (B.dist(e, t) > 3) { this.setStatus("translatingHandle"); let e = this.app.getShape(this.app.selectedIds[0]); e && ("bend" === this.pointedHandleId ? (this.app.startSession("handle", e.id, this.pointedHandleId), this.app.updateSession()) : (this.app.startSession("arrow", e.id, this.pointedHandleId, !1), this.app.updateSession())) } break; case "clonePainting": this.clonePaint(t); break; default: if (this.app.session) { this.app.updateSession(); break } } })), kE(this, "onPointerDown", ((e, t) => { if ("canvas" === e.target && "idle" === this.status) { let { currentPoint: n } = this.app; if (e.spaceKey && 1 === t.buttons) return; if ("idle" === this.status && e.altKey && e.shiftKey) return this.setStatus("clonePainting"), void this.clonePaint(n); if (!e.shiftKey) { if (this.app.onShapeBlur(), e.altKey && this.app.selectedIds.length > 0) return void this.app.duplicate(this.app.selectedIds, n); this.selectNone() } this.setStatus("pointingCanvas") } })), kE(this, "onPointerUp", (e => { var t; if ("translatingClone" === this.status || "pointingClone" === this.status) return this.pointedId && (this.app.completeSession(), this.app.setEditingId(this.pointedId)), this.setStatus("idle"), void (this.pointedId = void 0); if ("pointingBounds" === this.status) if ("bounds" === e.target) this.selectNone(); else if (this.app.isSelected(e.target)) e.shiftKey ? this.pointedId !== e.target && this.deselect(e.target) : this.pointedId !== e.target && this.app.selectedIds.length > 1 && this.select(e.target); else if (this.pointedId === e.target) { if (this.app.getShape(e.target).isLocked) return; e.shiftKey ? this.pushSelect(e.target) : this.select(e.target) } this.setStatus("idle"), this.pointedBoundsHandle = void 0, this.pointedHandleId = void 0, this.pointedId = void 0, "edit" !== (null == (t = this.app.session) ? void 0 : t.type) && this.app.completeSession() })), kE(this, "onDoubleClickCanvas", (() => { this.app.readOnly })), kE(this, "onPointShape", ((e, t) => { if (e.spaceKey && 1 === t.buttons || this.app.getShape(e.target).isLocked) return; let { editingId: n, hoveredId: r } = this.app.pageState; if (n && e.target !== n && this.app.onShapeBlur(), ("idle" === this.status || "pointingBounds" === this.status) && e.metaKey && e.shiftKey && r) return this.pointedId = r, void (this.app.isSelected(r) ? this.deselect(r) : (this.pushSelect(r), this.setStatus("pointingBounds"))); if ("pointingBounds" !== this.status) { if ("idle" === this.status) { if (this.setStatus("pointingBounds"), e.metaKey) return e.shiftKey || this.selectNone(), this.app.startSession("brush"), void this.setStatus("brushing"); let t, { parentId: n } = this.app.getShape(e.target); n === this.app.currentPageId ? (t = e.target, this.selectedGroupId = void 0) : n === this.selectedGroupId ? t = e.target : (t = n, this.selectedGroupId = void 0), this.app.isSelected(t) || (this.pointedId = t, e.shiftKey ? this.pushSelect(t) : this.select(t)) } } else { let { parentId: t } = this.app.getShape(e.target); this.pointedId = t === this.app.currentPageId ? e.target : t } })), kE(this, "onDoubleClickShape", (e => { if (this.app.readOnly) return; let t = this.app.getShape(e.target); t.isLocked || (ZA.getShapeUtil(t.type).canEdit && (t.parentId === this.app.currentPageId || t.parentId === this.selectedGroupId) && this.app.setEditingId(e.target), t.parentId !== this.app.currentPageId && (this.selectedGroupId = t.parentId)), this.app.select(e.target) })), kE(this, "onRightPointShape", (e => { this.app.isSelected(e.target) || this.app.select(e.target) })), kE(this, "onHoverShape", (e => { this.app.setHoveredId(e.target) })), kE(this, "onUnhoverShape", (e => { let { currentPageId: t } = this.app; requestAnimationFrame((() => { t === this.app.currentPageId && this.app.pageState.hoveredId === e.target && this.app.setHoveredId(void 0) })) })), kE(this, "onPointBounds", (e => { if (e.metaKey) return e.shiftKey || this.selectNone(), this.app.startSession("brush"), void this.setStatus("brushing"); this.setStatus("pointingBounds") })), kE(this, "onRightPointBounds", ((e, t) => { t.stopPropagation() })), kE(this, "onReleaseBounds", (() => { ("translating" === this.status || "brushing" === this.status) && this.app.completeSession(), this.setStatus("idle") })), kE(this, "onPointBoundsHandle", (e => { this.pointedBoundsHandle = e.target, this.setStatus("pointingBoundsHandle") })), kE(this, "onDoubleClickBoundsHandle", (e => { switch (e.target) { case "center": case "left": case "right": this.app.select(...ZA.getLinkedShapeIds(this.app.state, this.app.currentPageId, e.target, e.shiftKey)); break; default: if (1 === this.app.selectedIds.length) { this.app.resetBounds(this.app.selectedIds); let e = this.app.getShape(this.app.selectedIds[0]); "label" in e && this.app.setEditingId(e.id) } } })), kE(this, "onReleaseBoundsHandle", (() => { this.setStatus("idle") })), kE(this, "onPointHandle", (e => { this.pointedHandleId = e.target, this.setStatus("pointingHandle") })), kE(this, "onDoubleClickHandle", (e => { if ("bend" !== e.target) this.app.toggleDecoration(e.target); else { let { selectedIds: e } = this.app; if (1 !== e.length) return; let t = this.app.getShape(e[0]); ZA.getShapeUtil(t.type).canEdit && (t.parentId === this.app.currentPageId || t.parentId === this.selectedGroupId) && this.app.setEditingId(t.id) } })), kE(this, "onReleaseHandle", (() => { this.setStatus("idle") })), kE(this, "onShapeClone", (e => { let t = this.app.selectedIds[0], n = this.getShapeClone(t, e.target); "left" === e.target || "right" === e.target || "top" === e.target || "bottom" === e.target ? n && (this.app.createShapes(n), this.pointedId = n.id, this.setStatus("pointingClone")) : (this.setStatus("gridCloning"), this.app.startSession("grid", t)) })) } deselect(e) { this.app.select(...this.app.selectedIds.filter((t => t !== e))) } select(e) { this.app.select(e) } pushSelect(e) { let t = this.app.getShape(e); this.app.select(...this.app.selectedIds.filter((e => e !== t.parentId)), e) } selectNone() { this.app.selectNone() } }, dP = class extends rP { constructor() { super(...arguments), kE(this, "type", "sticky"), kE(this, "shapeId"), kE(this, "onPointerDown", (() => { if (!this.app.readOnly) { if ("creating" === this.status) return this.setStatus("idle"), void (this.app.appState.isToolLocked || this.app.selectTool("select")); if ("idle" === this.status) { let { currentPoint: e, currentGrid: t, settings: { showGrid: n }, appState: { currentPageId: r, currentStyle: i } } = this.app, o = this.getNextChildIndex(), a = Zt.uniqueId(); this.shapeId = a; let s = UA.create({ id: a, parentId: r, childIndex: o, point: n ? B.snap(e, t) : e, style: EE({}, i) }), l = UA.getBounds(s); s.point = B.sub(s.point, [l.width / 2, l.height / 2]), this.app.patchCreate([s]), this.app.startSession("translate"), this.setStatus("creating") } } })), kE(this, "onPointerUp", (() => { this.app.readOnly || "creating" === this.status && (this.setStatus("idle"), this.app.completeSession(), this.app.selectTool("select"), this.app.setEditingId(this.shapeId)) })) } }, pP = class extends rP { constructor() { super(...arguments), kE(this, "type", "text"), kE(this, "stopEditingShape", (() => { this.setStatus("idle"), this.app.appState.isToolLocked || this.app.selectTool("select") })), kE(this, "onKeyUp", (() => { })), kE(this, "onKeyDown", (() => { })), kE(this, "onPointerDown", (() => { if ("creating" !== this.status) { if ("idle" === this.status) { let { currentPoint: e, currentGrid: t, settings: { showGrid: n } } = this.app; return this.app.createTextShapeAtPoint(n ? B.snap(e, t) : e, void 0, !0), void this.setStatus("creating") } } else this.stopEditingShape() })), kE(this, "onPointerUp", (() => { })), kE(this, "onPointShape", (e => { if (this.app.readOnly) return; let t = this.app.getShape(e.target); "text" === t.type && (this.setStatus("idle"), this.app.setEditingId(t.id)) })), kE(this, "onShapeBlur", (() => { this.app.readOnly || this.stopEditingShape() })) } }, hP = class extends rP { constructor() { super(...arguments), kE(this, "type", "triangle"), kE(this, "onPointerDown", (() => { if (this.app.readOnly || "idle" !== this.status) return; let { currentPoint: e, currentGrid: t, settings: { showGrid: n }, appState: { currentPageId: r, currentStyle: i } } = this.app, o = this.getNextChildIndex(), a = Zt.uniqueId(), s = OA.create({ id: a, parentId: r, childIndex: o, point: n ? B.snap(e, t) : e, style: EE({}, i) }); this.app.patchCreate([s]), this.app.startSession("transformSingle", s.id, Kt.BottomRight, !0), this.setStatus("creating") })) } }, fP = Zt.uniqueId(), mP = class extends BI { constructor(e, t = {}) { super(mP.defaultState, e, mP.version, ((e, t, n) => KI(CE(EE({}, t), { document: CE(EE(EE({}, t.document), e.document), { version: n }) }), mP.version))), kE(this, "callbacks", {}), kE(this, "tools", { select: new uP(this), erase: new sP(this), text: new pP(this), draw: new oP(this), ellipse: new aP(this), rectangle: new cP(this), triangle: new hP(this), line: new lP(this), arrow: new iP(this), sticky: new dP(this) }), kE(this, "currentTool", this.tools.select), kE(this, "session"), kE(this, "readOnly", !1), kE(this, "isDirty", !1), kE(this, "isCreating", !1), kE(this, "originPoint", [0, 0]), kE(this, "currentPoint", [0, 0]), kE(this, "previousPoint", [0, 0]), kE(this, "shiftKey", !1), kE(this, "altKey", !1), kE(this, "metaKey", !1), kE(this, "ctrlKey", !1), kE(this, "spaceKey", !1), kE(this, "isPointing", !1), kE(this, "isForcePanning", !1), kE(this, "isErasingWithPen", !1), kE(this, "isPastePrevented", !1), kE(this, "editingStartTime", -1), kE(this, "fileSystemHandle", null), kE(this, "viewport", Zt.getBoundsFromPoints([[0, 0], [100, 100]])), kE(this, "rendererBounds", Zt.getBoundsFromPoints([[0, 0], [100, 100]])), kE(this, "selectHistory", { stack: [[]], pointer: 0 }), kE(this, "clipboard"), kE(this, "rotationInfo", { selectedIds: [], center: [0, 0] }), kE(this, "migrate", (e => KI(e, mP.version))), kE(this, "onReady", (() => { var e, t; this.loadDocument(this.document), GI().then((e => { this.fileSystemHandle = e })); try { this.patchState(CE(EE({}, KI(this.state, mP.version)), { appState: { status: "idle" } })) } catch (e) { console.error("The data appears to be corrupted. Resetting!", e), localStorage.setItem(this.document.id + "_corrupted", JSON.stringify(this.document)), this.patchState(CE(EE({}, mP.defaultState), { appState: CE(EE({}, mP.defaultState.appState), { status: "idle" }) })) } null == (t = (e = this.callbacks).onMount) || t.call(e, this) })), kE(this, "cleanup", ((e, t) => { var n; let r = EE({}, e); r.document !== t.document && Object.entries(r.document.pages).forEach((([e, n]) => { if (void 0 === n) return delete r.document.pages[e], void delete r.document.pageStates[e]; let i = t.document.pages[e], o = {}; if (!i || n.shapes !== i.shapes || n.bindings !== i.bindings) { n.shapes = EE({}, n.shapes), n.bindings = EE({}, n.bindings); let t = new Set; Object.entries(n.shapes).forEach((([a, s]) => { var l; let c; s ? c = s.parentId : (c = null == (l = null == i ? void 0 : i.shapes[a]) ? void 0 : l.parentId, delete n.shapes[a]), n.id === r.appState.currentPageId && (null == i ? void 0 : i.shapes[a]) !== s && (o[a] = s), c && c !== e && void 0 !== n.shapes[c] && t.add(n.shapes[c]) })), Object.keys(n.bindings).forEach((e => { n.bindings[e] || delete n.bindings[e] })), r.document.pages[e] = n; let a = ZA.getRelatedBindings(r, Object.keys(o), e), s = new Set; a.forEach((t => { if (!n.bindings[t.id]) return; let i = n.shapes[t.toId], o = n.shapes[t.fromId]; if (!i || !o) return void delete r.document.pages[e].bindings[t.id]; if (s.has(o)) return; let a = ZA.updateArrowBindings(n, o); if (s.add(o), a) { let e = EE(EE({}, o), a); n.shapes[o.id] = e } })), t.forEach((e => { if (!e) throw Error("no group!"); let t = e.children.filter((e => void 0 !== n.shapes[e])), r = Zt.getCommonBounds(t.map((e => n.shapes[e])).filter(Boolean).map((e => ZA.getRotatedBounds(e)))); n.shapes[e.id] = CE(EE({}, e), { point: [r.minX, r.minY], size: [r.width, r.height], children: t }) })) } let a = EE({}, r.document.pageStates[e]); a.brush || delete a.brush, a.hoveredId && !n.shapes[a.hoveredId] && delete a.hoveredId, a.bindingId && !n.bindings[a.bindingId] && (ZA.warn(`Could not find the binding of ${e}`), delete a.bindingId), a.editingId && !n.shapes[a.editingId] && (ZA.warn("Could not find the editing shape!"), delete a.editingId), r.document.pageStates[e] = a })), Object.keys(null != (n = r.document.assets) ? n : {}).forEach((e => { var t, n; (null == (t = r.document.assets) ? void 0 : t[e]) || null == (n = r.document.assets) || delete n[e] })); let i = r.appState.currentPageId, o = r.document.pageStates[i]; if (r.room && r.room !== t.room) { let e = CE(EE({}, r.room), { users: EE({}, r.room.users) }); t.room && Object.values(t.room.users).filter(Boolean).forEach((t => { void 0 === e.users[t.id] && delete e.users[t.id] })), r.room = e } return r.room && (r.room.users[r.room.userId] = CE(EE({}, r.room.users[r.room.userId]), { point: this.currentPoint, selectedIds: o.selectedIds })), this.readOnly && (r.document.pages = t.document.pages), r })), kE(this, "broadcastPatch", ((e, t) => { var n, r, i, o, a, s, l, c, u; let d = {}, p = {}, h = {}, f = null == (i = null == (r = null == (n = null == e ? void 0 : e.document) ? void 0 : n.pages) ? void 0 : r[this.currentPageId]) ? void 0 : i.shapes, m = null == (s = null == (a = null == (o = null == e ? void 0 : e.document) ? void 0 : o.pages) ? void 0 : a[this.currentPageId]) ? void 0 : s.bindings, g = null == (l = null == e ? void 0 : e.document) ? void 0 : l.assets; f && Object.keys(f).forEach((e => { d[e] = this.getShape(e, this.currentPageId) })), m && Object.keys(m).forEach((e => { p[e] = this.getBinding(e, this.currentPageId) })), g && Object.keys(g).forEach((e => { h[e] = this.document.assets[e] })), null == (u = (c = this.callbacks).onChangePage) || u.call(c, this, d, p, h, t) })), kE(this, "onPatch", ((e, t, n) => { var r, i, o, a, s, l; (this.callbacks.onChangePage && (null == (i = null == (r = null == t ? void 0 : t.document) ? void 0 : r.pages) ? void 0 : i[this.currentPageId]) || (null == (o = null == t ? void 0 : t.document) ? void 0 : o.assets)) && ((null == (a = null == t ? void 0 : t.document) ? void 0 : a.assets) || this.session && "brush" !== this.session.type && "erase" !== this.session.type && "draw" !== this.session.type) && this.broadcastPatch(t, !1), null == (l = (s = this.callbacks).onPatch) || l.call(s, this, t, n) })), kE(this, "onCommand", ((e, t, n) => { var r, i; this.clearSelectHistory(), this.isDirty = !0, null == (i = (r = this.callbacks).onCommand) || i.call(r, this, t, n) })), kE(this, "onReplace", (() => { this.clearSelectHistory(), this.isDirty = !1 })), kE(this, "onUndo", (() => { var e, t; this.rotationInfo.selectedIds = [...this.selectedIds], null == (t = (e = this.callbacks).onUndo) || t.call(e, this) })), kE(this, "onRedo", (() => { var e, t; this.rotationInfo.selectedIds = [...this.selectedIds], null == (t = (e = this.callbacks).onRedo) || t.call(e, this) })), kE(this, "onPersist", ((e, t) => { var n, r; null == (r = (n = this.callbacks).onPersist) || r.call(n, this), this.broadcastPatch(t, !0) })), kE(this, "prevSelectedIds", this.selectedIds), kE(this, "onStateDidChange", ((e, t) => { var n, r, i, o; null == (r = (n = this.callbacks).onChange) || r.call(n, this, t), this.room && this.selectedIds !== this.prevSelectedIds && (null == (o = (i = this.callbacks).onChangePresence) || o.call(i, this, CE(EE({}, this.room.users[this.room.userId]), { selectedIds: this.selectedIds, session: !!this.session })), this.prevSelectedIds = this.selectedIds) })), kE(this, "preventPaste", (() => { if (this.isPastePrevented) return; let e = e => e.stopImmediatePropagation(); document.addEventListener("paste", e, { capture: !0 }), window.addEventListener("pointerup", (() => { setTimeout((() => { document.removeEventListener("paste", e, { capture: !0 }), this.isPastePrevented = !1 }), 50) }), { once: !0 }), this.isPastePrevented = !0 })), kE(this, "justSent", !1), kE(this, "getReservedContent", ((e, t = this.currentPageId) => { let { bindings: n } = this.document.pages[t], r = {}, i = {}, o = Object.values(n), a = new Map(o.map((e => [e.toId, e]))), s = new Map(o.map((e => [e.fromId, e]))), l = [a, s], c = []; this.session && e.forEach((e => c.push(e))), this.pageState.editingId && c.push(this.pageState.editingId); let u = new Set(c), d = new Set; for (; c.length > 0;) { let e = c.pop(); if (!e) break; if (d.has(e)) continue; d.add(e); let n = this.getShape(e); r[e] = n, n.parentId !== t && c.push(n.parentId), n.children && c.push(...n.children), l.map((e => e.get(n.id))).filter(Boolean).forEach((e => { i[e.id] = e, c.push(e.toId, e.fromId) })) } return { reservedShapes: r, reservedBindings: i, strongReservedShapeIds: u } })), kE(this, "replacePageContent", ((e, t, n, r = this.currentPageId) => { if (this.justSent) return this.justSent = !1, this; let i = this.document.pages[this.currentPageId]; return Object.values(e).forEach((t => { t.parentId !== r && !i.shapes[t.parentId] && !e[t.parentId] && (console.warn("Added a shape without a parent on the page"), t.parentId = r) })), this.useStore.setState((i => { let { hoveredId: o, editingId: a, bindingId: s, selectedIds: l } = i.document.pageStates[r], c = [...l], u = a && i.document.pages[this.currentPageId].shapes[a]; u && c.push(u.id); let { reservedShapes: d, reservedBindings: p, strongReservedShapeIds: h } = this.getReservedContent(c, this.currentPageId); Object.values(d).filter((e => !("text" in e))).forEach((t => { let n = e[t.id]; if (n) { if ("arrow" !== t.type && !h.has(t.id)) return void (e[t.id] = n); "decorations" in n && "decorations" in t && (e[t.id] = CE(EE({}, t), { decorations: n.decorations })), t.style = n.style } })); let f = EE(EE({}, e), d); u && (f[u.id] = u); let m = EE(EE({}, t), p), g = EE({}, n), v = CE(EE({}, i), { document: CE(EE({}, i.document), { pages: { [r]: CE(EE({}, i.document.pages[r]), { shapes: f, bindings: m }) }, assets: g, pageStates: CE(EE({}, i.document.pageStates), { [r]: CE(EE({}, i.document.pageStates[r]), { selectedIds: l.filter((e => void 0 !== f[e])), hoveredId: o ? void 0 === f[o] ? void 0 : o : void 0, editingId: a, bindingId: s ? void 0 === m[s] ? void 0 : s : void 0 }) }) }) }), y = v.document.pages[r], b = ZA.getRelatedBindings(v, Object.keys(f), r), w = new Set; return b.forEach((e => { if (!y.bindings[e.id]) return; let t = y.shapes[e.fromId]; if (w.has(t)) return; let n = ZA.updateArrowBindings(y, t); if (w.add(t), n) { let e = EE(EE({}, t), n); y.shapes[t.id] = e } })), Object.values(f).forEach((e => { if ("group" !== e.type) return; let t = e.children.filter((e => void 0 !== y.shapes[e])), n = Zt.getCommonBounds(t.map((e => y.shapes[e])).filter(Boolean).map((e => ZA.getRotatedBounds(e)))); y.shapes[e.id] = CE(EE({}, e), { point: [n.minX, n.minY], size: [n.width, n.height], children: t }) })), this.state.document = v.document, v }), !0), this })), kE(this, "updateBounds", (e => { this.rendererBounds = e; let { point: t, zoom: n } = this.camera; this.updateViewport(t, n), !this.readOnly && this.session && this.session.update() })), kE(this, "updateViewport", ((e, t) => { let { width: n, height: r } = this.rendererBounds, [i, o] = R.sub(R.div([0, 0], t), e), [a, s] = R.sub(R.div([n, r], t), e); this.viewport = { minX: i, minY: o, maxX: a, maxY: s, width: a - i, height: s - o } })), kE(this, "setEditingId", ((e, t = !1) => { if (!this.readOnly) { if (e) this.startSession("edit", e, t); else { if (!this.pageState.editingId) return; this.completeSession() } this.editingStartTime = performance.now(), this.patchState({ document: { pageStates: { [this.currentPageId]: { editingId: e } } } }, "set_editing_id") } })), kE(this, "setHoveredId", (e => { this.patchState({ document: { pageStates: { [this.currentPageId]: { hoveredId: e } } } }, "set_hovered_id") })), kE(this, "setSetting", ((e, t) => { if (this.session) return this; let n = { settings: { [e]: "function" == typeof t ? t(this.settings[e]) : t } }; return this.patchState(n, `settings:${e}`), this.persist(n), this })), kE(this, "toggleFocusMode", (() => { if (this.session) return this; let e = { settings: { isFocusMode: !this.settings.isFocusMode } }; return this.patchState(e, "settings:toggled_focus_mode"), this.persist(e), this })), kE(this, "togglePenMode", (() => { if (this.session) return this; let e = { settings: { isPenMode: !this.settings.isPenMode } }; return this.patchState(e, "settings:toggled_pen_mode"), this.persist(e), this })), kE(this, "toggleDarkMode", (() => { if (this.session) return this; let e = { settings: { isDarkMode: !this.settings.isDarkMode } }; return this.patchState(e, "settings:toggled_dark_mode"), this.persist(e), this })), kE(this, "toggleZoomSnap", (() => { if (this.session) return this; let e = { settings: { isZoomSnap: !this.settings.isZoomSnap } }; return this.patchState(e, "settings:toggled_zoom_snap"), this.persist(e), this })), kE(this, "toggleDebugMode", (() => { if (this.session) return this; let e = { settings: { isDebugMode: !this.settings.isDebugMode } }; return this.patchState(e, "settings:toggled_debug"), this.persist(e), this })), kE(this, "setMenuOpen", (e => { let t = { appState: { isMenuOpen: e } }; return this.patchState(t, "ui:toggled_menu_opened"), this.persist(t), this })), kE(this, "setIsLoading", (e => { let t = { appState: { isLoading: e } }; return this.patchState(t, "ui:toggled_is_loading"), this.persist(t), this })), kE(this, "setDisableAssets", (e => (this.patchState({ appState: { disableAssets: e } }, "ui:toggled_disable_images"), this))), kE(this, "toggleGrid", (() => { if (this.session) return this; let e = { settings: { showGrid: !this.settings.showGrid } }; return this.patchState(e, "settings:toggled_grid"), this.persist(e), this })), kE(this, "selectTool", (e => { if (this.readOnly || this.session) return this; this.isPointing = !1; let t = this.tools[e]; return t === this.currentTool ? (this.patchState({ appState: { isToolLocked: !1 } }), this) : (this.currentTool.onExit(), t.previous = this.currentTool.type, this.currentTool = t, this.currentTool.onEnter(), this.patchState({ appState: { activeTool: e, isToolLocked: !1 } }, `selected_tool:${e}`)) })), kE(this, "toggleToolLock", (() => this.session ? this : this.patchState({ appState: { isToolLocked: !this.appState.isToolLocked } }, "toggled_tool_lock"))), kE(this, "resetDocument", (() => (this.session || (this.session = void 0, this.currentTool = this.tools.select, mP.defaultDocument.pages.page.name = "Page 1", this.resetHistory().clearSelectHistory().loadDocument(mP.defaultDocument).persist({})), this))), kE(this, "updateUsers", ((e, t = !1) => { this.patchState({ room: { users: Object.fromEntries(e.map((e => [e.id, e]))) } }, t ? "room:self:update" : "room:user:update") })), kE(this, "removeUser", (e => { this.patchState({ room: { users: { [e]: void 0 } } }) })), kE(this, "mergeDocument", (e => { if (this.document.id !== e.id) return this.replaceState(CE(EE({}, KI(CE(EE({}, this.state), { document: e }), mP.version)), { appState: CE(EE({}, this.appState), { currentPageId: Object.keys(e.pages)[0] }) })), this; let t = EE({}, this.document.pageStates), n = CE(EE({}, this.appState), { currentPageId: e.pages[this.currentPageId] ? this.currentPageId : Object.keys(e.pages)[0], pages: Object.values(e.pages).map(((e, t) => ({ id: e.id, name: e.name, childIndex: e.childIndex || t }))) }); this.resetHistory(), Object.keys(this.document.pages).forEach((n => { e.pages[n] || (n === this.appState.currentPageId && (this.cancelSession(), this.selectNone()), t[n] = void 0) })), this.session && this.selectedIds.filter((t => !e.pages[this.currentPageId].shapes[t])).forEach((t => e.pages[this.currentPageId].shapes[t] = this.page.shapes[t])), Object.entries(t).forEach((([t, n]) => { n.selectedIds = n.selectedIds.filter((n => !!e.pages[t].shapes[n])) })); let { editingId: r } = this.pageState; return r && (e.pages[this.currentPageId].shapes[r] = this.page.shapes[r], t[this.currentPageId].selectedIds = [r]), this.replaceState(CE(EE({}, KI(CE(EE({}, this.state), { document: CE(EE({}, e), { pageStates: t }) }), mP.version)), { appState: n }), "merge") })), kE(this, "updateDocument", ((e, t = "updated_document") => { let n = this.state, r = CE(EE({}, n), { document: CE(EE({}, n.document), { assets: e.assets }) }); e.pages[this.currentPageId] || (r.appState = CE(EE({}, n.appState), { currentPageId: Object.keys(e.pages)[0] })); let i = 1; for (let t of Object.values(e.pages)) t !== n.document.pages[t.id] && (r.document.pages[t.id] = t, t.name || (r.document.pages[t.id].name = `Page ${i + 1}`, i++)); for (let t of Object.values(e.pageStates)) if (t !== n.document.pageStates[t.id]) { r.document.pageStates[t.id] = t; let n = e.pages[t.id], i = ["bindingId", "editingId", "hoveredId", "pointedId"]; for (let e of i) n.shapes[e] || (t[e] = void 0); t.selectedIds = t.selectedIds.filter((t => !!e.pages[n.id].shapes[t])) } return this.replaceState(KI(r, r.document.version || 0), `${t}:${e.id}`) })), kE(this, "loadRoom", (e => (this.patchState({ room: { id: e, userId: fP, users: { [fP]: { id: fP, color: Wk[Math.floor(Math.random() * Wk.length)], point: [100, 100], selectedIds: [], activeShapes: [] } } } }), this))), kE(this, "loadDocument", (e => { this.setIsLoading(!0), this.selectNone(), this.resetHistory(), this.clearSelectHistory(), this.session = void 0; let t = CE(EE({}, mP.defaultState), { settings: EE({}, this.state.settings), document: e, appState: CE(EE(EE({}, mP.defaultState.appState), this.state.appState), { currentPageId: Object.keys(e.pages)[0], disableAssets: this.disableAssets }) }); this.replaceState(KI(t, mP.version), "loaded_document"); let { point: n, zoom: r } = this.camera; return this.updateViewport(n, r), this.setIsLoading(!1), this })), kE(this, "loadPageFromURL", ((e, t) => { let n = e.id, r = CE(EE({}, this.state.document), { pageStates: CE(EE({}, this.state.document.pageStates), { [n]: t }), pages: CE(EE({}, this.document.pages), { [n]: e }) }); this.loadDocument(r), this.persist({}) })), kE(this, "newProject", (() => { !this.isLocal || (this.fileSystemHandle = null, this.resetDocument()) })), kE(this, "saveProject", (() => xE(this, null, (function* () { if (this.readOnly) return; let e = yield XI(KI(this.state, mP.version).document, this.fileSystemHandle); return this.fileSystemHandle = e, this.persist({}), this.isDirty = !1, this })))), kE(this, "saveProjectAs", (e => xE(this, null, (function* () { try { let t = yield XI(this.document, null, e); this.fileSystemHandle = t, this.persist({}), this.isDirty = !1 } catch (e) { console.error(e.message) } return this })))), kE(this, "openProject", (() => xE(this, null, (function* () { if (this.isLocal) try { let e = yield _I(); if (!e) throw Error(); let { fileHandle: t, document: n } = e; this.loadDocument(n), this.fileSystemHandle = t, this.zoomToFit(), this.persist({}) } catch (e) { console.error(e) } finally { this.persist({}) } })))), kE(this, "openAsset", (() => xE(this, null, (function* () { if (!this.disableAssets) try { let e = yield QI(); if (Array.isArray(e)) this.addMediaFromFiles(e, this.centerPoint); else { if (!e) return; this.addMediaFromFiles([e]) } } catch (e) { console.error(e) } finally { this.persist({}) } })))), kE(this, "signOut", (() => { })), kE(this, "getAppState", (() => this.appState)), kE(this, "getPage", ((e = this.currentPageId) => ZA.getPage(this.state, e || this.currentPageId))), kE(this, "getShapes", ((e = this.currentPageId) => ZA.getShapes(this.state, e || this.currentPageId))), kE(this, "getBindings", ((e = this.currentPageId) => ZA.getBindings(this.state, e || this.currentPageId))), kE(this, "getShape", ((e, t = this.currentPageId) => ZA.getShape(this.state, e, t))), kE(this, "getShapeBounds", ((e, t = this.currentPageId) => ZA.getBounds(this.getShape(e, t)))), kE(this, "getBinding", ((e, t = this.currentPageId) => ZA.getBinding(this.state, e, t))), kE(this, "getPageState", ((e = this.currentPageId) => ZA.getPageState(this.state, e || this.currentPageId))), kE(this, "getPagePoint", ((e, t = this.currentPageId) => { let { camera: n } = this.getPageState(t); return R.sub(R.div(e, n.zoom), n.point) })), kE(this, "createPage", ((e, t) => { if (this.readOnly) return this; let { width: n, height: r } = this.rendererBounds; return this.setState(function (e, t, n = Zt.uniqueId(), r = "Page") { let { currentPageId: i } = e, o = Object.values(e.state.document.pages).sort(((e, t) => { var n, r; return (null != (n = e.childIndex) ? n : 0) - (null != (r = t.childIndex) ? r : 0) })), a = o[o.length - 1], s = (null == a ? void 0 : a.childIndex) ? (null == a ? void 0 : a.childIndex) + 1 : 1, l = { id: n, name: DI(r, o.map((e => { var t; return null != (t = e.name) ? t : "" }))), childIndex: s, shapes: {}, bindings: {} }; return { id: "create_page", before: { appState: { currentPageId: i }, document: { pages: { [n]: void 0 }, pageStates: { [n]: void 0 } } }, after: { appState: { currentPageId: l.id }, document: { pages: { [n]: l }, pageStates: { [n]: { id: n, selectedIds: [], camera: { point: t, zoom: 1 }, editingId: void 0, bindingId: void 0, hoveredId: void 0, pointedId: void 0 } } } } } }(this, [-n / 2, -r / 2], e, t)) })), kE(this, "changePage", (e => this.setState(function (e, t) { return { id: "change_page", before: { appState: { currentPageId: e.currentPageId } }, after: { appState: { currentPageId: t } } } }(this, e)))), kE(this, "movePage", ((e, t) => this.readOnly ? this : this.setState(function (e, t, n) { let { pages: r } = e.document, i = r[t], o = Object.values(r).sort(((e, t) => { var n, r; return (null != (n = e.childIndex) ? n : 0) - (null != (r = t.childIndex) ? r : 0) })), a = o.indexOf(i), s = [...o]; return s.splice(a, 1), s.splice(n > a ? n - 1 : n, 0, i), { id: "move_page", before: { document: { pages: Object.fromEntries(o.map((e => [e.id, { childIndex: e.childIndex }]))) } }, after: { document: { pages: Object.fromEntries(s.map(((e, t) => [e.id, { childIndex: t }]))) } } } }(this, e, t)))), kE(this, "renamePage", ((e, t) => this.readOnly ? this : this.setState(function (e, t, n) { let { page: r } = e; return { id: "rename_page", before: { document: { pages: { [t]: { name: r.name } } } }, after: { document: { pages: { [t]: { name: n } } } } } }(this, e, t)))), kE(this, "duplicatePage", (e => this.readOnly ? this : this.setState(function (e, t) { let { currentPageId: n, pageState: { camera: r } } = e, i = e.document.pages[t], o = Zt.uniqueId(), a = Object.fromEntries([[i.id, o], ...Object.keys(i.shapes).map((e => [e, Zt.uniqueId()])), ...Object.keys(i.bindings).map((e => [e, Zt.uniqueId()]))]), s = Object.fromEntries(Object.entries(i.shapes).map((([e, t]) => [a[e], CE(EE({}, Zt.deepClone(t)), { id: a[e], parentId: a[t.parentId] })]))), l = Object.fromEntries(Object.entries(i.bindings).map((([e, t]) => [a[e], CE(EE({}, Zt.deepClone(t)), { id: a[t.id], fromId: a[t.fromId], toId: a[t.toId] })]))); return Object.values(i.bindings).forEach((e => { let t = a[e.fromId], n = s[t].handles; n && Object.values(n).forEach((t => { t.bindingId === e.id && (t.bindingId = a[e.id]) })); let r = a[e.toId], i = s[r].handles; i && Object.values(i).forEach((t => { t.bindingId === e.id && (t.bindingId = a[e.id]) })) })), { id: "duplicate_page", before: { appState: { currentPageId: n }, document: { pages: { [o]: void 0 }, pageStates: { [o]: void 0 } } }, after: { appState: { currentPageId: o }, document: { pages: { [o]: CE(EE({}, i), { id: a[i.id], name: i.name + " Copy", shapes: s, bindings: l }) }, pageStates: { [o]: CE(EE({}, i), { id: o, selectedIds: [], camera: EE({}, r), editingId: void 0, bindingId: void 0, hoveredId: void 0, pointedId: void 0 }) } } } } }(this, e)))), kE(this, "deletePage", (e => this.readOnly || Object.values(this.document.pages).length <= 1 ? this : this.setState(function (e, t) { let n, { currentPageId: r, document: { pages: i, pageStates: o } } = e, a = Object.values(i).sort(((e, t) => (e.childIndex || 0) - (t.childIndex || 0))), s = a.findIndex((e => e.id === t)); return n = t === r ? s === a.length - 1 ? a[a.length - 2].id : a[s + 1].id : r, { id: "delete_page", before: { appState: { currentPageId: t }, document: { pages: { [t]: EE({}, i[t]) }, pageStates: { [t]: EE({}, o[t]) } } }, after: { appState: { currentPageId: n }, document: { pages: { [t]: void 0 }, pageStates: { [t]: void 0 } } } } }(this, e || this.currentPageId)))), kE(this, "cut", ((e = this.selectedIds, t) => (null == t || t.preventDefault(), this.copy(e, t), this.readOnly || this.delete(e), this))), kE(this, "copy", ((e = this.selectedIds, t) => { var n; null == t || t.preventDefault(), this.clipboard = this.getContent(e); let r = `<tldraw>${JSON.stringify(EE({ type: "tldr/clipboard", shapes: [], assets: [], bindings: [] }, this.clipboard))}</tldraw>`; return function (e) { xE(this, null, (function* () { return oE(RI, e) })) }(r), t && (null == (n = t.clipboardData) || n.setData("text/html", r)), navigator.clipboard && window.ClipboardItem && navigator.clipboard.write([new ClipboardItem({ "text/html": new Blob([r], { type: "text/html" }) })]), this })), kE(this, "paste", ((e, t) => xE(this, null, (function* () { var n, r; if (this.readOnly) return; let i, o = [], a = [], s = e => xE(this, null, (function* () { let t = document.createElement("div"); t.innerHTML = e; let n = t.firstChild; n.style.setProperty("background-color", "transparent"); let r = yield ZA.getImageForSvg(n, "svg", { scale: 1, quality: 1 }); if (r) { let e = new File([r], "image.svg"); o.push(e) } else l(e) })), l = t => { let n = this.getPagePoint(null != e ? e : this.centerPoint, this.currentPageId), r = t.includes("\n"); a.push(ZA.getShapeUtil("text").getShape({ id: Zt.uniqueId(), type: "text", parentId: this.appState.currentPageId, text: ZA.normalizeText(t.trim()), point: n, style: CE(EE({}, this.appState.currentStyle), { textAlign: r ? "start" : this.appState.currentStyle.textAlign }) })) }, c = e => { var t; try { let n = null == (t = e.match(/<tldraw>(.*)<\/tldraw>/)) ? void 0 : t[1]; if (!n) return; let r = JSON.parse(n); if ("tldr/clipboard" === r.type) return void (i = r); throw Error("Not tldraw data!") } catch (t) { l(e) } }; if (void 0 !== t) { let e = Array.from(null != (r = null == (n = t.clipboardData) ? void 0 : n.items) ? r : []); yield Promise.all(e.map((e => xE(this, null, (function* () { var t; let { type: n, kind: r } = e; switch (r) { case "string": { let r = yield new Promise((t => e.getAsString(t))); switch (n) { case "text/html": if (null == (t = r.match(/<tldraw>(.*)<\/tldraw>/)) ? void 0 : t[1]) return void c(r); break; case "text/plain": r.startsWith("<svg") ? yield s(r) : l(r) }break } case "file": { let t = e.getAsFile(); t && o.push(t); break } } }))))) } if (i) return this.insertContent(i, { point: e, select: !0 }), this; if (o.length) return this.addMediaFromFiles(o, e), this; if (a.length) { let t = this.getPagePoint(null != e ? e : this.centerPoint, this.currentPageId), n = R.add(t, [0, 0]); return a.forEach(((e, t) => { let r = ZA.getBounds(e); 0 === t && (n[0] -= r.width / 2, n[1] -= r.height / 2), e.point = [...n], n[0] += r.width })), this.createShapes(...a), this } return this.clipboard ? this.insertContent(this.clipboard) : function () { return xE(this, null, (function* () { return iE(RI) })) }().then((e => { e && c(e) })), this })))), kE(this, "getSvg", ((...e) => xE(this, [...e], (function* (e = (this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes)), t = {}) { if (0 === e.length) return; let n = document.createElementNS("http://www.w3.org/2000/svg", "svg"), r = document.createElementNS("http://www.w3.org/2000/svg", "defs"), i = document.createElementNS("http://www.w3.org/2000/svg", "style"); if ("undefined" != typeof window && window.focus(), t.includeFonts) try { let { fonts: e } = yield fetch(mP.assetSrc, { mode: "no-cors" }).then((e => e.json())); i.textContent = `\n          @font-face {\n            font-family: 'Caveat Brush';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${e.caveat}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          @font-face {\n            font-family: 'Source Code Pro';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${e.source_code_pro}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          @font-face {\n            font-family: 'Source Sans Pro';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${e.source_sans_pro}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          @font-face {\n            font-family: 'Crimson Pro';\n            src: url(data:application/x-font-woff;charset=utf-8;base64,${e.crimson_pro}) format('woff');\n            font-weight: 500;\n            font-style: normal;\n          }\n          ` } catch (e) { ZA.warn("Could not find tldraw-assets.json file.") } else i.textContent = "@import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Source+Code+Pro&family=Source+Sans+Pro&family=Crimson+Pro&display=block');"; r.append(i), n.append(r); let o = e.map((e => this.getShape(e, this.currentPageId))).sort(((e, t) => e.childIndex - t.childIndex)), a = Zt.getCommonBounds(o.map(ZA.getRotatedBounds)), s = e => { let t = ZA.getShapeUtil(e), n = t.getBounds(e), r = t.getSvgElement(e, this.settings.isDarkMode); if (r) return "image" === e.type ? r.setAttribute("xlink:href", this.document.assets[e.assetId].src) : "video" === e.type && r.setAttribute("xlink:href", this.serializeVideo(e.id)), r.setAttribute("transform", `translate(${(16 + e.point[0] - a.minX).toFixed(2)}, ${(16 + e.point[1] - a.minY).toFixed(2)}) rotate(${(180 * (e.rotation || 0) / Math.PI).toFixed(2)}, ${(n.width / 2).toFixed(2)}, ${(n.height / 2).toFixed(2)})`), r }; o.forEach((e => { var t; if (null == (t = e.children) ? void 0 : t.length) { let t = document.createElementNS("http://www.w3.org/2000/svg", "g"); return e.children.forEach((e => { let n = this.getShape(e, this.currentPageId), r = s(n); r && t.append(r) })), void n.append(t) } let r = s(e); r && n.append(r) })), n.setAttribute("viewBox", [0, 0, a.width + 32, a.height + 32].join(" ")), n.setAttribute("width", (a.width + 32).toString()), n.setAttribute("height", (a.height + 32).toString()); let l = "#212529", c = "rgb(248, 249, 250)"; switch (this.settings.exportBackground) { case "auto": n.style.setProperty("background-color", this.settings.isDarkMode ? l : c); break; case "dark": n.style.setProperty("background-color", l); break; case "light": n.style.setProperty("background-color", c); break; default: n.style.setProperty("background-color", "transparent") }return n.querySelectorAll(".tl-fill-hitarea, .tl-stroke-hitarea, .tl-binding-indicator").forEach((e => e.remove())), n })))), kE(this, "copySvg", ((...e) => xE(this, [...e], (function* (e = (this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes))) { if (0 === e.length) return; let t = yield this.getSvg(e); if (!t) return; let n = ZA.getSvgString(t, 1); this.clipboard = this.getContent(e); let r = JSON.stringify(EE({ type: "tldr/clipboard", shapes: [], assets: [], bindings: [] }, this.clipboard)); return navigator.clipboard && window.ClipboardItem && navigator.clipboard.write([new ClipboardItem({ "text/html": new Blob([r], { type: "text/html" }), "text/plain": new Blob([n], { type: "text/plain" }) })]), n })))), kE(this, "getContent", (e => { let t = this.getPage(this.currentPageId); if (e && 0 === e.length || (e || (e = this.selectedIds), 0 === e.length && (e = Object.keys(t.shapes)), 0 === e.length)) return; let n = e.map((e => t.shapes[e])).flatMap((e => { var n; return [e, ...(null != (n = e.children) ? n : []).map((e => t.shapes[e]))] })).map(_k), r = new Set(n.map((e => e.id))); n.forEach((e => { e.parentId === this.currentPageId && (e.parentId = "currentPageId") })); let i = Object.values(t.bindings).filter((e => { if (r.has(e.fromId) || r.has(e.toId)) return !0; if (r.has(e.fromId)) { let t = n.find((t => t.id === e.fromId)).handles; t && Object.values(t).forEach((t => { t.bindingId === e.id && (t.bindingId = void 0) })) } if (r.has(e.toId)) { let t = n.find((t => t.id === e.toId)).handles; t && Object.values(t).forEach((t => { t.bindingId === e.id && (t.bindingId = void 0) })) } return !1 })).map(_k), o = [...new Set(n.map((e => { if (e.assetId) return this.document.assets[e.assetId] })).filter(Boolean).map(_k))]; return { shapes: n, bindings: i, assets: o } })), kE(this, "copyJson", ((e = this.selectedIds) => { let t = this.getContent(e); return t && ZA.copyStringToClipboard(JSON.stringify(t)), this })), kE(this, "exportJson", ((e = this.selectedIds) => { let t = this.getContent(e); if (t) { let e = new Blob([JSON.stringify(t)], { type: "application/json" }), n = URL.createObjectURL(e), r = document.createElement("a"); r.href = n, r.download = "export.json", r.click() } return this })), kE(this, "insertContent", ((e, t = {}) => this.setState(function (e, t, n = {}) { let { currentPageId: r } = e, { point: i, select: o, overwrite: a } = n, s = e.document.pages[r], l = { shapes: {}, bindings: {} }, c = {}, u = { shapes: {}, bindings: {} }; if (a) { for (let e of t.shapes) l.shapes[e.id] = s.shapes[e.id], u.shapes[e.id] = e; if (t.bindings) for (let e of t.bindings) l.bindings[e.id] = s.bindings[e.id], u.bindings[e.id] = e; if (t.assets) for (let e of t.assets) c[e.id] = e } else { let n = {}, o = ZA.getTopChildIndex(e.state, r), a = t.shapes.sort(((e, t) => e.childIndex - t.childIndex)).map((e => { let t = Zt.uniqueId(); return n[e.id] = t, CE(EE({}, Zt.deepClone(e)), { id: t }) })), s = new Set; for (; a.length > 0;) { let e = a.shift(); if (!e) break; if (s.add(e.id), "currentPageId" === e.parentId) e.parentId = r, e.childIndex = o++; else { e.parentId = n[e.parentId]; let t = u.shapes[e.parentId]; if (!t) { s.has(e.id) && (e.parentId = "currentPageId"), a.push(e); continue } t.children.push(e.id) } e.children && (e.children = []), l.shapes[e.id] = void 0, u.shapes[e.id] = e } Object.values(u.shapes).forEach((e => { e.children && 0 === e.children.length && (delete l.shapes[e.id], delete u.shapes[e.id]) })), t.bindings && t.bindings.forEach((e => { let t = Zt.uniqueId(); n[e.id] = t; let r = n[e.toId], i = n[e.fromId]; if (!r || !i) { if (i) { let t = u.shapes[i].handles; t && Object.values(t).forEach((t => { t.bindingId === e.id && (t.bindingId = void 0) })) } if (r) { let t = u.shapes[r].handles; t && Object.values(t).forEach((t => { t.bindingId === e.id && (t.bindingId = void 0) })) } return } let o = u.shapes[i].handles; o && Object.values(o).forEach((n => { n.bindingId === e.id && (n.bindingId = t) })), u.shapes[r].handles && Object.values(u.shapes[r].handles).forEach((n => { n.bindingId === e.id && (n.bindingId = t) })); let a = CE(EE({}, Zt.deepClone(e)), { id: t, toId: r, fromId: i }); l.bindings[a.id] = void 0, u.bindings[a.id] = a })); let d = Object.values(u.shapes); if (d.length > 0) if (i) { let e = Zt.getCommonBounds(d.map((e => ZA.getBounds(e)))), t = Zt.getBoundsCenter(e); d.forEach((e => { !e.point || (e.point = R.sub(i, R.sub(t, e.point))) })) } else { let t = Zt.getCommonBounds(d.map(ZA.getBounds)); if (!Zt.boundsContain(e.viewport, t) && !Zt.boundsCollide(e.viewport, t)) { let n = R.toFixed(e.getPagePoint(e.centerPoint)), r = Zt.centerBounds(t, n), i = R.sub(Zt.getBoundsCenter(r), Zt.getBoundsCenter(t)); d.forEach((e => { e.point = R.toFixed(R.add(e.point, i)) })) } } if (t.assets) for (let e of t.assets) c[e.id] = e } let d = document.createElement("textarea"); return Object.values(u.shapes).forEach((e => { "text" in e && (d.innerHTML = e.text, e.text = d.value), "label" in e && (d.innerHTML = e.label, e.label = d.value) })), d.remove(), { id: "insert", before: { document: { pages: { [r]: l }, pageStates: { [r]: { selectedIds: [...e.selectedIds] } } } }, after: { document: { pages: { [r]: u }, assets: c, pageStates: { [r]: { selectedIds: o ? Object.keys(u.shapes) : [...e.selectedIds] } } } } } }(this, e, t), "insert_content"))), kE(this, "getImage", ((...e) => xE(this, [...e], (function* (e = "png", t = {}) { let { ids: n = (this.selectedIds.length ? this.selectedIds : Object.keys(this.page.shapes)) } = t, r = yield this.getSvg(n, { includeFonts: "svg" !== e }); if (r) { if ("svg" === e) { let e = ZA.getSvgString(r, 1); return new Blob([e], { type: "image/svg+xml" }) } return (yield ZA.getImageForSvg(r, e, t)) || void 0 } })))), kE(this, "copyImage", ((...e) => xE(this, [...e], (function* (e = "png", t = {}) { if ("svg" === e) return void this.copySvg(t.ids); if (!navigator.clipboard || !window.ClipboardItem) return void console.warn("Sorry, your browser does not support copying images."); let n = yield this.getImage(e, t); !n || navigator.clipboard.write([new ClipboardItem({ [n.type]: n })]) })))), kE(this, "exportImage", ((...e) => xE(this, [...e], (function* (e = "png", t = {}) { var n; let { pageId: r = this.currentPageId } = t, i = yield this.getImage(e, t); if (!i) return; let o = null != (n = this.document.pages[r].name) ? n : "export"; if (this.callbacks.onExport) this.callbacks.onExport(this, { name: o, type: e, blob: i }); else { let t = URL.createObjectURL(i), n = document.createElement("a"); n.href = t, n.download = `${o}.${e}`, n.click() } })))), kE(this, "setCamera", ((e, t, n) => (this.updateViewport(e, t), this.patchState({ document: { pageStates: { [this.currentPageId]: { camera: { point: e, zoom: t } } } } }, n), this))), kE(this, "resetCamera", (() => this.setCamera(this.centerPoint, 1, "reset_camera"))), kE(this, "pan", (e => { let { camera: t } = this.pageState; return this.setCamera(R.toFixed(R.sub(t.point, e)), t.zoom, "panned") })), kE(this, "pinchZoom", ((e, t, n) => { let { camera: r } = this.pageState, i = R.sub(r.point, R.div(t, r.zoom)), o = n, a = R.sub(R.div(e, r.zoom), i), s = R.sub(R.div(e, o), i); return this.setCamera(R.toFixed(R.add(i, R.sub(s, a))), o, "pinch_zoomed") })), kE(this, "zoomTo", ((e, t = this.centerPoint) => { let { zoom: n, point: r } = this.camera, i = R.sub(R.div(t, n), r), o = R.sub(R.div(t, e), r); return this.setCamera(R.toFixed(R.add(r, R.sub(o, i))), e, "zoomed_camera") })), kE(this, "zoomIn", (() => { let e = Math.round(100 * this.camera.zoom / 25), t = ZA.getCameraZoom(.25 * (e + 1)); return this.zoomTo(t) })), kE(this, "zoomOut", (() => { let e = Math.round(100 * this.camera.zoom / 25), t = ZA.getCameraZoom(.25 * (e - 1)); return this.zoomTo(t) })), kE(this, "zoomToFit", (() => { let { shapes: e, pageState: { camera: t } } = this; if (0 === e.length) return this; let { rendererBounds: n } = this, r = Zt.getCommonBounds(e.map(ZA.getBounds)), i = ZA.getCameraZoom(Math.min((n.width - 128) / r.width, (n.height - 128) / r.height)); i = t.zoom === i || t.zoom < 1 ? Math.min(1, i) : i; let o = (n.width - r.width * i) / 2 / i, a = (n.height - r.height * i) / 2 / i; return this.setCamera(R.toFixed(R.sub([o, a], [r.minX, r.minY])), i, "zoomed_to_fit") })), kE(this, "zoomToSelection", (() => { if (0 === this.selectedIds.length) return this; let { rendererBounds: e } = this, t = ZA.getSelectedBounds(this.state), n = ZA.getCameraZoom(Math.min((e.width - 128) / t.width, (e.height - 128) / t.height)); n = this.camera.zoom === n || this.camera.zoom < 1 ? Math.min(1, n) : n; let r = (e.width - t.width * n) / 2 / n, i = (e.height - t.height * n) / 2 / n; return this.setCamera(R.toFixed(R.sub([r, i], [t.minX, t.minY])), n, "zoomed_to_selection") })), kE(this, "zoomToContent", (() => { let e = this.shapes, t = this.pageState; if (0 === e.length) return this; let { rendererBounds: n } = this, { zoom: r } = t.camera, i = Zt.getCommonBounds(e.map(ZA.getBounds)), o = (n.width - i.width * r) / 2 / r, a = (n.height - i.height * r) / 2 / r; return this.setCamera(R.toFixed(R.sub([o, a], [i.minX, i.minY])), this.camera.zoom, "zoomed_to_content") })), kE(this, "resetZoom", (() => this.zoomTo(1))), kE(this, "zoomBy", Zt.throttle(((e, t) => { let { zoom: n } = this.camera, r = ZA.getCameraZoom(n - e * n); return this.zoomTo(r, t) }), 16)), kE(this, "clearSelectHistory", (() => (this.selectHistory.pointer = 0, this.selectHistory.stack = [this.selectedIds], this))), kE(this, "addToSelectHistory", (e => (this.selectHistory.pointer < this.selectHistory.stack.length && (this.selectHistory.stack = this.selectHistory.stack.slice(0, this.selectHistory.pointer + 1)), this.selectHistory.pointer++, this.selectHistory.stack.push(e), this))), kE(this, "setSelectedIds", ((e, t = !1) => { let n = t ? [...this.pageState.selectedIds, ...e] : [...e]; return this.patchState({ appState: { activeTool: "select" }, document: { pageStates: { [this.currentPageId]: { selectedIds: n } } } }, "selected") })), kE(this, "undoSelect", (() => (this.selectHistory.pointer > 0 && (this.selectHistory.pointer--, this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer])), this))), kE(this, "redoSelect", (() => (this.selectHistory.pointer < this.selectHistory.stack.length - 1 && (this.selectHistory.pointer++, this.setSelectedIds(this.selectHistory.stack[this.selectHistory.pointer])), this))), kE(this, "select", ((...e) => (e.forEach((e => { if (!this.page.shapes[e]) throw Error(`That shape does not exist on page ${this.currentPageId}`) })), this.setSelectedIds(e), this.addToSelectHistory(e), this))), kE(this, "selectAll", ((e = this.currentPageId) => (this.session || (this.setSelectedIds(Object.values(this.document.pages[e].shapes).filter((t => t.parentId === e)).map((e => e.id))), this.addToSelectHistory(this.selectedIds), this.selectTool("select")), this))), kE(this, "selectNone", (() => (this.setSelectedIds([]), this.addToSelectHistory(this.selectedIds), this))), kE(this, "startSession", ((e, ...t) => { var n, r; if (this.readOnly && "brush" !== e) return this; this.session && (ZA.warn(`Already in a session! (${this.session.constructor.name})`), this.cancelSession()); let i = (e => nP[e])(e); this.session = new i(this, ...t); let o = this.session.start(); return o && this.patchState(o, `session:start_${this.session.constructor.name}`), null == (r = (n = this.callbacks).onSessionStart) || r.call(n, this, this.session.constructor.name), this })), kE(this, "updateSession", (() => { let { session: e } = this; if (!e) return this; let t = e.update(); return t ? this.patchState(t, `session:${null == e ? void 0 : e.constructor.name}`) : this })), kE(this, "cancelSession", (() => { var e, t; let { session: n } = this; if (!n) return this; this.session = void 0; let r = n.cancel(); return r && this.patchState(r, `session:cancel:${n.constructor.name}`), this.setEditingId(), null == (t = (e = this.callbacks).onSessionEnd) || t.call(e, this, n.constructor.name), this })), kE(this, "completeSession", (() => { var e, t, n, r, i, o, a, s, l; let { session: c } = this; if (!c) return this; this.session = void 0; let u = c.complete(); return void 0 === u ? (this.isCreating = !1, this.patchState({ appState: { status: "idle" }, document: { pageStates: { [this.currentPageId]: { editingId: void 0, bindingId: void 0, hoveredId: void 0 } } } }, `session:complete:${c.constructor.name}`)) : "after" in u ? (this.isCreating && (u.before = { appState: CE(EE({}, u.before.appState), { status: "idle" }), document: { pages: { [this.currentPageId]: { shapes: Object.fromEntries(this.selectedIds.map((e => [e, void 0]))) } }, pageStates: { [this.currentPageId]: { selectedIds: [], editingId: null, bindingId: null, hoveredId: null } } } }, this.appState.isToolLocked && (((null == (n = null == (t = null == (e = u.after) ? void 0 : e.document) ? void 0 : t.pageStates) ? void 0 : n[this.currentPageId]) || {}).selectedIds = []), this.isCreating = !1), u.after.appState = CE(EE({}, u.after.appState), { status: "idle" }), u.after.document = CE(EE({}, u.after.document), { pageStates: CE(EE({}, null == (r = u.after.document) ? void 0 : r.pageStates), { [this.currentPageId]: CE(EE({}, ((null == (i = u.after.document) ? void 0 : i.pageStates) || {})[this.currentPageId]), { editingId: null }) }) }), this.setState(u, `session:complete:${c.constructor.name}`)) : this.patchState(CE(EE({}, u), { appState: CE(EE({}, u.appState), { status: "idle" }), document: CE(EE({}, u.document), { pageStates: { [this.currentPageId]: CE(EE({}, null == (a = null == (o = u.document) ? void 0 : o.pageStates) ? void 0 : a[this.currentPageId]), { editingId: null }) } }) }), `session:complete:${c.constructor.name}`), null == (l = (s = this.callbacks).onSessionEnd) || l.call(s, this, c.constructor.name), this })), kE(this, "createShapes", ((...e) => 0 === e.length ? this : this.create(e.map((e => ZA.getShapeUtil(e.type).create(EE({ parentId: this.currentPageId }, e))))))), kE(this, "updateShapes", ((...e) => { let t = this.document.pages[this.currentPageId].shapes, n = e.filter((e => t[e.id])); return 0 === n.length ? this : this.setState(UI(this, n, this.currentPageId), "updated_shapes") })), kE(this, "create", ((e = [], t = []) => 0 === e.length ? this : this.setState(LI(this, e, t)))), kE(this, "patchCreate", ((e = [], t = []) => 0 === e.length ? this : this.patchState(LI(this, e, t).after))), kE(this, "delete", ((e = this.selectedIds) => { var t, n; if (0 === e.length) return this; if (this.session) return this; let r = OI(this, e); if (this.callbacks.onAssetDelete && (null == (t = r.before.document) ? void 0 : t.assets) && (null == (n = r.after.document) ? void 0 : n.assets)) { let e = Object.keys(r.before.document.assets).filter((e => !!r.before.document.assets[e])), t = Object.keys(r.after.document.assets).filter((e => !!r.after.document.assets[e])); e.filter((e => !t.includes(e))).forEach((e => this.callbacks.onAssetDelete(this, e))) } return this.setState(r) })), kE(this, "deleteAll", (() => (this.selectAll(), this.delete(), this))), kE(this, "style", ((e, t = this.selectedIds) => this.setState(function (e, t, n) { let { currentPageId: r, selectedIds: i } = e, o = t.flatMap((t => ZA.getDocumentBranch(e.state, t, r))).filter((t => !e.getShape(t).isLocked)), a = {}, s = {}; return o.map((t => e.getShape(t))).filter((e => !e.isLocked)).forEach((t => { a[t.id] = { style: EE({}, Object.fromEntries(Object.keys(n).map((e => [e, t.style[e]])))) }, s[t.id] = { style: n }, "text" === t.type && (a[t.id].point = t.point, s[t.id].point = R.toFixed(R.add(t.point, R.sub(e.getShapeUtil(t).getCenter(t), e.getShapeUtil(t).getCenter(CE(EE({}, t), { style: EE(EE({}, t.style), n) })))))) })), { id: "style", before: { document: { pages: { [r]: { shapes: a } }, pageStates: { [r]: { selectedIds: i } } }, appState: { currentStyle: EE({}, e.appState.currentStyle) } }, after: { document: { pages: { [r]: { shapes: s } }, pageStates: { [r]: { selectedIds: t } } }, appState: { currentStyle: n } } } }(this, t, e)))), kE(this, "align", ((e, t = this.selectedIds) => t.length < 2 ? this : this.setState(function (e, t, n) { let { currentPageId: r } = e, i = t.map((t => e.getShape(t))), o = i.map((e => ({ id: e.id, point: [...e.point], bounds: ZA.getBounds(e) }))), a = Zt.getCommonBounds(o.map((({ bounds: e }) => e))), s = a.minX + a.width / 2, l = a.minY + a.height / 2, c = Object.fromEntries(o.map((({ id: e, point: t, bounds: r }) => [e, { prev: t, next: { top: [t[0], a.minY], centerVertical: [t[0], l - r.height / 2], bottom: [t[0], a.maxY - r.height], left: [a.minX, t[1]], centerHorizontal: [s - r.width / 2, t[1]], right: [a.maxX - r.width, t[1]] }[n] }]))), { before: u, after: d } = ZA.mutateShapes(e.state, t, (e => c[e.id] ? { point: c[e.id].next } : e), r, !1); return i.forEach((t => { if ("group" === t.type) { let n = R.sub(d[t.id].point, u[t.id].point); t.children.forEach((t => { let r = e.getShape(t); u[r.id] = { point: r.point }, d[r.id] = { point: R.add(r.point, n) } })), delete u[t.id], delete d[t.id] } })), { id: "align", before: { document: { pages: { [r]: { shapes: u } }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: { shapes: d } }, pageStates: { [r]: { selectedIds: t } } } } } }(this, t, e)))), kE(this, "distribute", ((e, t = this.selectedIds) => t.length < 3 ? this : this.setState(function (e, t, n) { let { currentPageId: r } = e, i = t.map((t => e.getShape(t))), o = Object.fromEntries(function (e, t) { let n = e.map((e => { let t = ZA.getShapeUtil(e); return { id: e.id, point: [...e.point], bounds: t.getBounds(e), center: t.getCenter(e) } })), r = n.length, i = Zt.getCommonBounds(n.map((({ bounds: e }) => e))), o = []; switch (t) { case "horizontal": { let e = n.reduce(((e, t) => e + t.bounds.width), 0); if (e > i.width) { let e = n.sort(((e, t) => e.bounds.minX - t.bounds.minX))[0], t = n.sort(((e, t) => t.bounds.maxX - e.bounds.maxX))[0], i = n.filter((n => n !== e && n !== t)).sort(((e, t) => e.center[0] - t.center[0])), a = (t.center[0] - e.center[0]) / (r - 1), s = e.center[0] + a; i.forEach((({ id: e, point: t, bounds: n }, r) => { o.push({ id: e, prev: t, next: [s + a * r - n.width / 2, n.minY] }) })) } else { let t = n.sort(((e, t) => e.center[0] - t.center[0])), a = i.minX, s = (i.width - e) / (r - 1); t.forEach((({ id: e, point: t, bounds: n }) => { o.push({ id: e, prev: t, next: [a, n.minY] }), a += n.width + s })) } break } case "vertical": { let e = n.reduce(((e, t) => e + t.bounds.height), 0); if (e > i.height) { let e = n.sort(((e, t) => e.bounds.minY - t.bounds.minY))[0], t = n.sort(((e, t) => t.bounds.maxY - e.bounds.maxY))[0], i = n.filter((n => n !== e && n !== t)).sort(((e, t) => e.center[1] - t.center[1])), a = (t.center[1] - e.center[1]) / (r - 1), s = e.center[1] + a; i.forEach((({ id: e, point: t, bounds: n }, r) => { o.push({ id: e, prev: t, next: [n.minX, s + a * r - n.height / 2] }) })) } else { let t = n.sort(((e, t) => e.center[1] - t.center[1])), a = i.minY, s = (i.height - e) / (r - 1); t.forEach((({ id: e, point: t, bounds: n }) => { o.push({ id: e, prev: t, next: [n.minX, a] }), a += n.height + s })) } break } }return o }(i, n).map((e => [e.id, e]))), { before: a, after: s } = ZA.mutateShapes(e.state, t.filter((e => void 0 !== o[e])), (e => { var t; return { point: null == (t = o[e.id]) ? void 0 : t.next } }), r); return i.forEach((t => { if ("group" === t.type) { let n = B.sub(s[t.id].point, a[t.id].point); t.children.forEach((t => { let r = e.getShape(t); a[r.id] = { point: r.point }, s[r.id] = { point: B.add(r.point, n) } })), delete a[t.id], delete s[t.id] } })), { id: "distribute", before: { document: { pages: { [r]: { shapes: a } }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: { shapes: s } }, pageStates: { [r]: { selectedIds: t } } } } } }(this, t, e)))), kE(this, "stretch", ((e, t = this.selectedIds) => t.length < 2 ? this : this.setState(function (e, t, n) { let { currentPageId: r, selectedIds: i } = e, o = t.map((t => e.getShape(t))), a = o.map((e => ZA.getBounds(e))), s = Zt.getCommonBounds(a), l = t.flatMap((t => { let n = e.getShape(t); return n.children ? n.children : n.id })).filter((t => !e.getShape(t).isLocked)), { before: c, after: u } = ZA.mutateShapes(e.state, l, (e => { let t = ZA.getBounds(e); switch (n) { case "horizontal": { let n = CE(EE({}, t), { minX: s.minX, maxX: s.maxX, width: s.width }); return ZA.getShapeUtil(e).transformSingle(e, n, { type: Kt.TopLeft, scaleX: n.width / t.width, scaleY: 1, initialShape: e, transformOrigin: [.5, .5] }) } case "vertical": { let n = CE(EE({}, t), { minY: s.minY, maxY: s.maxY, height: s.height }); return ZA.getShapeUtil(e).transformSingle(e, n, { type: Kt.TopLeft, scaleX: 1, scaleY: n.height / t.height, initialShape: e, transformOrigin: [.5, .5] }) } } }), r); return o.forEach((e => { "group" === e.type && (delete c[e.id], delete u[e.id]) })), { id: "stretch", before: { document: { pages: { [r]: { shapes: c } }, pageStates: { [r]: { selectedIds: i } } } }, after: { document: { pages: { [r]: { shapes: u } }, pageStates: { [r]: { selectedIds: t } } } } } }(this, t, e)))), kE(this, "flipHorizontal", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(FI(this, e, "horizontal")))), kE(this, "flipVertical", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(FI(this, e, "vertical")))), kE(this, "moveToPage", ((e, t = this.currentPageId, n = this.selectedIds) => { if (0 === n.length) return this; let { rendererBounds: r } = this; return this.setState(function (e, t, n, r, i) { let { page: o } = e, a = { before: { shapes: {}, bindings: {} }, after: { shapes: {}, bindings: {} } }, s = { before: { shapes: {}, bindings: {} }, after: { shapes: {}, bindings: {} } }, l = new Set, c = new Set; t.map((t => e.getShape(t, r))).filter((e => !e.isLocked)).forEach((t => { l.add(t.id), c.add(t), void 0 !== t.children && t.children.forEach((t => { l.add(t), c.add(e.getShape(t, r)) })) })); let u = ZA.getTopChildIndex(e.state, i), d = Array.from(c.values()); d.forEach(((t, n) => { if (a.before.shapes[t.id] = t, a.after.shapes[t.id] = void 0, s.before.shapes[t.id] = void 0, s.after.shapes[t.id] = t, !l.has(t.parentId) && (s.after.shapes[t.id] = CE(EE({}, t), { parentId: i, childIndex: u + n }), t.parentId !== r)) { let n = e.getShape(t.parentId, r); a.before.shapes[n.id] = { children: n.children }, a.after.shapes[n.id] = { children: n.children.filter((e => e !== t.id)) } } })), Object.values(o.bindings).filter((e => l.has(e.fromId) || l.has(e.toId))).forEach((t => { a.before.bindings[t.id] = t, a.after.bindings[t.id] = void 0; let n = e.getShape(t.fromId, r); if (l.has(t.fromId) && l.has(t.toId)) s.before.bindings[t.id] = void 0, s.after.bindings[t.id] = t; else if (l.has(t.fromId)) { let i = e.getShape(t.fromId, r), o = Object.values(n.handles).find((e => e.bindingId === t.id)).id, a = s.after.shapes[i.id]; a.handles = CE(EE({}, a.handles), { [o]: CE(EE({}, a.handles[o]), { bindingId: void 0 }) }) } else { let i = e.getShape(t.fromId, r), o = Object.values(n.handles).find((e => e.bindingId === t.id)); a.before.shapes[i.id] = { handles: { [o.id]: { bindingId: t.id } } }, a.after.shapes[i.id] = { handles: { [o.id]: { bindingId: void 0 } } } } })); let p = e.state.document.pageStates[i], h = Zt.getCommonBounds(d.map((e => ZA.getBounds(e)))), f = ZA.getCameraZoom(n.width < n.height ? (n.width - 128) / h.width : (n.height - 128) / h.height), m = (n.width - h.width * f) / 2 / f, g = (n.height - h.height * f) / 2 / f, v = R.toFixed(R.add([-h.minX, -h.minY], [m, g])); return { id: "move_to_page", before: { appState: { currentPageId: r }, document: { pages: { [r]: a.before, [i]: s.before }, pageStates: { [r]: { selectedIds: t }, [i]: { selectedIds: p.selectedIds, camera: p.camera } } } }, after: { appState: { currentPageId: i }, document: { pages: { [r]: a.after, [i]: s.after }, pageStates: { [r]: { selectedIds: [] }, [i]: { selectedIds: t, camera: { zoom: f, point: v } } } } } } }(this, n, r, t, e)), this })), kE(this, "moveToBack", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(zI(this, e, "toBack")))), kE(this, "moveBackward", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(zI(this, e, "backward")))), kE(this, "moveForward", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(zI(this, e, "forward")))), kE(this, "moveToFront", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(zI(this, e, "toFront")))), kE(this, "nudge", ((e, t = !1, n = this.selectedIds) => { if (0 === n.length) return this; let r = t ? this.settings.showGrid ? 4 * this.currentGrid : 10 : this.settings.showGrid ? this.currentGrid : 1; return this.setState(function (e, t, n) { let { currentPageId: r, selectedIds: i } = e; e.rotationInfo.selectedIds = [...i]; let o = { shapes: {}, bindings: {} }, a = { shapes: {}, bindings: {} }, s = t.flatMap((t => { let n = e.getShape(t); return n.children ? n.children : n.id })).filter((t => !e.getShape(t).isLocked)), l = ZA.mutateShapes(e.state, s, (e => ({ point: R.toFixed(R.add(e.point, n)) })), r); return o.shapes = l.before, a.shapes = l.after, ZA.getBindings(e.state, r).filter((e => t.includes(e.fromId) && !t.includes(e.toId))).forEach((t => { o.bindings[t.id] = t, a.bindings[t.id] = void 0; for (let n of [t.toId, t.fromId]) { let r = e.getShape(n); !r.handles || Object.values(r.handles).filter((e => e.bindingId === t.id)).forEach((e => { var r, i; o.shapes[n] = CE(EE({}, o.shapes[n]), { handles: CE(EE({}, null == (r = o.shapes[n]) ? void 0 : r.handles), { [e.id]: { bindingId: t.id } }) }), a.shapes[n] = CE(EE({}, a.shapes[n]), { handles: CE(EE({}, null == (i = a.shapes[n]) ? void 0 : i.handles), { [e.id]: { bindingId: void 0 } }) }) })) } })), { id: "translate", before: { document: { pages: { [r]: o }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: a }, pageStates: { [r]: { selectedIds: t } } } } } }(this, n, R.mul(e, r))) })), kE(this, "duplicate", ((e = this.selectedIds, t) => this.readOnly || 0 === e.length ? this : this.setState(function (e, t, n) { let { selectedIds: r, currentPageId: i, page: o, shapes: a } = e, s = { shapes: {}, bindings: {} }, l = { shapes: {}, bindings: {} }, c = {}, u = t.map((t => e.getShape(t))).filter((e => !t.includes(e.parentId))); u.forEach((t => { let n = Zt.uniqueId(); if (s.shapes[n] = void 0, l.shapes[n] = CE(EE({}, Zt.deepClone(t)), { id: n, childIndex: ZA.getChildIndexAbove(e.state, t.id, i) }), t.children && (l.shapes[n].children = []), t.parentId !== i) { let r = e.getShape(t.parentId); s.shapes[r.id] = CE(EE({}, s.shapes[r.id]), { children: r.children }), l.shapes[r.id] = CE(EE({}, l.shapes[r.id]), { children: [...(l.shapes[r.id] || r).children, n] }) } c[t.id] = n })), u.forEach((t => { t.children && t.children.forEach((n => { var r, o; let a = e.getShape(n), u = Zt.uniqueId(), d = c[t.id]; s.shapes[u] = void 0, l.shapes[u] = CE(EE({}, Zt.deepClone(a)), { id: u, parentId: d, childIndex: ZA.getChildIndexAbove(e.state, a.id, i) }), c[n] = u, null == (o = null == (r = l.shapes[c[t.id]]) ? void 0 : r.children) || o.push(u) })) })); let d = new Set(Object.keys(c)); Object.values(o.bindings).filter((e => d.has(e.fromId) || d.has(e.toId))).forEach((e => { if (d.has(e.fromId)) if (d.has(e.toId)) { let t = Zt.uniqueId(), n = CE(EE({}, Zt.deepClone(e)), { id: t, fromId: c[e.fromId], toId: c[e.toId] }); s.bindings[t] = void 0, l.bindings[t] = n; let r = l.shapes[n.fromId]; Object.values(r.handles).forEach((n => { n.bindingId === e.id && (n.bindingId = t) })) } else { let t = l.shapes[c[e.fromId]]; Object.values(t.handles).forEach((t => { t.bindingId === e.id && (t.bindingId = void 0) })) } })); let p = Object.values(l.shapes); if (n) { let e = Zt.getCommonBounds(p.map((e => ZA.getBounds(e)))), t = Zt.getBoundsCenter(e); p.forEach((e => { !e.point || (e.point = R.sub(n, R.sub(t, e.point))) })) } else { let e = [16, 16]; p.forEach((t => { !t.point || (t.point = R.add(t.point, e)) })) } return p.forEach((e => { e.isLocked && (e.isLocked = !1) })), { id: "duplicate", before: { document: { pages: { [i]: s }, pageStates: { [i]: { selectedIds: r } } } }, after: { document: { pages: { [i]: l }, pageStates: { [i]: { selectedIds: Array.from(d.values()).map((e => c[e])) } } } } } }(this, e, t)))), kE(this, "resetBounds", ((e = this.selectedIds) => { let t = HI(this, e, this.currentPageId); return this.setState(HI(this, e, this.currentPageId), t.id) })), kE(this, "toggleHidden", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(jI(this, e, "isHidden")))), kE(this, "toggleLocked", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(jI(this, e, "isLocked")))), kE(this, "toggleAspectRatioLocked", ((e = this.selectedIds) => 0 === e.length ? this : this.setState(jI(this, e, "isAspectRatioLocked")))), kE(this, "toggleDecoration", ((e, t = this.selectedIds) => 0 === t.length || "start" !== e && "end" !== e ? this : this.setState(function (e, t, n) { let { currentPageId: r, selectedIds: i } = e, o = Object.fromEntries(t.map((t => { var r; return [t, { decorations: { [n]: null == (r = e.getShape(t).decorations) ? void 0 : r[n] } }] }))), a = Object.fromEntries(t.filter((t => !e.getShape(t).isLocked)).map((t => { var r; return [t, { decorations: { [n]: (null == (r = e.getShape(t).decorations) ? void 0 : r[n]) ? void 0 : "arrow" } }] }))); return { id: "toggle_decorations", before: { document: { pages: { [r]: { shapes: o } }, pageStates: { [r]: { selectedIds: i } } } }, after: { document: { pages: { [r]: { shapes: a } }, pageStates: { [r]: { selectedIds: t } } } } } }(this, t, e)))), kE(this, "setShapeProps", ((e, t = this.selectedIds) => this.setState(function (e, t, n) { let { currentPageId: r, selectedIds: i } = e, o = t.map((t => e.getShape(t))).filter((e => !!n.isLocked || !e.isLocked)), a = {}, s = {}, l = Object.keys(n); return o.forEach((e => { a[e.id] = Object.fromEntries(l.map((t => [t, e[t]]))), s[e.id] = n })), { id: "set_props", before: { document: { pages: { [r]: { shapes: a } }, pageStates: { [r]: { selectedIds: i } } } }, after: { document: { pages: { [r]: { shapes: s } }, pageStates: { [r]: { selectedIds: i } } } } } }(this, t, e)))), kE(this, "rotate", ((e = -.5 * Math.PI, t = this.selectedIds) => { if (0 === t.length) return this; let n = function (e, t, n = -NI / 4) { let { currentPageId: r } = e, i = {}, o = {}, a = t.flatMap((t => { let n = e.getShape(t); return n.children ? n.children.map((t => e.getShape(t))) : n })).filter((e => !e.isLocked)), s = Zt.getBoundsCenter(Zt.getCommonBounds(a.map((e => ZA.getBounds(e))))); return a.forEach((e => { let t = ZA.getRotatedShapeMutation(e, ZA.getCenter(e), s, n); !t || (i[e.id] = ZA.getBeforeShape(e, t), o[e.id] = t) })), { id: "rotate", before: { document: { pages: { [r]: { shapes: i } }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: { shapes: o } }, pageStates: { [r]: { selectedIds: t } } } } } }(this, t, e); return n ? this.setState(n) : this })), kE(this, "group", ((e = this.selectedIds, t = Zt.uniqueId(), n = this.currentPageId) => { if (this.readOnly) return this; if (1 === e.length && "group" === this.getShape(e[0], n).type) return this.ungroup(e, n); if (e.length < 2) return this; let r = function (e, t, n, r) { var i, o; if (t.length < 2) return; let a = {}, s = {}, l = {}, c = {}, u = [...t], d = [], p = [], h = []; for (let n of t) { let t = e.getShape(n); if (!t.isLocked) if (void 0 === t.children) d.push(t); else { let n = t.children.filter((t => !e.getShape(t).isLocked)); h.push(t), u.push(...n), d.push(...n.map((t => e.getShape(t))).filter(Boolean)) } } if (d.every((e => e.parentId === d[0].parentId)) && d[0].parentId !== r && (null == (i = e.getShape(d[0].parentId).children) ? void 0 : i.length) === u.length) return; let f = ZA.flattenPage(e.state, r), m = Object.fromEntries(d.map((e => [e.id, f.indexOf(e)]))), g = d.sort(((e, t) => m[e.id] - m[t.id])), v = r, y = (g.filter((e => e.parentId === r))[0] || g[0]).childIndex, b = Zt.getCommonBounds(d.map((e => ZA.getBounds(e)))); for (a[n] = void 0, s[n] = ZA.getShapeUtil("group").create({ id: n, childIndex: y, parentId: v, point: [b.minX, b.minY], size: [b.width, b.height], children: g.map((e => e.id)) }), g.forEach(((t, i) => { if (t.parentId !== r) { let n = e.getShape(t.parentId); h.push(n) } a[t.id] = CE(EE({}, a[t.id]), { parentId: t.parentId, childIndex: t.childIndex }), s[t.id] = CE(EE({}, s[t.id]), { parentId: n, childIndex: i + 1 }) })); h.length > 0;) { let t = h.pop(); if (!t) break; let n = ((null == (o = a[t.id]) ? void 0 : o.children) || t.children).filter((e => e && !(u.includes(e) || p.includes(e)))); 0 === n.length ? (a[t.id] = t, s[t.id] = void 0, t.parentId !== r && (p.push(t.id), h.push(e.getShape(t.parentId)))) : (a[t.id] = CE(EE({}, a[t.id]), { children: t.children }), s[t.id] = CE(EE({}, s[t.id]), { children: n })) } let { bindings: w } = e, E = new Set(p); return w.forEach((t => { for (let n of [t.toId, t.fromId]) if (E.has(n)) { l[t.id] = t, c[t.id] = void 0; let r = e.getShape(n); r.handles && Object.values(r.handles).filter((e => e.bindingId === t.id)).forEach((e => { var r, i; a[n] = CE(EE({}, a[n]), { handles: CE(EE({}, null == (r = a[n]) ? void 0 : r.handles), { [e.id]: { bindingId: t.id } }) }), p.includes(n) || (s[n] = CE(EE({}, s[n]), { handles: CE(EE({}, null == (i = s[n]) ? void 0 : i.handles), { [e.id]: { bindingId: void 0 } }) })) })) } })), { id: "group", before: { document: { pages: { [r]: { shapes: a, bindings: l } }, pageStates: { [r]: { selectedIds: t } } } }, after: { document: { pages: { [r]: { shapes: s, bindings: l } }, pageStates: { [r]: { selectedIds: [n] } } } } } }(this, e, t, n); return r ? this.setState(r) : this })), kE(this, "ungroup", ((e = this.selectedIds, t = this.currentPageId) => { if (this.readOnly) return this; let n = e.map((e => this.getShape(e, t))).filter((e => "group" === e.type)); if (0 === n.length) return this; let r = function (e, t, n, r) { let { bindings: i } = e, o = {}, a = {}, s = {}, l = {}, c = t, u = t.filter((e => !n.find((t => t.id === e)))); return n.filter((e => !e.isLocked)).forEach((t => { let n = [], c = []; o[t.id] = t, a[t.id] = void 0, t.children.forEach((t => { u.push(t); let i = e.getShape(t, r); n.push(i) })); let d = t.childIndex, p = (ZA.getChildIndexAbove(e.state, t.id, r) - d) / n.length; n.sort(((e, t) => e.childIndex - t.childIndex)).forEach(((e, t) => { o[e.id] = { parentId: e.parentId, childIndex: e.childIndex }, a[e.id] = { parentId: r, childIndex: d + p * t } })), i.filter((e => e.toId === t.id || e.fromId === t.id)).forEach((t => { for (let n of [t.toId, t.fromId]) if (void 0 === a[n]) { s[t.id] = t, l[t.id] = void 0; let i = e.getShape(n, r); i.handles && Object.values(i.handles).filter((e => e.bindingId === t.id)).forEach((e => { var r, i; o[n] = CE(EE({}, o[n]), { handles: CE(EE({}, null == (r = o[n]) ? void 0 : r.handles), { [e.id]: { bindingId: t.id } }) }), c.includes(n) || (a[n] = CE(EE({}, a[n]), { handles: CE(EE({}, null == (i = a[n]) ? void 0 : i.handles), { [e.id]: { bindingId: void 0 } }) })) })) } })) })), { id: "ungroup", before: { document: { pages: { [r]: { shapes: o, bindings: s } }, pageStates: { [r]: { selectedIds: c } } } }, after: { document: { pages: { [r]: { shapes: a, bindings: s } }, pageStates: { [r]: { selectedIds: u } } } } } }(this, e, n, t); return r ? this.setState(r) : this })), kE(this, "cancel", (() => { var e, t; return null == (t = (e = this.currentTool).onCancel) || t.call(e), this })), kE(this, "addMediaFromFiles", ((e, ...t) => xE(this, [e, ...t], (function* (e, t = this.centerPoint) { this.setIsLoading(!0); let n = [], r = this.getPagePoint(t); for (let r of e) { let e = Zt.uniqueId(), i = r.name.match(/\.[0-9a-z]+$/i); if (!i) throw Error("No extension"); let o = Zk.includes(i[0].toLowerCase()), a = Xk.includes(i[0].toLowerCase()); if (!o && !a) throw Error("Wrong extension"); let s, l = o ? "image" : "video", c = o ? "image" : "video"; try { if (this.callbacks.onAssetCreate) { let t = yield this.callbacks.onAssetCreate(this, r, e); if (!t) throw Error("Asset creation callback returned false"); s = t } else s = yield qI(r); if ("string" == typeof s) { let a = [0, 0]; if (o) { if (".svg" == i[0]) { let e, t = yield JI(r), n = this.getViewboxFromSVG(t); n && (e = n.split(" "), a[0] = parseFloat(e[2]), a[1] = parseFloat(e[3])) } R.isEqual(a, [0, 0]) && (a = yield $I(s)) } else a = yield eP(s); let u, d = Object.values(this.document.assets).find((e => e.type === c && e.src === s)); if (d) u = d.id; else { u = e; let t = { id: u, type: c, name: r.name, src: s, size: a }; this.patchState({ document: { assets: { [u]: t } } }) } n.push(this.getImageOrVideoShapeAtPoint(e, l, t, a, u)) } } catch (e) { console.warn(e) } } if (n.length) { let e = R.add(r, [0, 0]); n.forEach(((t, n) => { let r = ZA.getBounds(t); 0 === n && (e[0] -= r.width / 2, e[1] -= r.height / 2), t.point = [...e], e[0] += r.width })); let t = Zt.getCommonBounds(n.map(ZA.getBounds)); this.createShapes(...n), Zt.boundsContain(this.viewport, t) || (this.zoomToSelection(), this.zoom > 1 && this.resetZoom()) } return this.setIsLoading(!1), this })))), kE(this, "getViewboxFromSVG", (e => { let t = /.*?viewBox=["'](-?[\d.]+[, ]+-?[\d.]+[, ][\d.]+[, ][\d.]+)["']/; if ("string" == typeof e) { let n = e.match(t); return n && n.length >= 2 ? n[1] : null } return this.setIsLoading(!1), null })), kE(this, "onKeyDown", ((e, t, n) => { var r, i; switch (n.key) { case "/": if ("idle" === this.status && !this.pageState.editingId) { let { shiftKey: e, metaKey: n, altKey: r, ctrlKey: i, spaceKey: o } = this; this.onPointerDown({ target: "canvas", pointerId: 0, origin: t.point, point: t.point, delta: [0, 0], pressure: .5, shiftKey: e, ctrlKey: i, metaKey: n, altKey: r, spaceKey: o }, { shiftKey: e, altKey: r, ctrlKey: i, pointerId: 0, clientX: t.point[0], clientY: t.point[1] }) } break; case "Escape": this.cancel(); break; case "Meta": this.metaKey = !0; break; case "Alt": this.altKey = !0; break; case "Control": this.ctrlKey = !0; break; case " ": this.isForcePanning = !0, this.spaceKey = !0 }return null == (i = (r = this.currentTool).onKeyDown) || i.call(r, e, t, n), this })), kE(this, "onKeyUp", ((e, t, n) => { var r, i; if (t) { switch (n.key) { case "/": { let { currentPoint: e, shiftKey: t, metaKey: n, altKey: r, ctrlKey: i, spaceKey: o } = this; this.onPointerUp({ target: "canvas", pointerId: 0, origin: e, point: e, delta: [0, 0], pressure: .5, shiftKey: t, ctrlKey: i, metaKey: n, altKey: r, spaceKey: o }, { shiftKey: t, altKey: r, ctrlKey: i, pointerId: 0, clientX: e[0], clientY: e[1] }); break } case "Meta": this.metaKey = !1; break; case "Alt": this.altKey = !1; break; case "Control": this.ctrlKey = !1; break; case " ": this.isForcePanning = !1, this.spaceKey = !1 }null == (i = (r = this.currentTool).onKeyUp) || i.call(r, e, t, n) } })), kE(this, "refreshBoundingBoxes", (() => { let e = this.shapes.map((e => [e.id, EE({ point: [...e.point] }, "label" in e && { label: "" })])), t = this.shapes.map((e => [e.id, EE({ point: [...e.point] }, "label" in e && { label: e.label })])); ex = "", this.patchState({ document: { pages: { [this.currentPageId]: { shapes: Object.fromEntries(e) } } } }), this.patchState({ document: { pages: { [this.currentPageId]: { shapes: Object.fromEntries(t) } } } }) })), kE(this, "onDragOver", (e => { e.preventDefault() })), kE(this, "onDrop", (e => xE(this, null, (function* () { var t; return e.preventDefault(), this.disableAssets || (null == (t = e.dataTransfer.files) ? void 0 : t.length) && this.addMediaFromFiles(Object.values(e.dataTransfer.files), [e.clientX, e.clientY]), this })))), kE(this, "onPinchStart", ((e, t) => { var n, r; null == (r = (n = this.currentTool).onPinchStart) || r.call(n, e, t) })), kE(this, "onPinchEnd", ((e, t) => { var n, r; return null == (r = (n = this.currentTool).onPinchEnd) ? void 0 : r.call(n, e, t) })), kE(this, "onPinch", ((e, t) => { var n, r; return null == (r = (n = this.currentTool).onPinch) ? void 0 : r.call(n, e, t) })), kE(this, "onPan", ((e, t) => { if ("pinching" === this.appState.status) return; let n = R.div(e.delta, this.camera.zoom), r = this.camera.point, i = R.sub(r, n); R.isEqual(i, r) || (this.pan(n), this.isForcePanning || this.onPointerMove(e, t), Gk && this.isForcePanning && this.preventPaste()) })), kE(this, "onZoom", ((e, t) => { if ("idle" !== this.state.appState.status) return; let n = e.delta[2] / 50; this.zoomBy(n, e.point), this.onPointerMove(e, t) })), kE(this, "updateInputs", (e => { this.currentPoint = this.getPagePoint(e.point).concat(e.pressure), this.shiftKey = e.shiftKey, this.altKey = e.altKey, this.ctrlKey = e.ctrlKey, this.metaKey = e.metaKey })), kE(this, "onPointerMove", ((e, t) => { var n, r, i, o, a; if (this.previousPoint = this.currentPoint, this.updateInputs(e, t), this.isForcePanning && this.isPointing) null == (n = this.onPan) || n.call(this, CE(EE({}, e), { delta: R.neg(e.delta) }), t); else if (null == (i = (r = this.currentTool).onPointerMove) || i.call(r, e, t), this.state.room) { let { users: t, userId: n } = this.state.room; null == (a = (o = this.callbacks).onChangePresence) || a.call(o, this, CE(EE({}, t[n]), { point: this.getPagePoint(e.point), session: !!this.session })) } })), kE(this, "onPointerDown", ((e, t) => { var n, r; if (4 === t.buttons) this.isForcePanning = !0; else if (this.isPointing) return; this.isPointing = !0, this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), !this.isForcePanning && ("draw" === this.currentTool.type && "pen" === t.pointerType && 5 === t.button && (this.selectTool("erase"), this.isErasingWithPen = !0), null == (r = (n = this.currentTool).onPointerDown) || r.call(n, e, t)) })), kE(this, "onPointerUp", ((e, t) => { var n, r; this.isPointing = !1, this.shiftKey || (this.isForcePanning = !1), this.updateInputs(e, t), null == (r = (n = this.currentTool).onPointerUp) || r.call(n, e, t), this.isErasingWithPen && "pen" === t.pointerType && 5 === t.button && (this.selectTool("draw"), this.isErasingWithPen = !1) })), kE(this, "onPointCanvas", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onPointCanvas) || r.call(n, e, t) })), kE(this, "onDoubleClickCanvas", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onDoubleClickCanvas) || r.call(n, e, t) })), kE(this, "onRightPointCanvas", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onRightPointCanvas) || r.call(n, e, t) })), kE(this, "onDragCanvas", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onDragCanvas) || r.call(n, e, t) })), kE(this, "onReleaseCanvas", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onReleaseCanvas) || r.call(n, e, t) })), kE(this, "onPointShape", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onPointShape) || r.call(n, e, t) })), kE(this, "onReleaseShape", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onReleaseShape) || r.call(n, e, t) })), kE(this, "onDoubleClickShape", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onDoubleClickShape) || r.call(n, e, t) })), kE(this, "onRightPointShape", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onRightPointShape) || r.call(n, e, t) })), kE(this, "onDragShape", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onDragShape) || r.call(n, e, t) })), kE(this, "onHoverShape", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onHoverShape) || r.call(n, e, t) })), kE(this, "onUnhoverShape", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onUnhoverShape) || r.call(n, e, t) })), kE(this, "onPointBounds", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onPointBounds) || r.call(n, e, t) })), kE(this, "onDoubleClickBounds", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onDoubleClickBounds) || r.call(n, e, t) })), kE(this, "onRightPointBounds", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onRightPointBounds) || r.call(n, e, t) })), kE(this, "onDragBounds", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onDragBounds) || r.call(n, e, t) })), kE(this, "onHoverBounds", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onHoverBounds) || r.call(n, e, t) })), kE(this, "onUnhoverBounds", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onUnhoverBounds) || r.call(n, e, t) })), kE(this, "onReleaseBounds", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onReleaseBounds) || r.call(n, e, t) })), kE(this, "onPointBoundsHandle", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onPointBoundsHandle) || r.call(n, e, t) })), kE(this, "onDoubleClickBoundsHandle", ((e, t) => { var n, r; if (this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onDoubleClickBoundsHandle) || r.call(n, e, t), 1 !== this.selectedIds.length) return; let i = this.getShape(this.selectedIds[0]); if ("image" === i.type || "video" === i.type) { let e = this.document.assets[i.assetId], t = ZA.getShapeUtil(i), n = t.getCenter(i), r = t.getCenter(CE(EE({}, i), { size: e.size })), o = R.sub(r, n); this.updateShapes({ id: i.id, point: R.sub(i.point, o), size: e.size }) } })), kE(this, "onRightPointBoundsHandle", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onRightPointBoundsHandle) || r.call(n, e, t) })), kE(this, "onDragBoundsHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onDragBoundsHandle) || r.call(n, e, t) })), kE(this, "onHoverBoundsHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onHoverBoundsHandle) || r.call(n, e, t) })), kE(this, "onUnhoverBoundsHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onUnhoverBoundsHandle) || r.call(n, e, t) })), kE(this, "onReleaseBoundsHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onReleaseBoundsHandle) || r.call(n, e, t) })), kE(this, "onPointHandle", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onPointHandle) || r.call(n, e, t) })), kE(this, "onDoubleClickHandle", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onDoubleClickHandle) || r.call(n, e, t) })), kE(this, "onRightPointHandle", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onRightPointHandle) || r.call(n, e, t) })), kE(this, "onDragHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onDragHandle) || r.call(n, e, t) })), kE(this, "onHoverHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onHoverHandle) || r.call(n, e, t) })), kE(this, "onUnhoverHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onUnhoverHandle) || r.call(n, e, t) })), kE(this, "onReleaseHandle", ((e, t) => { var n, r; this.updateInputs(e, t), null == (r = (n = this.currentTool).onReleaseHandle) || r.call(n, e, t) })), kE(this, "onShapeChange", (e => { let t = this.document.pages[this.currentPageId].shapes, n = UI(this, [EE(EE({}, t[e.id]), e)], this.currentPageId).after; return this.patchState(n, "patched_shapes") })), kE(this, "onShapeBlur", (() => { var e, t; if (performance.now() - this.editingStartTime < 50) return; let { editingId: n } = this.pageState, { isToolLocked: r } = this.getAppState(); if (n) { let e = this.getShape(n); this.setEditingId(), "text" === e.type && (e.text.trim().length <= 0 ? this.patchState(OI(this, [n]).after, "delete_empty_text") : r || this.select(n)) } null == (t = (e = this.currentTool).onShapeBlur) || t.call(e) })), kE(this, "onShapeClone", ((e, t) => { var n, r; this.originPoint = this.getPagePoint(e.point).concat(e.pressure), this.updateInputs(e, t), null == (r = (n = this.currentTool).onShapeClone) || r.call(n, e, t) })), kE(this, "onRenderCountChange", (e => { let t = this.getAppState(); t.isEmptyCanvas && e.length > 0 ? this.patchState({ appState: { isEmptyCanvas: !1 } }, "empty_canvas:false") : !t.isEmptyCanvas && e.length <= 0 && this.patchState({ appState: { isEmptyCanvas: !0 } }, "empty_canvas:true") })), kE(this, "onError", (() => { })), kE(this, "getShapeUtil", ZA.getShapeUtil), this.callbacks = t } setStatus(e) { return this.patchState({ appState: { status: e } }, `set_status:${e}`) } get isMenuOpen() { return this.appState.isMenuOpen } get isLoading() { return this.appState.isLoading } get disableAssets() { return this.appState.disableAssets } get history() { return this.stack.slice(0, this.pointer + 1) } set history(e) { this.replaceHistory(e) } get document() { return this.state.document } get settings() { return this.state.settings } get appState() { return this.state.appState } get currentPageId() { return this.state.appState.currentPageId } get page() { return this.state.document.pages[this.currentPageId] } get shapes() { return Object.values(this.page.shapes) } get bindings() { return Object.values(this.page.bindings) } get assets() { return Object.values(this.document.assets) } get pageState() { return this.state.document.pageStates[this.currentPageId] } get camera() { return this.pageState.camera } get zoom() { return this.pageState.camera.zoom } get selectedIds() { return this.pageState.selectedIds } createTextShapeAtPoint(e, t, n) { let { shapes: r, appState: { currentPageId: i, currentStyle: o } } = this, a = 0 === r.length ? 1 : r.filter((e => e.parentId === i)).sort(((e, t) => t.childIndex - e.childIndex))[0].childIndex + 1, s = WA.text, l = s.create({ id: t || Zt.uniqueId(), parentId: i, childIndex: a, point: e, style: EE({}, o) }), c = s.getBounds(l); return l.point = R.sub(l.point, [c.width / 2, c.height / 2]), n ? this.patchCreate([ZA.getShapeUtil(l.type).create(l)]) : this.createShapes(l), this.setEditingId(l.id, !0), this } getImageOrVideoShapeAtPoint(e, t, n, r, i) { let { shapes: o, appState: { currentPageId: a, currentStyle: s } } = this, l = 0 === o.length ? 1 : o.filter((e => e.parentId === a)).sort(((e, t) => t.childIndex - e.childIndex))[0].childIndex + 1, c = WA[t]; if (r[0] > this.viewport.width) { let e = r[1] / r[0]; r[0] = this.viewport.width - 128 / this.camera.zoom * 2, r[1] = r[0] * e, (r[1] < 32 || r[1] < 32) && (r[1] = 32, r[0] = r[1] / e) } else if (r[1] > this.viewport.height) { let e = r[0] / r[1]; r[1] = this.viewport.height - 128 / this.camera.zoom * 2, r[0] = r[1] * e, (r[1] < 32 || r[1] < 32) && (r[0] = 32, r[1] = r[0] / e) } return c.create({ id: e, parentId: a, childIndex: l, point: n, size: r, style: EE({}, s), assetId: i }) } isSelected(e) { return this.selectedIds.includes(e) } serializeVideo(e) { let t = document.getElementById(e + "_video"); if (t) { let e = document.createElement("canvas"); return e.width = t.videoWidth, e.height = t.videoHeight, e.getContext("2d").drawImage(t, 0, 0), e.toDataURL("image/png") } throw new Error("Video with id " + e + " not found") } serializeImage(e) { let t = document.getElementById(e + "_image"); if (t) { let e = document.createElement("canvas"); return e.width = t.width, e.height = t.height, e.getContext("2d").drawImage(t, 0, 0), e.toDataURL("image/png") } throw new Error("Image with id " + e + " not found") } patchAssets(e) { this.document.assets = EE(EE({}, this.document.assets), e) } get room() { return this.state.room } get isLocal() { return void 0 === this.state.room || "local" === this.state.room.id } get status() { return this.appState.status } get currentUser() { if (this.state.room) return this.state.room.users[this.state.room.userId] } get centerPoint() { let { width: e, height: t } = this.rendererBounds; return R.toFixed([e / 2, t / 2]) } get currentGrid() { let { zoom: e } = this.camera; return e < .15 ? 128 : e < 1 ? 32 : 8 } }, gP = mP; kE(gP, "version", 15.5), kE(gP, "defaultDocument", { id: "doc", name: "New Document", version: mP.version, pages: { page: { id: "page", name: "Page 1", childIndex: 1, shapes: {}, bindings: {} } }, pageStates: { page: { id: "page", selectedIds: [], camera: { point: [0, 0], zoom: 1 } } }, assets: {} }), kE(gP, "defaultState", { settings: { isCadSelectMode: !1, isPenMode: !1, isDarkMode: !1, isZoomSnap: !1, isFocusMode: !1, isSnapping: !1, isDebugMode: !1, isReadonlyMode: !1, keepStyleMenuOpen: !1, nudgeDistanceLarge: 16, nudgeDistanceSmall: 1, showRotateHandles: !0, showBindingHandles: !0, showCloneHandles: !1, showGrid: !1, language: "en", dockPosition: "bottom", exportBackground: "transparent" }, appState: { status: "idle", activeTool: "select", hoveredId: void 0, currentPageId: "page", currentStyle: Ax, isToolLocked: !1, isMenuOpen: !1, isEmptyCanvas: !1, eraseLine: [], snapLines: [], isLoading: !1, disableAssets: !1 }, document: mP.defaultDocument }), kE(gP, "assetSrc", "tldraw-assets.json"); var vP = Zn.ErrorBoundary, yP = !!window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches; function bP({ id: e, document: t, currentPageId: n, autofocus: r = !0, showMenu: i = !0, showMultiplayerMenu: o = !0, showPages: a = !0, showTools: s = !0, showZoom: l = !0, showStyles: c = !0, showUI: u = !0, readOnly: d = !1, disableAssets: p = !1, darkMode: h = yP, components: f, onMount: m, onChange: g, onChangePresence: v, onNewProject: y, onSaveProject: b, onSaveProjectAs: w, onOpenProject: E, onOpenMedia: C, onUndo: S, onRedo: k, onPersist: x, onPatch: I, onCommand: P, onChangePage: M, onAssetCreate: T, onAssetDelete: R, onAssetUpload: B, onSessionStart: D, onSessionEnd: L, onExport: O, hideCursors: F }) { let [z, H] = A.useState(e), [N, j] = A.useState((() => new gP(e, { onMount: m, onChange: g, onChangePresence: v, onNewProject: y, onSaveProject: b, onSaveProjectAs: w, onOpenProject: E, onOpenMedia: C, onUndo: S, onRedo: k, onPersist: x, onPatch: I, onCommand: P, onChangePage: M, onAssetDelete: R, onAssetCreate: T, onAssetUpload: B, onSessionStart: D, onSessionEnd: L }))), [U, V] = A.useState(null), [K, W] = A.useState(null), [Y, G] = A.useState(null), [Z, X] = A.useState(null), _ = A.useCallback(((e, t, n, r) => { X((() => e)), V((() => r)), W((() => t)), G((() => n)) }), []); return A.useLayoutEffect((() => { if (e === z) return; let t = new gP(e, { onMount: m, onChange: g, onChangePresence: v, onNewProject: y, onSaveProject: b, onSaveProjectAs: w, onOpenProject: E, onOpenMedia: C, onUndo: S, onRedo: k, onPersist: x, onPatch: I, onCommand: P, onChangePage: M, onAssetDelete: R, onAssetCreate: T, onAssetUpload: B, onExport: O, onSessionStart: D, onSessionEnd: L }); H(e), j(t) }), [z, e]), A.useEffect((() => { !t || (t.id === N.document.id ? N.updateDocument(t) : N.loadDocument(t)) }), [t, N]), A.useEffect((() => { N.setDisableAssets(p) }), [N, p]), A.useEffect((() => { !n || N.changePage(n) }), [n, N]), A.useEffect((() => { N.readOnly = d, d || (N.selectNone(), N.cancelSession(), N.setEditingId()) }), [N, d]), A.useEffect((() => { h !== N.settings.isDarkMode && N.toggleDarkMode() }), [N, h]), A.useEffect((() => { N.callbacks = { onMount: m, onChange: g, onChangePresence: v, onNewProject: y, onSaveProject: b, onSaveProjectAs: w, onOpenProject: E, onOpenMedia: C, onUndo: S, onRedo: k, onPersist: x, onPatch: I, onCommand: P, onChangePage: M, onAssetDelete: R, onAssetCreate: T, onAssetUpload: B, onExport: O, onSessionStart: D, onSessionEnd: L } }), [m, g, v, y, b, w, E, C, S, k, x, I, P, M, R, T, B, O, D, L]), A.useLayoutEffect((() => { var e; if ("undefined" != typeof window && (null == (e = window.document) ? void 0 : e.fonts)) return window.document.fonts.addEventListener("loadingdone", t), () => { window.document.fonts.removeEventListener("loadingdone", t) }; function t() { N.refreshBoundingBoxes() } }), [N]), A.createElement(uC.Provider, { value: N }, A.createElement(vC.Provider, { value: { onYes: K, onCancel: U, onNo: Y, dialogState: Z, setDialogState: X, openDialog: _ } }, A.createElement(wP, { key: z || "Tldraw", id: z, autofocus: r, showPages: a, showMenu: i, showMultiplayerMenu: o, showStyles: c, showZoom: l, showTools: s, showUI: u, readOnly: d, components: f, hideCursors: F }))) } var wP = A.memo((function ({ id: e, autofocus: t, showPages: n, showMenu: r, showMultiplayerMenu: i, showZoom: o, showStyles: a, showTools: s, readOnly: l, showUI: c, components: u, hideCursors: d }) { var p, h; let f = pC(), [m, g] = A.useState(null), v = A.useRef(null), y = f.useStore(), { document: b, settings: w, appState: E, room: C } = y, S = "select" === y.appState.activeTool, k = b.pages[E.currentPageId], x = b.pageStates[k.id], I = b.assets, { selectedIds: P } = x, M = 1 === P.length && k.shapes[P[0]] && ZA.getShapeUtil(k.shapes[P[0]].type).hideBounds, T = 1 === P.length && k.shapes[P[0]] && ZA.getShapeUtil(k.shapes[P[0]].type).hideResizeHandles, R = A.useMemo((() => ({ isDarkMode: w.isDarkMode })), [w.isDarkMode]), B = w.isCadSelectMode ? !E.selectByContain : E.selectByContain, D = A.useMemo((() => { let { selectByContain: e } = E, { isDarkMode: t, isCadSelectMode: n } = w; if (t) { let t = n ? e ? "69, 155, 255" : "105, 209, 73" : "180, 180, 180"; return { brushFill: `rgba(${t}, ${n ? .08 : .05})`, brushStroke: `rgba(${t}, ${n ? .5 : .25})`, brushDashStroke: `rgba(${t}, .6)`, selected: "rgba(38, 150, 255, 1.000)", selectFill: "rgba(38, 150, 255, 0.05)", background: "#212529", foreground: "#49555f" } } let r = n ? e ? "0, 89, 242" : "51, 163, 23" : "0,0,0"; return { brushFill: `rgba(${r}, ${n ? .08 : .05})`, brushStroke: `rgba(${r}, ${n ? .4 : .25})`, brushDashStroke: `rgba(${r}, .6)` } }), [w.isDarkMode, w.isCadSelectMode, E.selectByContain]), L = void 0 !== f.session, O = L && "BrushSession" !== (null == (p = f.session) ? void 0 : p.constructor.name) || !S || M || !!x.editingId, F = L || !S, z = L && "brushing" !== y.appState.status || !S, H = L || !S || x.camera.zoom < .2, N = function (e) { return A.useMemo((() => function (e) { var t; let n = gC.find((t => t.locale === e)); return { locale: e, label: null != (t = null == n ? void 0 : n.label) ? t : e, messages: EE(EE({}, mC), null == n ? void 0 : n.messages) } }(null != e ? e : navigator.language.split(/[-_]/)[0])), [e]) }(w.language); return A.useLayoutEffect((() => { let e = v.current; !e || (w.isDarkMode ? e.classList.add(PE) : e.classList.remove(PE)) }), [w.isDarkMode]), function (e) { A.useEffect((() => { let t = !1, n = !1, r = e.current; if (!r) return; let i = e => { " " === e.key && !n && (n = !0, t ? r.setAttribute("style", "cursor: grabbing !important") : r.setAttribute("style", "cursor: grab !important")) }, o = e => { " " === e.key && (n = !1, r.setAttribute("style", "cursor: initial")) }, a = e => { t = !0, 1 === e.button && r.setAttribute("style", "cursor: grabbing !important"), 0 === e.button && n && r.setAttribute("style", "cursor: grabbing !important") }, s = () => { t = !1, n ? r.setAttribute("style", "cursor: grab !important") : r.setAttribute("style", "cursor: initial") }; return r.addEventListener("keydown", i), r.addEventListener("keyup", o), r.addEventListener("pointerdown", a), r.addEventListener("pointerup", s), () => { r.removeEventListener("keydown", i), r.removeEventListener("keyup", o), r.removeEventListener("pointerdown", a), r.removeEventListener("pointerup", s) } }), [e.current]) }(v), A.createElement(hC.Provider, { value: v }, A.createElement(yo, { locale: N.locale, messages: N.messages }, A.createElement(nS, { container: m }), A.createElement(CP, { ref: v, tabIndex: -0 }, A.createElement(XC, null), A.createElement(EP, { focusableRef: v, autofocus: t }), A.createElement(NC, null, A.createElement(vP, { FallbackComponent: jC }, A.createElement(Wn, { id: e, containerRef: v, shapeUtils: WA, page: k, pageState: x, assets: I, snapLines: E.snapLines, eraseLine: E.eraseLine, grid: 8, users: null == C ? void 0 : C.users, userId: null == C ? void 0 : C.userId, theme: D, meta: R, components: u, hideCursors: d, hideBounds: O, hideHandles: F, hideResizeHandles: T, hideIndicators: z, hideBindingHandles: !w.showBindingHandles, hideCloneHandles: H, hideRotateHandles: !w.showRotateHandles, hideGrid: !w.showGrid, showDashedBrush: B, performanceMode: null == (h = f.session) ? void 0 : h.performanceMode, onPinchStart: f.onPinchStart, onPinchEnd: f.onPinchEnd, onPinch: f.onPinch, onPan: f.onPan, onZoom: f.onZoom, onPointerDown: f.onPointerDown, onPointerMove: f.onPointerMove, onPointerUp: f.onPointerUp, onPointCanvas: f.onPointCanvas, onDoubleClickCanvas: f.onDoubleClickCanvas, onRightPointCanvas: f.onRightPointCanvas, onDragCanvas: f.onDragCanvas, onReleaseCanvas: f.onReleaseCanvas, onPointShape: f.onPointShape, onDoubleClickShape: f.onDoubleClickShape, onRightPointShape: f.onRightPointShape, onDragShape: f.onDragShape, onHoverShape: f.onHoverShape, onUnhoverShape: f.onUnhoverShape, onReleaseShape: f.onReleaseShape, onPointBounds: f.onPointBounds, onDoubleClickBounds: f.onDoubleClickBounds, onRightPointBounds: f.onRightPointBounds, onDragBounds: f.onDragBounds, onHoverBounds: f.onHoverBounds, onUnhoverBounds: f.onUnhoverBounds, onReleaseBounds: f.onReleaseBounds, onPointBoundsHandle: f.onPointBoundsHandle, onDoubleClickBoundsHandle: f.onDoubleClickBoundsHandle, onRightPointBoundsHandle: f.onRightPointBoundsHandle, onDragBoundsHandle: f.onDragBoundsHandle, onHoverBoundsHandle: f.onHoverBoundsHandle, onUnhoverBoundsHandle: f.onUnhoverBoundsHandle, onReleaseBoundsHandle: f.onReleaseBoundsHandle, onPointHandle: f.onPointHandle, onDoubleClickHandle: f.onDoubleClickHandle, onRightPointHandle: f.onRightPointHandle, onDragHandle: f.onDragHandle, onHoverHandle: f.onHoverHandle, onUnhoverHandle: f.onUnhoverHandle, onReleaseHandle: f.onReleaseHandle, onError: f.onError, onRenderCountChange: f.onRenderCountChange, onShapeChange: f.onShapeChange, onShapeBlur: f.onShapeBlur, onShapeClone: f.onShapeClone, onBoundsChange: f.updateBounds, onKeyDown: f.onKeyDown, onKeyUp: f.onKeyUp, onDragOver: f.onDragOver, onDrop: f.onDrop }))), c && A.createElement(SP, { ref: g }, w.isFocusMode ? A.createElement(YC, { onSelect: f.toggleFocusMode }) : A.createElement(A.Fragment, null, A.createElement(TI, { readOnly: l, showPages: n, showMenu: r, showMultiplayerMenu: i, showStyles: a, showZoom: o }), A.createElement(kP, null), s && !l && A.createElement(Ik, null)))))) })), EP = A.memo((function ({ focusableRef: e, autofocus: t }) { return function (e) { let t = pC(), n = A.useCallback(((n = !1) => { let r = e.current; return !(!n || !t.isMenuOpen && !t.settings.keepStyleMenuOpen) || r && (document.activeElement === r || r.contains(document.activeElement)) }), [e]); A.useEffect((() => { if (!t) return; let e = e => { if (n(!0)) { if (t.readOnly) return void t.copy(void 0, e); t.cut(void 0, e) } }, r = e => { !n(!0) || t.copy(void 0, e) }, i = e => { !n(!0) || t.readOnly || t.paste(void 0, e) }; return document.addEventListener("cut", e), document.addEventListener("copy", r), document.addEventListener("paste", i), () => { document.removeEventListener("cut", e), document.removeEventListener("copy", r), document.removeEventListener("paste", i) } }), [t]), Vv("v,1", (() => { !n(!0) || t.selectTool("select") }), [t, e.current]), Vv("d,p,2", (() => { !n(!0) || t.selectTool("draw") }), void 0, [t]), Vv("e,3", (() => { !n(!0) || t.selectTool("erase") }), void 0, [t]), Vv("r,4", (() => { !n(!0) || t.selectTool("rectangle") }), void 0, [t]), Vv("o,5", (() => { !n(!0) || t.selectTool("ellipse") }), void 0, [t]), Vv("g,6", (() => { !n() || t.selectTool("triangle") }), void 0, [t]), Vv("l,7", (() => { !n(!0) || t.selectTool("line") }), void 0, [t]), Vv("a,8", (() => { !n(!0) || t.selectTool("arrow") }), void 0, [t]), Vv("t,9", (() => { !n(!0) || t.selectTool("text") }), void 0, [t]), Vv("s,0", (() => { !n(!0) || t.selectTool("sticky") }), void 0, [t]), Vv("ctrl+shift+d,+shift+d", (e => { !n(!0) || (t.toggleDarkMode(), e.preventDefault()) }), void 0, [t]), Vv("ctrl+.,+.", (() => { !n(!0) || t.toggleFocusMode() }), void 0, [t]), Vv("ctrl+shift+g,+shift+g", (() => { !n(!0) || t.toggleGrid() }), void 0, [t]); let { onNewProject: r, onOpenProject: i, onSaveProject: o, onSaveProjectAs: a, onOpenMedia: s } = KE(); Vv("ctrl+n,+n", (e => { e.preventDefault(), n() && r(e) }), void 0, [t]), Vv("ctrl+s,+s", (e => { !n() || o(e) }), void 0, [t]), Vv("ctrl+shift+s,+shift+s", (e => { !n() || a(e) }), void 0, [t]), Vv("ctrl+alt+1,+alt+1", (e => { !n() || t.exportImage("svg", { scale: 2, quality: 1 }) }), void 0, [t]), Vv("ctrl+alt+2,+alt+2", (e => { !n() || t.exportImage("png", { scale: 2, quality: 1 }) }), void 0, [t]), Vv("ctrl+alt+3,+alt+3", (e => { !n() || t.exportImage("jpeg", { scale: 2, quality: 1 }) }), void 0, [t]), Vv("ctrl+alt+4,+alt+4", (e => { !n() || t.exportImage("webp", { scale: 2, quality: 1 }) }), void 0, [t]), Vv("ctrl+alt+5,+alt+5", (e => { !n() || t.exportJson() }), void 0, [t]), Vv("ctrl+o,+o", (e => { !n() || i(e) }), void 0, [t]), Vv("ctrl+u,+u", (e => { !n() || s(e) }), void 0, [t]), Vv("+z,ctrl+z", (e => { e.preventDefault(), n(!0) && (t.session ? t.cancelSession() : t.undo()) }), void 0, [t]), Vv("ctrl+shift+z,+shift+z", (() => { !n(!0) || (t.session ? t.cancelSession() : t.redo()) }), void 0, [t]), Vv("+u,ctrl+u", (() => { !n() || t.undoSelect() }), void 0, [t]), Vv("ctrl+shift-u,+shift+u", (() => { !n() || t.redoSelect() }), void 0, [t]), Vv("ctrl+=,+=,ctrl+num_add,+num_add", (e => { !n(!0) || (t.zoomIn(), e.preventDefault()) }), void 0, [t]), Vv("ctrl+-,+-,ctrl+num_subtract,+num_subtract", (e => { !n(!0) || (t.zoomOut(), e.preventDefault()) }), void 0, [t]), Vv("shift+0,ctrl+numpad_0,+numpad_0", (() => { !n(!0) || t.resetZoom() }), void 0, [t]), Vv("shift+1", (() => { !n(!0) || t.zoomToFit() }), void 0, [t]), Vv("shift+2", (() => { !n(!0) || t.zoomToSelection() }), void 0, [t]), Vv("ctrl+d,+d", (e => { !n() || (t.duplicate(), e.preventDefault()) }), void 0, [t]), Vv("shift+h", (() => { !n(!0) || t.flipHorizontal() }), void 0, [t]), Vv("shift+v", (() => { !n(!0) || t.flipVertical() }), void 0, [t]), Vv("escape", (() => { !n(!0) || t.cancel() }), void 0, [t]), Vv("backspace,del", (() => { !n() || t.delete() }), void 0, [t]), Vv("+a,ctrl+a", (() => { !n(!0) || t.selectAll() }), void 0, [t]), Vv("up", (() => { !n() || t.nudge([0, -1], !1) }), void 0, [t]), Vv("right", (() => { !n() || t.nudge([1, 0], !1) }), void 0, [t]), Vv("down", (() => { !n() || t.nudge([0, 1], !1) }), void 0, [t]), Vv("left", (() => { !n() || t.nudge([-1, 0], !1) }), void 0, [t]), Vv("shift+up", (() => { !n() || t.nudge([0, -1], !0) }), void 0, [t]), Vv("shift+right", (() => { !n() || t.nudge([1, 0], !0) }), void 0, [t]), Vv("shift+down", (() => { !n() || t.nudge([0, 1], !0) }), void 0, [t]), Vv("shift+left", (() => { !n() || t.nudge([-1, 0], !0) }), void 0, [t]), Vv("+shift+l,ctrl+shift+l", (() => { !n() || t.toggleLocked() }), void 0, [t]), Vv("+shift+c,ctrl+shift+c", (e => { !n() || (t.copySvg(), e.preventDefault()) }), void 0, [t]), Vv("+g,ctrl+g", (e => { !n() || (t.group(), e.preventDefault()) }), void 0, [t]), Vv("+shift+g,ctrl+shift+g", (e => { !n() || (t.ungroup(), e.preventDefault()) }), void 0, [t]), Vv("[", (() => { !n(!0) || t.moveBackward() }), void 0, [t]), Vv("]", (() => { !n(!0) || t.moveForward() }), void 0, [t]), Vv("shift+[", (() => { !n(!0) || t.moveToBack() }), void 0, [t]), Vv("shift+]", (() => { !n(!0) || t.moveToFront() }), void 0, [t]), Vv("ctrl+shift+backspace,+shift+backspace", (e => { !n() || (t.settings.isDebugMode && t.resetDocument(), e.preventDefault()) }), void 0, [t]), Vv("alt+command+l,alt+ctrl+l", (e => { !n(!0) || (t.style({ textAlign: "start" }), e.preventDefault()) }), void 0, [t]), Vv("alt+command+t,alt+ctrl+t", (e => { !n(!0) || (t.style({ textAlign: "middle" }), e.preventDefault()) }), void 0, [t]), Vv("alt+command+r,alt+ctrl+r", (e => { !n(!0) || (t.style({ textAlign: "end" }), e.preventDefault()) }), void 0, [t]) }(e), A.useEffect((() => { var n; t && (null == (n = e.current) || n.focus()) }), [t]), null })), CP = AE("div", { position: "absolute", height: "100%", width: "100%", minHeight: 0, minWidth: 0, maxHeight: "100%", maxWidth: "100%", overflow: "hidden", boxSizing: "border-box", outline: "none", userSelect: "none", WebkitUserSelect: "none", "& .tl-container": { position: "absolute", top: 0, left: 0, height: "100%", width: "100%", zIndex: 1 }, "& input, textarea, button, select, label, button": { webkitTouchCallout: "none", webkitUserSelect: "none", "-webkit-tap-highlight-color": "transparent", "tap-highlight-color": "transparent" } }), SP = AE("div", { position: "absolute", top: 0, left: 0, height: "100%", width: "100%", padding: "8px 8px 0 8px", display: "flex", alignItems: "flex-start", justifyContent: "flex-start", pointerEvents: "none", zIndex: 2, "& > *": { pointerEvents: "all" } }), kP = AE("div", { flexGrow: 2 })
        }
      }, r = {}; function i(e) { var t = r[e]; if (void 0 !== t) return t.exports; var o = r[e] = { id: e, exports: {} }; return n[e].call(o.exports, o, o.exports, i), o.exports } i.m = n, i.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return i.d(t, { a: t }), t }, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, i.t = function (n, r) { if (1 & r && (n = this(n)), 8 & r) return n; if ("object" == typeof n && n) { if (4 & r && n.__esModule) return n; if (16 & r && "function" == typeof n.then) return n } var o = Object.create(null); i.r(o); var a = {}; e = e || [null, t({}), t([]), t(t)]; for (var s = 2 & r && n; "object" == typeof s && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach((e => a[e] = () => n[e])); return a.default = () => n, i.d(o, a), o }, i.d = (e, t) => { for (var n in t) i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, { enumerable: !0, get: t[n] }) }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, i.p = "", i.b = document.baseURI || self.location.href, i.nc = void 0, i(2629)
    })();</script>
</body>

</html>